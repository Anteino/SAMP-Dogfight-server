<?xml version="1.0" encoding="ISO-8859-1"?>
<?xml-stylesheet href="file:///C|/Users/gebruiker/Google Drive/SAMP dog fight server/pawno/xml/pawndoc.xsl" type="text/xsl"?>
<doc source=".\gamemodes\dogfight.pwn">
	<assembly>
		<name>dogfight.pwn</name>
	</assembly>

	<!-- general -->
	<general>
		<library name="y_commands">  <section>  Description  </section>  Runs commands registered with the system and calls the required functions.  Also handles alternate names and prefixes.  Based very loosely on dcmd.  <section>  Version  </section>  0.1.4  <section>  Functions  </section>  <subsection>  Public  </subsection><ul>  <symbol name="Command_Add">Adds a command to the array for processing.</symbol>  <symbol name="Command_Remove">Removes a command.</symbol>  <symbol name="Command_Name">Gets the name of a command in a property.</symbol>  </ul><subsection>  Core  </subsection><ul>  <symbol name="Command_Process">Called from OnPlayerCommandText to process entered commands.</symbol>  <symbol name="Command_Parse">Sorts added commands into a binary tree.</symbol>  <symbol name="Command_Hash">Hashes a word for command hashing.</symbol>  <symbol name="Command_ProcRem">Processes a help command in the master script.</symbol>  </ul><subsection>  Stock  </subsection><ul>  <symbol name="Command_SetDisconnectReturn">Sets the return value for unconnected players.</symbol>  <symbol name="Command_UseShortCuts">Toggles use of per-player command shortcuts.</symbol>  <symbol name="Command_SetDeniedReturn">Sets the return value for denied use commands.</symbol>  <symbol name="Command_UseDeniedMessage">Toggles the use of an error message for denied.</symbol>  <symbol name="Command_SetIllegalReturn">Sets the return value for illegal characters.</symbol>  <symbol name="Command_UseAltNames">Toggles the use of ini defined alternate names.</symbol>  <symbol name="Command_UsePrefix">Toggles the use of a global prefix.</symbol>  <symbol name="Command_UseSpace">Toggles the use of a space between prefix and command.</symbol>  <symbol name="Command_SetAltName">Sets the alternate name of a function.</symbol>  <symbol name="Command_SetPrefix">Sets the pfexix to be typed.</symbol>  <symbol name="Comamnd_SetPlayerUse">Sets wether or not a player can use a command.</symbol>  <symbol name="Comamnd_SetPlayerUseByID">Sets wether or not a player can use a command.</symbol>  <symbol name="Command_FindByName">Finds a command in a possibly sorted list.</symbol>  </ul><section>  Definitions  </section><ul>  <symbol name="MAX_COMMAND_LENGTH">The maximum length of a command string.</symbol>  <symbol name="COMMAND_NOT_FOUND">Indicates that a searched for string is not a function.</symbol>  </ul><section>  Enums  </section><ul>  <symbol name="e_COMM_FLAG">Bit mappings for command options.</symbol>  <symbol name="E_COMMANDS">Structure of the array holding the string data.</symbol>  </ul><section>  Macros  </section><ul>  <symbol name="Command_(%1)">Forwards and declares a standard command for calling.</symbol>  <symbol name="ycmd(%1)">Adds a command to the array (wrapper for Command_Add).</symbol>  </ul><section>  Tags  </section><ul>  <symbol name="e_COMM_FLAG">Flag type.</symbol>  </ul><section>  Variables  </section>  <subsection>  Static  </subsection><ul>  <symbol name="YSI_g_sCommands">Holds all the textual data of the commands.</symbol>  <symbol name="YSI_g_sSearchTree">Tree of hashes for function names.</symbol>  <symbol name="YSI_g_sAltTree">Tree of hashes for alternate names.</symbol>  <symbol name="YSI_g_sPrefix">The command prefix.</symbol>  <symbol name="YSI_g_sPrefixLength">Length of the prefix.</symbol>  <symbol name="YSI_g_sCommandIndex">Pointer to the next free index in the function array.</symbol>  <symbol name="YSI_g_sAltCount">The number of commands with altnames.</symbol>  <symbol name="YSI_g_sCommandFlags">Bit array of command options.</symbol>  </ul><section>  Commands  </section><ul>  <symbol name="commands">Lists all commands available to you.</symbol>  </ul><section>Compile options</section><ul>  <symbol name="COMMAND_SENSITIVE">Make commands case sensitive.</symbol>  <symbol name="COMMAND_ACCURATE">Can use '@' in command names.</symbol>  <symbol name="MAX_COMMANDS">The maximum number of commands which can be used.</symbol>  </ul>  </library> <p/> <!--  <transition target[^/]+/>  :::::::: README ::::::::  To read the generated XML output, copy `pawndoc.xsl` to `pawno/xml/`.  This information goes very close to the top of the generated XML documentation  (because of include dependency orders), but doesn't appear in the visual output.  There is a bug in the compiler related to outputting documentation on state  transitions (<a href="https://github.com/Zeex/pawn/issues/184" />).  So after  generation of the XML file, you should clean it up with the following RegEx  replacement:  Search: <transition target[^/]+/>  Replace: (nothing)  This works 99% of the time, though you may get one where the corrupted target  includes the character `/`, in which case you should manually delete them.  Note  that YSI now includes manual documentation for transitions, but these all  include the parameter `keep="true"`, which exists simply to not match that  RegEx.  I also put the search at the top of this block so it is easier to find  in the output code.  --> <p/> <library name="y_scriptinit">  <section>  Description  </section>  This file provides "OnScriptInit" and "OnScriptExit" which are called at the  start and end of the current script, regardless of what the type of the  script is (note: doesn't support NPC modes).  It also provides  "YSI_FILTERSCRIPT" as a (partial) replacement for "FILTERSCRIPT" which  detects what the mode is at runtime for a more reliable system (but it is a  run-time variable, not a compile-time constant).  <section>  Version  </section>  1.0  </library> <p/> <library name="y_debug">  <section>  Description  </section>  <p>Ensures debug levels are set and defines debug functions.</p>  <p>General debug levels:</p>  <ul>  <li>-1 - Run-time selected debug level.</li>  <li>0 - No debug information.</li>  <li>1 - Callbacks and timers.</li>  <li>2 - Remote functions.</li>  <li>3 - Stock functions.</li>  <li>4 - Static functions.</li>  <li>5 - Code.</li>  <li>6 - Loops.</li>  <li>7 - Extra loop code.</li>  </ul>  <p>If you use <c>P:0</c> you get an optional debug print controlled by the  global state <c>ysi_debug</c> - which is either on or off.</p>  <section>  Version  </section>  1.0  <section>  Functions  </section>  <subsection>  Inline  </subsection><ul>  <symbol name="Debug_Code">Runs defined code if a certain level is active.</symbol>  <symbol name="Debug_Print">Prints the formatted string provided at the given level.</symbol>  </ul><subsection>  Stock  </subsection><ul>  <symbol name="Debug_PrintArray">Print several items from an array for debugging purposes.</symbol>  <symbol name="Debug_Enable">Turn on level 0 prints.</symbol>  <symbol name="Debug_Disable">Turn off level 0 prints.</symbol>  <symbol name="Debug_Level">Set the debug level when the code is compiled with  <c>_DEBUG=-1</c>, which means full run-time selection.</symbol>  </ul><section>  Definitions  </section><ul>  <symbol name="P:&lt;0-6&gt;">Print a message.</symbol>  <symbol name="P:C">Run debug code.</symbol>  <symbol name="P:E">Print an error message.</symbol>  <symbol name="P:W">Print a warning message.</symbol>  </ul><section>Compile options</section><ul>  <symbol name="_DEBUG">Debugging level to use.</symbol>  </ul>  </library> <p/> <library name="y_hooks">  <section>  Description  </section>  Automatically hooks any callbacks with a very simple syntax.  <section>  Version  </section>  2.0  </library> <p/> <library name="y_cell">  <section>  Description  </section>  Provides a few functions for manipulating the bits in single cells.  Note  that this is distinct from the y_bit library.  <section>  Version  </section>  0.2  </library> <p/> <library name="y_utils">  <section>  Description  </section>  Misc functions used throughout.  <section>  Version  </section>  0.1.3  <section>  Functions  </section>  <subsection>Stock</subsection>  <ul>  <symbol name="StrToLower">Convert a whole string to lower-case.</symbol>  <symbol name="StrToUpper">Convert a whole string to upper-case.</symbol>  <symbol name="Random">Generate a random number, optionally takes lower and upper bounds.</symbol>  <symbol name="RandomFloat">Same as <symbolref name="Random" />, but for floats.</symbol>  <symbol name="StripNL">Strips the newline characters from the end of a string.</symbol>  <symbol name="StripL">Remove whitespace from the start of a string.</symbol>  <symbol name="Strip">Remove whitespace from both ends of a string.</symbol>  <symbol name="endofline">Check if the given position is the end of a string (ignoring whitespace).</symbol>  <symbol name="chrfind">Return the first position (after <symbolref name="start" />) of the given character.</symbol>  <symbol name="chrfindp">Like <symbolref name="chrfind" />, but without the upper-bounds check.</symbol>  <symbol name="bernstein">Generate the Bernstein hash of the given string.</symbol>  <symbol name="ishex">Is the given string hexadecimal?</symbol>  <symbol name="unpack">Version of <symbolref name="strunpack" /> that returns the result.</symbol>  <symbol name="returnstringarg">Get the string passed as a variable argument from the given index.</symbol>  <symbol name="va_return">Like <symbolref name="sprintf" />, formats a string and returns the result.</symbol>  <symbol name="isnumeric">Is the given string a number?</symbol>  <symbol name="hexstr">Return the value of the given hexadecimal string.</symbol>  <symbol name="boolstr">Return the value of the given boolean string.</symbol>  <symbol name="binstr">Return the value of the given binary string.</symbol>  <symbol name="rawMemcpy">Copy memory between two address, instead of two arrays.</symbol>  <symbol name="memset">Set all of an array to a value.</symbol>  <symbol name="rawMemset">Set all of a given memory region to a value.</symbol>  <symbol name="ReturnPlayerName">Return a player's name.</symbol>  <symbol name="ftouch">Ensures that a file exists, but nothing more.</symbol>  <symbol name="InterpolateColour">Get the colour (in 3D RGB space) between two other colours.</symbol>  <symbol name="SkipWhitespace">Return the first position in a string of a non-whitespace character.</symbol>  <symbol name="Trim">Get the first and last positions of non-whitespace characters in the string.  Like  <symbolref name="Strip" />, but doesn't modify the string.</symbol>  <symbol name="Sum">Get the total (sum) of an array.</symbol>  <symbol name="Mean">Get the mathematical mean of an array.</symbol>  <symbol name="Mode">Get the mathematical mode of an array.</symbol>  <symbol name="Median">Get the mathematical median of an array.</symbol>  <symbol name="Range">Get the mathematical range of an array.</symbol>  </ul>  <subsection>Inline</subsection>  <ul>  <symbol name="UCMP">Unsigned compare.</symbol>  <symbol name="VALID_PLAYERID">Check if a player ID is valid (in range).</symbol>  <symbol name="IS_IN_RANGE">Check if a number is in range.</symbol>  <symbol name="NOT_IN_RANGE">Check if a number is outside a range.</symbol>  <symbol name="ceildiv">Divide two numbers and round up.</symbol>  <symbol name="floordiv">Divide two numbers and round down.</symbol>  <symbol name="isnull">Checks if a string is NULL (<c>\1\0</c> or <c>\0</c>).</symbol>  <symbol name="isodd">Checks if a number is odd.</symbol>  <symbol name="iseven">Checks if a number is even.</symbol>  <symbol name="strcpy">Copy one string to another.</symbol>  <symbol name="GetIP">Return the encoded (32-bit) version of a player's IP.</symbol>  <synonym name="getstring" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="GetString" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="getstringarg" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="GetStringArg" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="ReturnStringArg" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="InterpolateColor" for="InterpolateColour" />  <synonym name="StripR" for="StripNL" />  </ul>  <section>  Variables  </section>  <subsection>Global</subsection>  <ul>  <symbol name="TRUE">True hack for infinate loops.</symbol>  <symbol name="FALSE">False hack for one-time loops.</symbol>  <symbol name="NULL">1 long string for passing via Call(Remote|Local)Function.</symbol>  </ul>  </library> <p/> <library name="y_amx">  <section>  Description  </section>  Allows a script access to information about itself, such as function names.  This can be used for a range of things, including automatic callback hooking  and testing.  <section>  Version  </section>  1.0  </library> <p/> <library name="y_va">  <section>  Description  </section>  This library currently provides two functions - va_printf and va_format  which perform printf and format using variable arguments passed to another  function.  This is bsed on the variable parameter passing method based on code by Zeex.  See page 15 of the code optimisations topic.  <section>  Version  </section>  1.0  </library> <p/> <library name="y_bit">  <section>  Description  </section>  Provides functions for bit manipulation and bit arrays greater than 32bits.  The arrays are usually bigger than required due to cell boundaries but this  shouldn't cause a major problem (bit tests on the 101st bit of a 100 bit  array won't return 0 for out of bounds, but the 129th will).  Note that y_commands has a few optimisations which bypass the code in here  so any modifications to bit array layouts will need to be reflected there.  <section>  Version  </section>  0.2  <section>  Functions  </section>  <subsection>  Stock  </subsection><ul>  <symbol name="Bit_Set">Sets a slot to the given value.</symbol>  <symbol name="Bit_Get">Gets a slot state.</symbol>  <symbol name="Bit_SetAll">Sets all the slots in an array to the same thing.</symbol>  <symbol name="Bit_GetCount">Gets the number of 1s in a bit array.</symbol>  </ul><subsection>  Inline  </subsection><ul>  <symbol name="Bit_Bits">Gets the number of cells required for a bit array.</symbol>  <symbol name="Bit_Let">Sets a slot to 1.</symbol>  <symbol name="Bit_Vet">Sets a slot to 0.</symbol>  <symbol name="Bit_GetBits">Gets the bit at a slot unsafely.</symbol>  </ul><section>  Definitions  </section><ul>  <symbol name="CELLSHIFT">Number of bits that can hold "cellbits"</symbol>  </ul><section>  Tags  </section><ul>  <symbol name="Bit">Bit array type.</symbol>  </ul>  </library> <p/> <library name="y_als">  <section>  Description  </section>  Provides a number of macros for making ALS (Advanced Library System)  callback hooking simpler.  <section>  Version  </section>  1.0  </library> <p/> <library name="y_master">  <section>  Description  </section>  Handles distribution of control of code segments across all running scripts  with YSI to avoid conflicts of checkpoint streamers etc and allow features  like "/commands" displaying all commands on the server.  Now fully autonomous - to use the master system simply define which one you  want and include the script:  <c>  #define MASTER 14  #include "Master"  </c>  That will make the current script attempt to make itself the main master -  you don't need ANY other code for initialisation anywhere (which took a  while to figure out)...  This is now over 2000 lines of repetitive and complex macros!  <section>  Version  </section>  0.2  <section>  Macros  </section><ul>  <symbol name="RF">Declare a function which may be remote.</symbol>  <symbol name="RV">Declare a void function which may be remote.</symbol>  <symbol name="RS">Declare an optional callback.</symbol>  <symbol name="RFN">Declare an optional callback with no parameters.</symbol>  <symbol name="RFC">Declare a slower but shorter function.</symbol>  <symbol name="RFP">Declare a function with tags and give recall hints.</symbol>  <symbol name="RFPC">Combination of P and C.</symbol>  <symbol name="RFCP">Combination of P and C.</symbol>  </ul><section>  Variables  </section>  <subsection>  Global  </subsection><ul>  <symbol name="_@">ID of this script.</symbol>  </ul><section>Compile options</section><ul>  <symbol name="YSI_NO_MASTER">Don't use the master system.</symbol>  <symbol name="YSI_IS_CLIENT">Script is a client only script.</symbol>  <symbol name="YSI_IS_SERVER">Script is a server only script.</symbol>  </ul>  </library> <p/> <library name="y_hashmap">  <section>  Description  </section>  Maps string indexes to integer indexes.  Uses a fast hash to get an array  slot, then a linked list to resolve collisions.  <section>  Version  </section>  2.0  <section>  Functions  </section>  <subsection>  Stock  </subsection><ul>  <symbol name="HashMap_Init">Associate a hash map with an array.</symbol>  <symbol name="HashMap_Add">Add a value under a given string.</symbol>  <symbol name="HashMap_Get">Get a value from a string.</symbol>  <symbol name="HashMap_RemoveKey">Remove a string and its value from a hash map.</symbol>  <symbol name="HashMap_Set">Change the value associated with a key.</symbol>  </ul><section>  Definitions  </section><ul>  <symbol name="HASH_MAP_DATA">What should be added to enums to be hash map referenced.</symbol>  <symbol name="HashMap">Declare a new hash map.</symbol>  </ul>  </library> <p/> <library name="y_stringhash">  <section>  Description  </section>  Allows you to hash strings at compile time to use them in a switch.  <section>  Version  </section>  2.0  <section>  Functions  </section>  <subsection>  Stock  </subsection><ul>  <symbol name="YHash">Generate a string hash at run time.</symbol>  </ul><section>  Definitions  </section><ul>  <symbol name="_H">Generate a string hash at compile time.</symbol>  <symbol name="_I">Generate a case insensitive string hash at compile time.</symbol>  </ul>  </library> <p/> <library name="y_iterate">  <section>  Description  </section>  Provides efficient looping through sparse data sets, such as connected  players.  Significantly improved from the original version to be a generic  loop system, rather then purely a player loop system.  When used for  players this has constant time O(n) for number of connected players (n),  unlike standard player loops which are O(MAX_PLAYERS), regardless of the  actual number of connected players.  Even when n is MAX_PLAYERS this is  still faster.  For extensive documentation on writing and using iterators, see this topic:  <a href="http://forum.sa-mp.com/showthread.php?t=481877" />  <section>  Version  </section>  0.4  <section>  Functions  </section>  <subsection>  Public  </subsection><ul>  <symbol name="OnPlayerDisconnect">Called when a player leaves to remove them.</symbol>  <symbol name="OnPlayerConnect">Called when a player connects to add them.</symbol>  </ul><subsection>  Stock  </subsection><ul>  <symbol name="Iter_ShowArray">Displays the contents of the array.</symbol>  <symbol name="Iter_AddInternal">Add a value to an iterator.</symbol>  <symbol name="Iter_RemoveInternal">Remove a value from an iterator.</symbol>  <symbol name="Iter_RandomInternal">Get a random item from an iterator.</symbol>  <symbol name="Iter_FreeInternal">Gets the first free slot in the iterator.</symbol>  <symbol name="Iter_InitInternal">Initialises a multi-dimensional iterator.</symbol>  </ul><subsection>  Inline  </subsection><ul>  <symbol name="Iter_Create">Create a new iterator value set.</symbol>  <symbol name="Iter_Add">Wraps Iter_AddInternal.</symbol>  <symbol name="Iter_Remove">Wraps Iter_RemoveInternal.</symbol>  <symbol name="Iter_Random">Wraps Iter_RandomInternal.</symbol>  <symbol name="Iter_Count">Gets the number of items in an iterator.</symbol>  <symbol name="Iter_Debug">Wraps around Iter_ShowArray.</symbol>  <symbol name="Iter_Free">Wraps around Iter_FreeInternal.</symbol>  <symbol name="Iter_Create2">Create a new iterator array value set.</symbol>  <symbol name="Iter_Add2">Wraps Iter_AddInternal for arrays.</symbol>  <symbol name="Iter_Remove2">Wraps Iter_RemoveInternal for arrays.</symbol>  <symbol name="Iter_Random2">Wraps Iter_RandomInternal for arrays.</symbol>  <symbol name="Iter_Count2">Gets the number of items in an iterator array.</symbol>  <symbol name="Iter_Debug2">Wraps around Iter_ShowArray for arrays.</symbol>  <symbol name="Iter_Free2">Wraps around Iter_FreeInternal for arrays.</symbol>  </ul><section>  Hooks  </section><ul>  <symbol name="Iter_OnPlayerConnect">Hook for the OnPlayerConnect callback.</symbol>  <symbol name="Iter_OnPlayerDisconnect">Hook for the OnPlayerDisconnect callback.</symbol>  <symbol name="Iter_OnGameModeInit">Only exists to make the code compile correctly...</symbol>  </ul><section>  Keywords  </section><ul>  <symbol name="foreach">Command to loop an iterator.</symbol>  <symbol name="foreachex">Like foreach but without a new variable.</symbol>  <symbol name="foreach2">Command to loop through an iterator array.</symbol>  <symbol name="foreachex">Like foreach2 but without a new variable.</symbol>  </ul><section>  Tags  </section><ul>  <symbol name="Iterator">Declare an iterator.</symbol>  </ul><section>  Variables  </section>  <subsection>  Static  </subsection><ul>  <symbol name="YSI_g_OPC">Records wether Iter_OnPlayerConnect exists for speed.</symbol>  <symbol name="YSI_g_OPDC">Records wether Iter_OnPlayerDisconnect exists for speed.</symbol>  </ul><section>Compile options</section><ul>  <symbol name="YSI_ITTER_NO_SORT">Removed.</symbol>  <symbol name="FOREACH_NO_BOTS">Remove the bot iterators for smaller code.</symbol>  <symbol name="FOREACH_NO_PLAYERS">Remove all default code for player itteration.</symbol>  </ul><section>  Iterators  </section><ul>  <symbol name="Player">List of all players connected.</symbol>  <symbol name="Bot">List of all bots (npcs) connected.</symbol>  <symbol name="NPC">Alias of Bot.</symbol>  <symbol name="Character">All players and bots.</symbol>  </ul><section>  Examples  </section>  <subsection>Basic Iterators</subsection>  <p>  Basic iterators are simply collections of numbers - little more than an array.  A number is either in the array, or not in the array, <em>y_iterate</em> loops  through only the <em>in</em> numbers.</p>  <p><em>Players</em><br /><br />  This code will loop through every player connected to the server.  <code>  foreach (new i : Player)																				<br />  {																				<br /><indent />  printf("player %d is connected", i);																				<br />  }  </code>  </p>  <p><em>Vehicles</em><br /><br />  This code will loop through all the created vehicles on the server (including  those made in other running scripts).  <code>  foreach (new vid : Vehicle)																				<br />  {																				<br /><indent />  printf("vehicleid %d has been created", vid);																				<br />  }  </code>  </p>  <p><em>Create An Iterator</em><br /><br />  To create your own iterator, first declare it, then add things to it, then loop  over it:  <code>  new																				<br /><indent />  Iterator:MyIter&lt;100&gt;; // First declare it (this has room for 100 items numbered 0-99).									 											<br />  // Then add things to it.																				<br />  Iter_Add(MyIter, 0);  // Fine.																				<br />  Iter_Add(MyIter, 55); // Fine.																				<br />  Iter_Add(MyIter, 100); // Will fail.																				<br />  // Then loop over it.																				<br />  foreach (new i : MyIter)																				<br />  {																				<br /><indent />  printf("%d", i); // Will print "0" then "55".																				<br />  }  </code>  </p>  <subsection>Special Iterators</subsection>  </library> <p/> <param name="expr"><code>var : Iterator</code></param>  <remarks>  </remarks> <p/> <library name="y_remote">  <section>  Description  </section>  Wrapper for "__CallRemoteFunction".  Enforces some features like no returns  and arrays being followed by their length.  <section>  Version  </section>  1.0  <section>  Macros  </section><ul>  <symbol name="remotefunc">Define a function to be called remotely (use like "stock").</symbol>  <symbol name="broadcastfunc">Call the function, but in all scripts.</symbol>  <symbol name="localfunc">Call the function by name, not address, in the current script.</symbol>  </ul><section>Compile options</section><ul>  <symbol name="YSI_NO_MASTER">Disable all knowledge of other scripts.</symbol>  </ul>  </library> <p/> <library name="y_playerarray">  <section>  Description  </section>  This code provides arrays of players who can do things.  This is for support  of the text system which can take arrays of player ids, bit arrays or just a  single ID.  <section>  Version  </section>  1.0  </library> <p/> <library name="y_punycode">  <section>  Description  </section>  Functions for converting unicode strings to and from punycode, to be  represented in just ASCII characters.  Based on several public  implementations and the RFC, adapted for PAWN.  For more information see:  <a href="https://en.wikipedia.org/wiki/Punycode" />  Also includes a function that hooks the "HTTP" function to allow for  internationalised domain names with that function.  <section>  Version  </section>  0.1  <section>  Functions  </section>  <subsection>  Stock  </subsection><ul>  <symbol name="Puny_Encode">Convert a Unicode string to Punycode.</symbol>  <symbol name="Puny_Decode">Convert a Punycode string to Unicode.</symbol>  <symbol name="Puny_HTTP">Wrapper for "HTTP" to encode domain names.</symbol>  </ul>  </library> <p/> <param name="index">The HTTP reference index.</param>  <param name="type">How the request should be sent.</param>  <param name="url">The (internationalised) URL address.</param>  <param name="data">The GET/POST data.</param>  <param name="callback">Which function to return the data to.</param>  <remarks>  Hooks the "HTTP" function.  </remarks> <p/> <param name="error">Which error to show.</param>  <param name="playerid">Player who typed the command.</param>  <param name="cmdtext">What they typed.</param>  <remarks>  Call OnPlayerCommandReceived once the system knows how the player can use  this command (if they can).  The order of the parameters is such that the  error comes first.  This is because it is compile-time concatenated to make  the error enum value, and putting that parameter first means that we don't  need to ommit the space after any comma.  </remarks> <p/> <param name="command">Command to get for.</param>  <returns>  Is this command ID valid?  </returns>  <remarks>  Internal direct-access check.  </remarks> <p/> <param name="idx">Command to test.</param>  <remarks>  Checks to see if a character is a possible prefix character.  May use an  unsigned comparison.  </remarks> <p/> <param name="c">Command to get.</param>  <returns>  The prefix for this command ('/' by default).  </returns> <p/> <param name="prefix">Possible prefix character.</param>  <returns>  Is this a valid character for a prefix?  </returns>  <remarks>  This is the ONLY place the list of valid prefixes is defined!  They are  symbols, not an alphanumerics, and under 128.  </remarks> <p/> <param name="prefix">Possible prefix character.</param>  <returns>  Is this a prefix used for any command?  </returns> <p/> <param name="prefix">Prefix to maybe remove.</param>  <remarks>  If one command uses a prefix, then STOPS using said prefix, the global list  of valid prefixes will need to be updated.  </remarks> <p/> <param name="c">Command to set.</param>  <param name="prefix">First character of the command.</param>  <remarks>  Change what command to type "/x" vs "#x" for example.  </remarks> <p/> <param name="c">Named command to set.</param>  <param name="prefix">First character of the command.</param>  <remarks>  Change what command to type "/x" vs "#x" for example.  </remarks> 
	</general>

	<members>

		<!-- enumerations -->
		<member name="T:AMX_FUNCSTUBNT" value="2">
			<tagname value="AMX_FUNCSTUBNT"/>
			<member name="C:AMX_FUNCSTUBNT_ADDRESS" value="0">
			</member>
			<member name="C:AMX_FUNCSTUBNT_NAMEOFS" value="1">
			</member>
			<referrer name="GetPublicAddressFromIndex"/>
			<referrer name="GetPublicNameFromIndex"/>
			<referrer name="GetNativeAddressFromIndex"/>
			<referrer name="GetNativeNameFromIndex"/>
			<referrer name="GetPubVarAddressFromIndex"/>
			<referrer name="GetPubVarNameFromIndex"/>
			<referrer name="GetTagIDFromIndex"/>
			<referrer name="GetTagNameFromIndex"/>
			<referrer name="IsTagIndexStrong"/>
			<referrer name="IsTagIndexWeak"/>
		</member>
		<member name="T:AMX_HDR" value="17">
			<tagname value="AMX_HDR"/>
			<member name="C:AMX_HDR_SIZE" value="0">
			</member>
			<member name="C:AMX_HDR_MAGIC" value="1">
			</member>
			<member name="C:AMX_HDR_FILE_VERSION" value="2">
			</member>
			<member name="C:AMX_HDR_AMX_VERSION" value="3">
			</member>
			<member name="C:AMX_HDR_FLAGS" value="4">
			</member>
			<member name="C:AMX_HDR_DEFSIZE" value="5">
			</member>
			<member name="C:AMX_HDR_COD" value="6">
			</member>
			<member name="C:AMX_HDR_DAT" value="7">
			</member>
			<member name="C:AMX_HDR_HEA" value="8">
			</member>
			<member name="C:AMX_HDR_STP" value="9">
			</member>
			<member name="C:AMX_HDR_CIP" value="10">
			</member>
			<member name="C:AMX_HDR_PUBLICS" value="11">
			</member>
			<member name="C:AMX_HDR_NATIVES" value="12">
			</member>
			<member name="C:AMX_HDR_LIBRARIES" value="13">
			</member>
			<member name="C:AMX_HDR_PUBVARS" value="14">
			</member>
			<member name="C:AMX_HDR_TAGS" value="15">
			</member>
			<member name="C:AMX_HDR_NAMETABLE" value="16">
			</member>
			<referrer name="AsmGetJumpAddressFromOffset"/>
			<referrer name="AsmGetCode"/>
			<referrer name="AsmEmitCallAbs"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="DisasmInit"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DisasmWriteData"/>
			<referrer name="ProfilerInit"/>
		</member>
		<member name="T:AsmContext" value="21">
			<tagname value="AsmContext"/>
			<member name="C:AsmContext_buffer" value="0">
			</member>
			<member name="C:AsmContext_buffer_size" value="1">
			</member>
			<member name="C:AsmContext_buffer_offset" value="2">
			</member>
			<member name="C:AsmContext_error" value="3">
			</member>
			<member name="C:AsmContext_error_handler" value="4">
			</member>
			<member name="C:AsmContext_label_names" value="5">
				<size value="8"/>
			</member>
			<member name="C:AsmContext_labels" value="13">
				<size value="8"/>
			</member>
			<referrer name="AMX_Read"/>
			<referrer name="bernstein"/>
			<referrer name="rawMemset"/>
			<referrer name="Hooks_WriteFunction"/>
		</member>
		<member name="T:CodeScanMatcher" value="171">
			<tagname value="CodeScanMatcher"/>
			<member name="C:CodeScanMatcher_func" value="0">
			</member>
			<member name="C:CodeScanMatcher_user_data" value="1">
			</member>
			<member name="C:CodeScanMatcher_code" value="2">
				<size value="128"/>
			</member>
			<member name="C:CodeScanMatcher_len" value="130">
			</member>
			<member name="C:CodeScanMatcher_offset" value="131">
				<size value="2"/>
			</member>
			<member name="C:CodeScanMatcher_start" value="133">
				<size value="2"/>
			</member>
			<member name="C:CodeScanMatcher_holeidx" value="135">
				<size value="2"/>
			</member>
			<member name="C:CodeScanMatcher_holes" value="137">
				<size value="32"/>
			</member>
			<member name="C:CodeScanMatcher_next" value="169">
			</member>
			<member name="C:CodeScanMatcher_flags" value="170">
			</member>
			<referrer name="CodeScanDeref"/>
			<referrer name="YVA2_Initalise"/>
		</member>
		<member name="T:CodeScanner" value="164">
			<tagname value="CodeScanner"/>
			<member name="C:CodeScanMatch_func" value="0">
			</member>
			<member name="C:CodeScanMatch_size" value="1">
			</member>
			<member name="C:CodeScanMatch_type" value="2">
			</member>
			<member name="C:CodeScanMatch_heap" value="3">
			</member>
			<member name="C:CodeScanMatch_stack" value="4">
			</member>
			<member name="C:CodeScanMatch_params" value="5">
			</member>
			<member name="C:CodeScanMatch_cip" value="6">
			</member>
			<member name="C:CodeScanMatch_holes" value="7">
				<size value="16"/>
			</member>
			<member name="C:CodeScanMatch_hole_count" value="23">
			</member>
			<member name="C:CodeScanMatch_name" value="24">
				<size value="8"/>
			</member>
			<member name="C:CodeScanner_first" value="32">
			</member>
			<member name="C:CodeScanner_minn" value="33">
			</member>
			<member name="C:CodeScanner_jump_switch" value="34">
				<size value="32"/>
			</member>
			<member name="C:CodeScanner_jump_target" value="66">
				<size value="32"/>
			</member>
			<member name="C:CodeScanner_jump_stack" value="98">
				<size value="32"/>
			</member>
			<member name="C:CodeScanner_jump_heap" value="130">
				<size value="32"/>
			</member>
			<member name="C:CodeScanner_state" value="162">
			</member>
			<member name="C:CodeScanner_param" value="163">
			</member>
			<referrer name="YVA2_Initalise"/>
		</member>
		<member name="T:DisasmContext" value="5">
			<tagname value="DisasmContext"/>
			<member name="C:DisasmContext_start_ip" value="0">
			</member>
			<member name="C:DisasmContext_end_ip" value="1">
			</member>
			<member name="C:DisasmContext_nip" value="2">
			</member>
			<member name="C:DisasmContext_cip" value="3">
			</member>
			<member name="C:DisasmContext_opcode" value="4">
				<tagname value="Opcode"/>
			</member>
			<referrer name="DisasmWriteCode"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<referrer name="AMX_Read"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<referrer name="Hooks_GetStubEntry"/>
		</member>
		<member name="T:E_COMMAND" value="45">
			<tagname value="E_COMMAND"/>
			<member name="C:E_COMMAND_NAME" value="0">
				<size value="8"/>
			</member>
			<member name="C:E_COMMAND_HASH_MAP" value="8">
				<size value="3"/>
			</member>
			<member name="C:E_COMMAND_USERS" value="11">
				<tagname value="Bit"/>
				<size value="33"/>
			</member>
			<member name="C:E_COMMAND_POINTER" value="44">
			</member>
			<referrer name="YSI_g_sCommands_Dist"/>
			<referrer name="YSI_g_sCommands@Dist"/>
		</member>
		<member name="T:E_HOOK_NAME_REPLACEMENT_DATA" value="34">
			<tagname value="E_HOOK_NAME_REPLACEMENT_DATA"/>
			<member name="C:E_HOOK_NAME_REPLACEMENT_SHORT" value="0">
				<size value="16"/>
			</member>
			<member name="C:E_HOOK_NAME_REPLACEMENT_LONG" value="16">
				<size value="16"/>
			</member>
			<member name="C:E_HOOK_NAME_REPLACEMENT_MIN" value="32">
			</member>
			<member name="C:E_HOOK_NAME_REPLACEMENT_MAX" value="33">
			</member>
		</member>
		<member name="T:E_ITER_YIELD" value="11">
			<tagname value="E_ITER_YIELD"/>
			<member name="C:E_ITER_YIELD_STACK_START" value="0">
			</member>
			<member name="C:E_ITER_YIELD_STACK_END" value="1">
			</member>
			<member name="C:E_ITER_YIELD_STACK_SIZE" value="2">
			</member>
			<member name="C:E_ITER_YIELD_HEAP_START" value="3">
			</member>
			<member name="C:E_ITER_YIELD_HEAP_END" value="4">
			</member>
			<member name="C:E_ITER_YIELD_HEAP_SIZE" value="5">
			</member>
			<member name="C:E_ITER_YIELD_FIRST" value="6">
			</member>
			<member name="C:E_ITER_YIELD_FRM" value="7">
			</member>
			<member name="C:E_ITER_YIELD_CIP" value="8">
			</member>
			<member name="C:E_ITER_YIELD_FRAME" value="9">
			</member>
			<member name="C:E_ITER_YIELD_RETURN" value="10">
			</member>
		</member>
		<member name="T:E_PRE_HOOK" value="17">
			<tagname value="E_PRE_HOOK"/>
			<member name="C:E_PRE_HOOK_NAME" value="0">
				<size value="16"/>
			</member>
			<member name="C:E_PRE_HOOK_VALUE" value="16">
			</member>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_DoAllHooks"/>
		</member>
		<member name="T:OpcodeInsnInfo" value="17">
			<tagname value="OpcodeInsnInfo"/>
			<member name="C:OpcodeInsnInfo_name" value="0">
				<size value="15"/>
			</member>
			<member name="C:OpcodeInsnInfo_num_opers" value="15">
			</member>
			<member name="C:OpcodeInsnInfo_needs_reloc" value="16">
				<tagname value="bool"/>
			</member>
		</member>
		<member name="T:ProfCallInfo" value="2">
			<tagname value="ProfCallInfo"/>
			<member name="C:pci_index" value="0">
			</member>
			<member name="C:pci_start_time" value="1">
			</member>
			<referrer name="enter_public"/>
		</member>
		<member name="T:ProfEntryCode" value="8">
			<tagname value="ProfEntryCode"/>
			<member name="C:pec_push_c0" value="0">
				<tagname value="Opcode"/>
			</member>
			<member name="C:pec_push_address" value="1">
			</member>
			<member name="C:pec_push_c1" value="2">
				<tagname value="Opcode"/>
			</member>
			<member name="C:pec_push_index" value="3">
			</member>
			<member name="C:pec_push_c2" value="4">
				<tagname value="Opcode"/>
			</member>
			<member name="C:pec_push_8" value="5">
			</member>
			<member name="C:pec_call" value="6">
				<tagname value="Opcode"/>
			</member>
			<member name="C:pec_call_enter" value="7">
			</member>
			<referrer name="new_pec"/>
		</member>
		<member name="T:ProfPublicInfo" value="3">
			<tagname value="ProfPublicInfo"/>
			<member name="C:ppi_child_time" value="0">
			</member>
			<member name="C:ppi_total_time" value="1">
			</member>
			<member name="C:ppi_num_calls" value="2">
			</member>
		</member>
		<member name="T:__E_COMPILER_ENUM" value="4">
			<tagname value="__E_COMPILER_ENUM"/>
			<member name="C:__E_COMPILER_ENUM_ENTRY" value="0">
				<size value="3"/>
			</member>
			<member name="C:__E_COMPILER_ENUM_AFTER" value="3">
			</member>
		</member>
		<member name="T:e_COMMAND_ERRORS" value="11">
			<tagname value="e_COMMAND_ERRORS"/>
			<member name="C:COMMAND_ZERO_RET" value="0">
			</member>
			<member name="C:COMMAND_OK" value="1">
			</member>
			<member name="C:COMMAND_UNDEFINED" value="2">
			</member>
			<member name="C:COMMAND_DENIED" value="3">
			</member>
			<member name="C:COMMAND_HIDDEN" value="4">
			</member>
			<member name="C:COMMAND_NO_PLAYER" value="6">
			</member>
			<member name="C:COMMAND_DISABLED" value="7">
			</member>
			<member name="C:COMMAND_BAD_PREFIX" value="8">
			</member>
			<member name="C:COMMAND_INVALID_INPUT" value="10">
			</member>
			<referrer name="YSI_g_sErrorMessages_Dist"/>
			<referrer name="YSI_g_sErrorMessages@Dist"/>
		</member>

		<!-- constants -->
		<member name="C:AMX_HDR_OFFSET_AMX_VERSION" value="7">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_CIP" value="28">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_COD" value="12">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_DAT" value="16">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_DEFSIZE" value="10">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_FILE_VERSION" value="6">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_FLAGS" value="8">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_HEA" value="20">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_LIBRARIES" value="40">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_MAGIC" value="4">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_NAMETABLE" value="52">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_NATIVES" value="36">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_PUBLICS" value="32">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_PUBVARS" value="44">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_SIZE" value="0">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_STP" value="24">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_TAGS" value="48">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:EOS" value="0">
			<referrer name="strtok"/>
			<referrer name="strrest"/>
			<referrer name="token_by_delim"/>
		</member>
		<member name="C:NUM_OPCODES" value="138">
			<referrer name="IsOpcodeValid"/>
			<referrer name="InitOpcodeTable"/>
			<referrer name="UnrelocateOpcode"/>
			<referrer name="GetOpcodeInstructionInformation"/>
			<referrer name="GetOpcodeInstructionName"/>
			<referrer name="GetOpcodeInstructionParameters"/>
			<referrer name="GetOpcodeInstructionRelocatable"/>
			<referrer name="AsmEmitOpcode"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="DisasmNext"/>
		</member>
		<member name="C:__Pawn" value="770">
		</member>
		<member name="C:cellbits" value="32">
			<referrer name="CodeScanCheckJumpTarget"/>
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanNOPMatch"/>
			<referrer name="YVA2_CodeGenDeepCleanup"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<referrer name="Bit_Set"/>
			<referrer name="Iter_Func@Bits"/>
			<referrer name="Iter_Func@Blanks"/>
			<referrer name="PA_Set"/>
			<referrer name="Iter_Func@PA"/>
			<referrer name="Group_SetCommand"/>
			<referrer name="Group_GetCommand"/>
			<referrer name="Group_SetCommandDefault"/>
			<referrer name="Group_ExclusiveCommand"/>
			<referrer name="Group_Handoff"/>
			<referrer name="_yGICommand"/>
			<referrer name="_yGACommand"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="Command_GetPlayerDisabled"/>
			<referrer name="Command_GetPlayer"/>
			<referrer name="Command_GetPlayerCommandCount"/>
			<referrer name="Command_GetNext"/>
			<referrer name="Iter_Func@PlayerCommand"/>
			<referrer name="_Command_GetDisplay"/>
		</member>
		<member name="C:cellmax" value="2147483647">
			<referrer name="operator!(Float:)"/>
			<referrer name="CodeScanGetFunctionAsm"/>
			<referrer name="CodeScanGetMatchAsm"/>
			<referrer name="exit_public"/>
			<referrer name="Range"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="Puny_Decode"/>
			<referrer name="Puny_Encode"/>
			<referrer name="Puny_EncodeHash"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_Add"/>
		</member>
		<member name="C:cellmin" value="-2147483648">
			<referrer name="operator-(Float:)"/>
			<referrer name="CallN"/>
			<referrer name="SysreqC"/>
			<referrer name="SysreqD"/>
			<referrer name="SysreqCN"/>
			<referrer name="SysreqDN"/>
			<referrer name="CallNative"/>
			<referrer name="CallNativeByAddress"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<referrer name="CodeScanInit"/>
			<referrer name="exit_public"/>
			<referrer name="Random"/>
			<referrer name="endofline"/>
			<referrer name="ishex"/>
			<referrer name="isnumeric"/>
			<referrer name="SkipWhitespace"/>
			<referrer name="Trim"/>
			<referrer name="Range"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<referrer name="Iter_Random_Internal"/>
			<referrer name="Iter_RandomFree_InternalC"/>
			<referrer name="Iter_Alloc_InternalC"/>
			<referrer name="Iter_Alloc_InternalD"/>
			<referrer name="Iter_Free_Internal"/>
			<referrer name="Iter_FreeMulti_Internal"/>
			<referrer name="Iter_Add_InternalC"/>
			<referrer name="Iter_Add_InternalD"/>
			<referrer name="Iter_Index_Internal"/>
			<referrer name="Iter_SafeRemove_InternalC"/>
			<referrer name="Iter_SafeRemove_InternalD"/>
			<referrer name="Iter_GetMulti_Internal"/>
			<referrer name="Iter_Func@Range"/>
			<referrer name="Iter_Func@Random"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="Command_GetPlayer"/>
			<referrer name="Command_SetPlayer"/>
			<referrer name="Command_Touch"/>
			<referrer name="Command_IsValid"/>
			<referrer name="Command_GetName"/>
			<referrer name="@yH_OnMasterSystemClose@004"/>
			<referrer name="_Command_GetDisplay"/>
		</member>
		<member name="C:debug" value="1">
			<referrer name="RelocateOpcodeNow"/>
		</member>
		<member name="C:false" value="0">
			<tagname value="bool"/>
			<referrer name="isNumeric"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="YVers_Callback"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicNameFromIndex"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeNameFromIndex"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarNameFromIndex"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagNameFromIndex"/>
			<referrer name="GetOpcodeInstructionRelocatable"/>
			<referrer name="Push"/>
			<referrer name="Pop"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="DisasmWrite"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanCheckJumpTarget"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="CodeScanGetFuncName"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanFindOneFastPattern3"/>
			<referrer name="CodeScanFindOneFastPattern2"/>
			<referrer name="CodeScanRunFastPrescan"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="ProfilerWriteData"/>
			<referrer name="Utils_PreSort"/>
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="Hooks_IsolateName"/>
			<referrer name="_Master_Get"/>
			<referrer name="Master_GetCurrentMaster"/>
			<referrer name="HashMap_Add"/>
			<referrer name="HashMap_RemoveKeyWithHash"/>
			<referrer name="HashMap_RemoveValue"/>
			<referrer name="Iter_YieldEnter"/>
			<referrer name="Iter_YieldLoop"/>
			<referrer name="@yH_OnPlayerDisconnect@003"/>
			<referrer name="Iter_DestroyActor"/>
			<referrer name="Iter_DestroyVehicle"/>
			<referrer name="Puny_EncodeHash"/>
			<referrer name="Command_InitialiseFromGroups"/>
			<referrer name="Group_FullPlayerUpdate"/>
			<referrer name="_Group_IncludeAll_1"/>
			<referrer name="Command_GetPlayer"/>
			<referrer name="Master_GetCurrentMaster"/>
		</member>
		<member name="C:true" value="1">
			<tagname value="bool"/>
			<referrer name="isNumeric"/>
			<referrer name="ReturnUser"/>
			<referrer name="OnFilterScriptInit"/>
			<referrer name="ResetStaticAmxHeader"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagNameFromIndex"/>
			<referrer name="GetTagNameFromID"/>
			<referrer name="InitOpcodeTable"/>
			<referrer name="Push"/>
			<referrer name="Pop"/>
			<referrer name="AsmEmitJrelLabelStringize"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="DisasmWrite"/>
			<referrer name="CodeScanCheckJumpTarget"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="CodeScanGetFuncName"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanFindOneFastPattern3"/>
			<referrer name="CodeScanFindOneFastPattern2"/>
			<referrer name="CodeScanRunFastPrescan"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<referrer name="ProfilerWriteData"/>
			<referrer name="boolstr"/>
			<referrer name="Utils_PreSort"/>
			<referrer name="Hooks_GetPreHooks"/>
			<referrer name="Hooks_GetFunctionWritePoint"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<referrer name="_Master_Get"/>
			<referrer name="HashMap_Add"/>
			<referrer name="HashMap_RemoveKeyWithHash"/>
			<referrer name="Iter_YieldEnter"/>
			<referrer name="Iter_YieldLoop"/>
			<referrer name="Iter_CreateActor"/>
			<referrer name="Iter_CreateVehicle"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<referrer name="Puny_EncodeHash"/>
			<referrer name="Group_FullPlayerUpdate"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_Add"/>
		</member>

		<!-- variables -->
		<member name="F:AMX_BASE_ADDRESS">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetEntry"/>
			<referrer name="AMX_GetEntryPrefix"/>
			<referrer name="AMX_GetEntrySuffix"/>
			<referrer name="AMX_GetName"/>
			<referrer name="AMX_GetNamePrefix"/>
			<referrer name="AMX_GetNameSuffix"/>
			<referrer name="AMX_GetStringFromEntry"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_InvalidateName"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_ComparePublics"/>
			<referrer name="Hooks_SortPublics"/>
			<referrer name="@yH_OnScriptInit@004"/>
		</member>
		<member name="F:AMX_HEADER_AMX_VERSION">
			<referrer name="Debug_OnScriptInit"/>
		</member>
		<member name="F:AMX_HEADER_CIP">
			<referrer name="Debug_OnScriptInit"/>
		</member>
		<member name="F:AMX_HEADER_COD">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetGlobal"/>
			<referrer name="AMX_TraceCode"/>
			<referrer name="AMX_Read"/>
			<referrer name="bernstein"/>
			<referrer name="rawMemset"/>
			<referrer name="CGen_GetAddr"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GenerateCode"/>
			<referrer name="Hooks_WriteFunction"/>
		</member>
		<member name="F:AMX_HEADER_DAT">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_TraceCode"/>
			<referrer name="AMX_TraceMemory"/>
		</member>
		<member name="F:AMX_HEADER_DEFSIZE">
			<referrer name="Debug_OnScriptInit"/>
		</member>
		<member name="F:AMX_HEADER_FILE_VERSION">
			<referrer name="Debug_OnScriptInit"/>
		</member>
		<member name="F:AMX_HEADER_FLAGS">
			<referrer name="Debug_OnScriptInit"/>
		</member>
		<member name="F:AMX_HEADER_HEA">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_TraceMemory"/>
		</member>
		<member name="F:AMX_HEADER_LIBRARIES">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetBaseCount"/>
		</member>
		<member name="F:AMX_HEADER_MAGIC">
			<referrer name="Debug_OnScriptInit"/>
		</member>
		<member name="F:AMX_HEADER_NAMETABLE">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetBaseCount"/>
		</member>
		<member name="F:AMX_HEADER_NATIVES">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetBaseCount"/>
			<referrer name="AMX_GetEntryFromNativeIndex"/>
			<referrer name="AMX_GetNativeIndexFromEntry"/>
			<referrer name="Hooks_SortPublics"/>
		</member>
		<member name="F:AMX_HEADER_PUBLICS">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetBaseCount"/>
			<referrer name="AMX_GetEntryFromPublicIndex"/>
			<referrer name="AMX_GetPublicIndexFromEntry"/>
			<referrer name="CGen_GetAddr"/>
			<referrer name="Hooks_ComparePublics"/>
			<referrer name="Hooks_SortPublics"/>
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="@yH_OnMasterSystemClose@004"/>
		</member>
		<member name="F:AMX_HEADER_PUBVARS">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetBaseCount"/>
		</member>
		<member name="F:AMX_HEADER_SIZE">
			<referrer name="Debug_OnScriptInit"/>
		</member>
		<member name="F:AMX_HEADER_STP">
			<referrer name="Debug_OnScriptInit"/>
		</member>
		<member name="F:AMX_HEADER_TAGS">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetBaseCount"/>
		</member>
		<member name="F:AMX_REAL_ADDRESS">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="Hooks_WriteFunction"/>
		</member>
		<member name="F:AMX_REAL_DATA">
			<referrer name="Debug_OnScriptInit"/>
			<referrer name="AMX_GetGlobalAddress"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GenerateCode"/>
		</member>
		<member name="F:ASM_ARGUMENTS_OFFSET">
			<referrer name="AsmGetArgOffset"/>
		</member>
		<member name="F:ASM_CALLER_FRAME_OFFSET">
		</member>
		<member name="F:ASM_CTRL_CIP">
		</member>
		<member name="F:ASM_CTRL_COD">
		</member>
		<member name="F:ASM_CTRL_DAT">
		</member>
		<member name="F:ASM_CTRL_FRM">
		</member>
		<member name="F:ASM_CTRL_HEA">
		</member>
		<member name="F:ASM_CTRL_JIT">
		</member>
		<member name="F:ASM_CTRL_JMP">
		</member>
		<member name="F:ASM_CTRL_STK">
		</member>
		<member name="F:ASM_CTRL_STP">
		</member>
		<member name="F:ASM_LOCALS_OFFSET">
		</member>
		<member name="F:ASM_RETURN_ADDR_OFFSET">
		</member>
		<member name="F:F@o">
		</member>
		<member name="F:FALSE">
			<tagname value="bool"/>
		</member>
		<member name="F:I@">
			<referrer name="Iter_YieldReturn"/>
			<referrer name="Iter_ActorDo_"/>
			<referrer name="Iter_CreateActor"/>
			<referrer name="Iter_DestroyActor"/>
			<referrer name="Iter_VehicleDo_"/>
			<referrer name="Iter_CreateVehicle"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<referrer name="Iter_DestroyVehicle"/>
			<referrer name="Command_Add"/>
		</member>
		<member name="F:Iter_Single@Actor">
			<referrer name="@yH_OnScriptInit@003"/>
			<referrer name="Iter_ActorDo"/>
		</member>
		<member name="F:Iter_Single@Bot">
			<referrer name="@yH_OnScriptInit@003"/>
			<referrer name="@yH_OnPlayerConnect@003"/>
			<referrer name="Iter_OPDCInternal"/>
		</member>
		<member name="F:Iter_Single@Character">
			<referrer name="@yH_OnScriptInit@003"/>
			<referrer name="@yH_OnPlayerConnect@003"/>
			<referrer name="Iter_OPDCInternal"/>
		</member>
		<member name="F:Iter_Single@LocalActor">
			<referrer name="Iter_CreateActor"/>
			<referrer name="Iter_DestroyActor"/>
		</member>
		<member name="F:Iter_Single@LocalVehicle">
			<referrer name="Iter_CreateVehicle"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<referrer name="Iter_DestroyVehicle"/>
		</member>
		<member name="F:Iter_Single@Player">
			<referrer name="@yH_OnScriptInit@003"/>
			<referrer name="@yH_OnPlayerConnect@003"/>
			<referrer name="Iter_OPDCInternal"/>
		</member>
		<member name="F:Iter_Single@Vehicle">
			<referrer name="@yH_OnScriptInit@003"/>
			<referrer name="Iter_VehicleDo"/>
		</member>
		<member name="F:Iterator@Actor">
			<referrer name="@yH_OnScriptInit@003"/>
			<referrer name="Iter_ActorDo"/>
		</member>
		<member name="F:Iterator@Bot">
			<referrer name="@yH_OnScriptInit@003"/>
			<referrer name="@yH_OnPlayerConnect@003"/>
			<referrer name="Iter_OPDCInternal"/>
		</member>
		<member name="F:Iterator@Character">
			<referrer name="@yH_OnScriptInit@003"/>
			<referrer name="@yH_OnPlayerConnect@003"/>
			<referrer name="Iter_OPDCInternal"/>
		</member>
		<member name="F:Iterator@Fib">
			<tagname value="F@z"/>
		</member>
		<member name="F:Iterator@Filter">
			<tagname value="F@z"/>
		</member>
		<member name="F:Iterator@LocalActor">
			<referrer name="Iter_CreateActor"/>
			<referrer name="Iter_DestroyActor"/>
		</member>
		<member name="F:Iterator@LocalVehicle">
			<referrer name="Iter_CreateVehicle"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<referrer name="Iter_DestroyVehicle"/>
		</member>
		<member name="F:Iterator@NonNull">
			<tagname value="F@z"/>
		</member>
		<member name="F:Iterator@Null">
			<tagname value="F@z"/>
		</member>
		<member name="F:Iterator@Player">
			<referrer name="@yH_OnScriptInit@003"/>
			<referrer name="@yH_OnPlayerConnect@003"/>
			<referrer name="Iter_OPDCInternal"/>
			<referrer name="Group_SetCommand"/>
			<referrer name="Group_SetCommandDefault"/>
			Create the internal iterators. 
		</member>
		<member name="F:Iterator@Powers">
			<tagname value="F@z"/>
		</member>
		<member name="F:Iterator@Random">
			<tagname value="F@z"/>
		</member>
		<member name="F:Iterator@Range">
			<tagname value="F@z"/>
		</member>
		<member name="F:Iterator@Until">
			<tagname value="F@z"/>
		</member>
		<member name="F:Iterator@Vehicle">
			<referrer name="@yH_OnScriptInit@003"/>
			<referrer name="Iter_VehicleDo"/>
		</member>
		<member name="F:J@">
			<referrer name="Iter_ActorDo_"/>
			<referrer name="Iter_CreateActor"/>
			<referrer name="Iter_DestroyActor"/>
			<referrer name="Iter_VehicleDo_"/>
			<referrer name="Iter_CreateVehicle"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<referrer name="Iter_DestroyVehicle"/>
			<referrer name="_yGICommand"/>
			<referrer name="_yGACommand"/>
			<referrer name="_yGUCommand"/>
		</member>
		<member name="F:NULL">
			<referrer name="Command_ReProcess"/>
		</member>
		<member name="F:O@V_">
			<referrer name="O@A_"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<referrer name="YVA2_Initalise"/>
		</member>
		<member name="F:PUNY_BIAS">
			<referrer name="Puny_Decode"/>
			<referrer name="Puny_Encode"/>
			<referrer name="Puny_EncodeHash"/>
		</member>
		<member name="F:PUNY_DAMP">
			<referrer name="Puny_Adapt"/>
		</member>
		<member name="F:PUNY_INIT">
			<referrer name="Puny_Decode"/>
			<referrer name="Puny_Encode"/>
			<referrer name="Puny_EncodeHash"/>
		</member>
		<member name="F:PUNY_SKEW">
			<referrer name="Puny_Adapt"/>
		</member>
		<member name="F:PUNY_TMAX">
			<referrer name="Puny_Decode"/>
			<referrer name="Puny_EncodeVarHash"/>
			<referrer name="Puny_EncodeVar"/>
			<referrer name="Puny_Adapt"/>
		</member>
		<member name="F:PUNY_TMIN">
			<referrer name="Puny_Decode"/>
			<referrer name="Puny_EncodeVarHash"/>
			<referrer name="Puny_EncodeVar"/>
			<referrer name="Puny_Adapt"/>
		</member>
		<member name="F:Q@">
			<referrer name="S@"/>
			<referrer name="G@"/>
			<referrer name="F@"/>
			<referrer name="Command_GetName"/>
			<referrer name="Command_GetDisplay"/>
			<referrer name="Command_GetDisplayNamed"/>
			<referrer name="Command_GetNext"/>
		</member>
		<member name="F:THE_CURRENT_MASTER_IS_CLOUD">
		</member>
		<member name="F:THE_CURRENT_MASTER_IS_CLOUD">
		</member>
		<member name="F:TRUE">
			<tagname value="bool"/>
			<referrer name="YVA2_DummyPush"/>
		</member>
		<member name="F:UNIQUE_SYMBOL_DOESNT_EXIST">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:YSI_FILTERSCRIPT">
			<tagname value="bool"/>
			<referrer name="OnFilterScriptInit"/>
			<referrer name="OnGameModeInit"/>
			<referrer name="OnFilterScriptExit"/>
			<referrer name="OnGameModeExit"/>
			<referrer name="YVers_OnScriptInit"/>
		</member>
		<member name="F:YSI_gDebugLevel">
			<referrer name="Debug_Level"/>
		</member>
		<member name="F:YSI_gGroupPlayers">
			<tagname value="Bit"/>
			<referrer name="Group_SetCommand"/>
			<referrer name="Group_SetCommandDefault"/>
		</member>
		<member name="F:YSI_gIteratorDepth">
			<referrer name="Iter_YieldEnter"/>
			<referrer name="Iter_YieldLoop"/>
			<referrer name="Iter_YieldReturn"/>
		</member>
		<member name="F:YSI_gPlayerIP">
			<referrer name="OnPlayerConnect"/>
			<referrer name="OnPlayerDisconnect"/>
		</member>
		<member name="F:YSI_gTempGroups">
			<tagname value="Bit"/>
			<referrer name="Group_SetCommand"/>
			<referrer name="Group_ExclusiveCommand"/>
		</member>
		<member name="F:YSI_g_cEmptyGroups">
			<tagname value="Bit"/>
			<referrer name="Group_ExclusiveCommand"/>
			<referrer name="_yGICommand"/>
		</member>
		<member name="F:YSI_g_sCodeEnd">
			<referrer name="CGen_SetupCodeSpace"/>
			<referrer name="CGen_UseCodeSpace"/>
		</member>
		<member name="F:YSI_g_sCodeSpace">
			<referrer name="CGen_SetupCodeSpace"/>
			<referrer name="CGen_UseCodeSpace"/>
			<referrer name="CGen_GetCodeSpace"/>
			<referrer name="CGen_AddCodeSpace"/>
		</member>
		<member name="F:YSI_g_sCommandFlags">
			<tagname value="e_COMMAND_FLAGS"/>
			<referrer name="YSI_g_sCommandFlags_Dist"/>
			<referrer name="YSI_g_sCommandFlags@Dist"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="Command_SetDeniedReturn"/>
			<referrer name="Command_GetDeniedReturn"/>
			<referrer name="Command_SetIllegalReturn"/>
			<referrer name="Command_GetIllegalReturn"/>
			<referrer name="Command_SetUnknownReturn"/>
			<referrer name="Command_GetUnknownReturn"/>
			<referrer name="Command_SetDisconnectReturn"/>
			<referrer name="Command_GetDisconnectReturn"/>
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="Command_IncOPCR"/>
			<referrer name="Command_DecOPCR"/>
			<referrer name="Command_IncOPCP"/>
			<referrer name="Command_DecOPCP"/>
		</member>
		<member name="F:YSI_g_sCommandMap">
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="Command_Find"/>
			<referrer name="Command_Remove"/>
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="_Command_Rebuild"/>
			<referrer name="Command_Add"/>
		</member>
		<member name="F:YSI_g_sCommands">
			<referrer name="YSI_g_sCommands_Dist"/>
			<referrer name="YSI_g_sCommands@Dist"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="Command_GetPlayer"/>
			<referrer name="Command_SetPlayer"/>
			<referrer name="Command_Touch"/>
			<referrer name="Command_Remove"/>
			<referrer name="Command_IsValid"/>
			<referrer name="Command_GetPlayerCommandCount"/>
			<referrer name="Command_GetName"/>
			<referrer name="Command_GetNext"/>
			<referrer name="Iter_Func@Command"/>
			<referrer name="Iter_Func@PlayerCommand"/>
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="@yH_OnMasterSystemClose@004"/>
			<referrer name="_Command_Rebuild"/>
			<referrer name="Command_GetEmptySlot"/>
			<referrer name="Command_Add"/>
			<referrer name="_Command_GetDisplay"/>
		</member>
		<member name="F:YSI_g_sContexts">
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_sCurrentID">
			<referrer name="Command_ReProcess"/>
			<referrer name="Command_GetCurrent"/>
		</member>
		<member name="F:YSI_g_sDefaultMembership">
			<tagname value="Bit"/>
			<referrer name="Group_SetCommandDefault"/>
			<referrer name="Group_SetCommandNew"/>
			<referrer name="Group_ExclusiveCommand"/>
			<referrer name="Group_Handoff"/>
			<referrer name="HANDOFF_SOURCE@_Group"/>
			<referrer name="_yGICommand"/>
			<referrer name="_yGACommand"/>
			<referrer name="_Group_IncludeAll_1"/>
		</member>
		<member name="F:YSI_g_sDisabledPlayers">
			<tagname value="Bit"/>
			<referrer name="YSI_g_sDisabledPlayers_Dist"/>
			<referrer name="YSI_g_sDisabledPlayers@Dist"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="Command_SetPlayerDisabled"/>
			<referrer name="Command_GetPlayerDisabled"/>
		</member>
		<member name="F:YSI_g_sElementMembership">
			<tagname value="Bit"/>
			<referrer name="Group_SetCommand"/>
			<referrer name="Group_GetCommand"/>
			<referrer name="Group_SetCommandDefault"/>
			<referrer name="Group_Handoff"/>
			<referrer name="HANDOFF_SOURCE@_Group"/>
			<referrer name="_yGACommand"/>
			<referrer name="_yGUCommand"/>
			<referrer name="_Group_IncludeAll_1"/>
		</member>
		<member name="F:YSI_g_sEmpty">
			<tagname value="Bit"/>
			<referrer name="Group_ExclusiveCommand"/>
			<referrer name="_yGICommand"/>
			<referrer name="_Group_IncludeAll_1"/>
		</member>
		<member name="F:YSI_g_sErrorMessages">
			<referrer name="YSI_g_sErrorMessages_Dist"/>
			<referrer name="YSI_g_sErrorMessages@Dist"/>
		</member>
		<member name="F:YSI_g_sHighestID">
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_GetPlayerCommandCount"/>
			<referrer name="Command_GetNext"/>
			<referrer name="Iter_Func@Command"/>
			<referrer name="Iter_Func@PlayerCommand"/>
			<referrer name="_Command_Rebuild"/>
			<referrer name="Command_Add"/>
			<referrer name="_Command_GetDisplay"/>
		</member>
		<member name="F:YSI_g_sInitialised">
			<referrer name="YVA2_DummyPush"/>
			<referrer name="AMX_OnScriptInit"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_sIteratorStack">
			<referrer name="Iter_YieldEnter"/>
			<referrer name="Iter_YieldLoop"/>
			<referrer name="Iter_YieldReturn"/>
		</member>
		<member name="F:YSI_g_sLength">
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_sMasterCount">
			<referrer name="ScriptInit_OnScriptExit"/>
			<referrer name="Master_Reassert"/>
			<referrer name="_Master_Relinquish"/>
			<referrer name="_Master_Get"/>
		</member>
		<member name="F:YSI_g_sMasterData">
			<tagname value="Bit"/>
			<referrer name="YSI_g_sCommands_Dist"/>
			<referrer name="YSI_g_sCommands@Dist"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="@yH_OnMasterSystemClose@004"/>
			<referrer name="Command_Add"/>
		</member>
		<member name="F:YSI_g_sMasterData">
			<referrer name="ScriptInit_OnScriptExit"/>
			<referrer name="Master_Reassert"/>
			<referrer name="_Master_Relinquish"/>
			<referrer name="_Master_Get"/>
		</member>
		<member name="F:YSI_g_sMaxEncountered">
			<referrer name="Group_SetCommandDefault"/>
			<referrer name="_yGUCommand"/>
			<referrer name="_Group_IncludeAll_1"/>
		</member>
		<member name="F:YSI_g_sMaxNesting">
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_sPassthroughNestings">
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_sPrefixes">
			<tagname value="Bit"/>
		</member>
		<member name="F:YSI_g_sPtr">
			<referrer name="Iter_YieldLoop"/>
			<referrer name="Iter_YieldReturn"/>
		</member>
		<member name="F:YSI_g_sReplacePtr">
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="Hooks_SortReplacements"/>
		</member>
		<member name="F:YSI_g_sReplacements">
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="Hooks_SortReplacements"/>
		</member>
		<member name="F:YSI_g_sReplacementsLongOrder">
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="Hooks_SortReplacements"/>
		</member>
		<member name="F:YSI_g_sReplacementsShortOrder">
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="Hooks_SortReplacements"/>
		</member>
		<member name="F:YSI_g_sReturnBuffer">
			<referrer name="Command_GetName"/>
			<referrer name="Command_GetDisplay"/>
			<referrer name="Command_GetDisplayNamed"/>
			<referrer name="Command_GetNext"/>
			<referrer name="_Command_GetDisplay"/>
		</member>
		<member name="F:YSI_g_sSkips">
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_g_sStack">
			<referrer name="@yH_OnScriptInit@002"/>
		</member>
		<member name="F:YSI_g_sStackPtr">
			<referrer name="@yH_OnScriptInit@002"/>
			<referrer name="Iter_YieldLoop"/>
			<referrer name="Iter_YieldReturn"/>
		</member>
		<member name="F:YSI_g_sStacks">
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
		</member>
		<member name="F:YSI_gscDecoder">
			<referrer name="Puny_Decode"/>
		</member>
		<member name="F:YSI_gscISI">
			<referrer name="Command_ReProcess"/>
		</member>
		<member name="F:YSI_gscISII">
			<referrer name="Command_ReProcess"/>
		</member>
		<member name="F:YSI_gscOPCP">
			<referrer name="Command_ReProcess"/>
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="@yH_OnScriptExit@004"/>
		</member>
		<member name="F:YSI_gscOPCR">
			<referrer name="Command_ReProcess"/>
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="@yH_OnScriptExit@004"/>
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:_@">
			<attribute name="public"/>
			<referrer name="Y@"/>
			<referrer name="HookChain_OnScriptInit"/>
			<referrer name="ScriptInit_OnScriptExit"/>
			<referrer name="Master_Reassert"/>
			<referrer name="_Master_Get"/>
			<referrer name="@_"/>
			<referrer name="Iter_ActorDo@"/>
			<referrer name="Iter_VehicleDo@"/>
			<referrer name="Distribute_So"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="@yH_OnMasterSystemClose@004"/>
			<referrer name="Command_Add"/>
			<referrer name="@a"/>
			<referrer name="@yC_joinfight"/>
		</member>
		<member name="F:_YCM_g@_">
			<tagname value="_E_YCM"/>
			<referrer name="Master_GetCurrentMaster"/>
			<referrer name="@_"/>
		</member>
		<member name="F:_YCM_g@a">
			<tagname value="_E_YCM"/>
			<referrer name="Master_GetCurrentMaster"/>
			<referrer name="@a"/>
		</member>
		<member name="F:__ARR">
		</member>
		<member name="F:__REF">
		</member>
		<member name="F:__TAGOF__Amx">
			<tagname value="Amx"/>
		</member>
		<member name="F:__TAGOF__AmxString">
			<tagname value="AmxString"/>
		</member>
		<member name="F:__TAGOF__AmxStringBuffer">
			<tagname value="AmxStringBuffer"/>
		</member>
		<member name="F:__TAGOF__AmxVariant">
			<tagname value="AmxVariant"/>
		</member>
		<member name="F:__TAGOF__AmxVariantBuffer">
			<tagname value="AmxVariantBuffer"/>
		</member>
		<member name="F:__TAGOF__AsmError">
			<tagname value="AsmError"/>
		</member>
		<member name="F:__TAGOF__Bintree">
			<tagname value="Bintree"/>
		</member>
		<member name="F:__TAGOF__Bit">
			<tagname value="Bit"/>
		</member>
		<member name="F:__TAGOF__BitStream">
			<tagname value="BitStream"/>
		</member>
		<member name="F:__TAGOF__ConstAmxString">
			<tagname value="ConstAmxString"/>
		</member>
		<member name="F:__TAGOF__ConstAmxVariant">
			<tagname value="ConstAmxVariant"/>
		</member>
		<member name="F:__TAGOF__ConstString">
			<tagname value="ConstString"/>
		</member>
		<member name="F:__TAGOF__ConstVariant">
			<tagname value="ConstVariant"/>
		</member>
		<member name="F:__TAGOF__DB">
			<tagname value="DB"/>
		</member>
		<member name="F:__TAGOF__DBResult">
			<tagname value="DBResult"/>
		</member>
		<member name="F:__TAGOF__DisasmResult">
			<tagname value="DisasmResult"/>
		</member>
		<member name="F:__TAGOF__DynamicActor">
			<tagname value="DynamicActor"/>
		</member>
		<member name="F:__TAGOF__DynamicArea">
			<tagname value="DynamicArea"/>
		</member>
		<member name="F:__TAGOF__DynamicCP">
			<tagname value="DynamicCP"/>
		</member>
		<member name="F:__TAGOF__DynamicMapIcon">
			<tagname value="DynamicMapIcon"/>
		</member>
		<member name="F:__TAGOF__DynamicObject">
			<tagname value="DynamicObject"/>
		</member>
		<member name="F:__TAGOF__DynamicPickup">
			<tagname value="DynamicPickup"/>
		</member>
		<member name="F:__TAGOF__DynamicRaceCP">
			<tagname value="DynamicRaceCP"/>
		</member>
		<member name="F:__TAGOF__DynamicText3D">
			<tagname value="DynamicText3D"/>
		</member>
		<member name="F:__TAGOF__E_MATCH_FLAG">
			<tagname value="E_MATCH_FLAG"/>
		</member>
		<member name="F:__TAGOF__E_REGEX_FLAG">
			<tagname value="E_REGEX_FLAG"/>
		</member>
		<member name="F:__TAGOF__E_REGEX_GRAMMAR">
			<tagname value="E_REGEX_GRAMMAR"/>
		</member>
		<member name="F:__TAGOF__E_SORT_ORDER">
			<tagname value="E_SORT_ORDER"/>
		</member>
		<member name="F:__TAGOF__File">
			<tagname value="File"/>
		</member>
		<member name="F:__TAGOF__Float">
			<tagname value="Float"/>
		</member>
		<member name="F:__TAGOF__Group">
			<tagname value="Group"/>
		</member>
		<member name="F:__TAGOF__Guard">
			<tagname value="Guard"/>
		</member>
		<member name="F:__TAGOF__Handle">
			<tagname value="Handle"/>
		</member>
		<member name="F:__TAGOF__INI">
			<tagname value="INI"/>
		</member>
		<member name="F:__TAGOF__Iter">
			<tagname value="Iter"/>
		</member>
		<member name="F:__TAGOF__Language">
			<tagname value="Language"/>
		</member>
		<member name="F:__TAGOF__LinkedList">
			<tagname value="LinkedList"/>
		</member>
		<member name="F:__TAGOF__List">
			<tagname value="List"/>
		</member>
		<member name="F:__TAGOF__Map">
			<tagname value="Map"/>
		</member>
		<member name="F:__TAGOF__Menu">
			<tagname value="Menu"/>
		</member>
		<member name="F:__TAGOF__Opcode">
			<tagname value="Opcode"/>
		</member>
		<member name="F:__TAGOF__PR_HandlerType">
			<tagname value="PR_HandlerType"/>
		</member>
		<member name="F:__TAGOF__PR_PacketPriority">
			<tagname value="PR_PacketPriority"/>
		</member>
		<member name="F:__TAGOF__PR_PacketReliability">
			<tagname value="PR_PacketReliability"/>
		</member>
		<member name="F:__TAGOF__PR_ValueType">
			<tagname value="PR_ValueType"/>
		</member>
		<member name="F:__TAGOF__PlayerText">
			<tagname value="PlayerText"/>
		</member>
		<member name="F:__TAGOF__PlayerText3D">
			<tagname value="PlayerText3D"/>
		</member>
		<member name="F:__TAGOF__Regex">
			<tagname value="Regex"/>
		</member>
		<member name="F:__TAGOF__RegexMatch">
			<tagname value="RegexMatch"/>
		</member>
		<member name="F:__TAGOF__String">
			<tagname value="String"/>
		</member>
		<member name="F:__TAGOF__Style">
			<tagname value="Style"/>
		</member>
		<member name="F:__TAGOF__Task">
			<tagname value="Task"/>
		</member>
		<member name="F:__TAGOF__Text">
			<tagname value="Text"/>
		</member>
		<member name="F:__TAGOF__Text3D">
			<tagname value="Text3D"/>
		</member>
		<member name="F:__TAGOF__Timer">
			<tagname value="Timer"/>
		</member>
		<member name="F:__TAGOF__Var">
			<tagname value="Var"/>
		</member>
		<member name="F:__TAGOF__Variant">
			<tagname value="Variant"/>
		</member>
		<member name="F:__TAGOF__XML">
			<tagname value="XML"/>
		</member>
		<member name="F:__TAGOF__amx_err">
			<tagname value="amx_err"/>
		</member>
		<member name="F:__TAGOF__bool">
			<tagname value="bool"/>
		</member>
		<member name="F:__TAGOF__error_level">
			<tagname value="error_level"/>
		</member>
		<member name="F:__TAGOF__filemode">
			<tagname value="filemode"/>
		</member>
		<member name="F:__TAGOF__filter_type">
			<tagname value="filter_type"/>
		</member>
		<member name="F:__TAGOF__fork_level">
			<tagname value="fork_level"/>
		</member>
		<member name="F:__TAGOF__handler_flags">
			<tagname value="handler_flags"/>
		</member>
		<member name="F:__TAGOF__hex">
			<tagname value="hex"/>
		</member>
		<member name="F:__TAGOF__locale_category">
			<tagname value="locale_category"/>
		</member>
		<member name="F:__TAGOF__match_results">
			<tagname value="match_results"/>
		</member>
		<member name="F:__TAGOF__regex">
			<tagname value="regex"/>
		</member>
		<member name="F:__TAGOF__seek_whence">
			<tagname value="seek_whence"/>
		</member>
		<member name="F:__TAGOF__str_create_mode">
			<tagname value="str_create_mode"/>
		</member>
		<member name="F:__TAGOF__tag_op">
			<tagname value="tag_op"/>
		</member>
		<member name="F:__TAGOF__tag_uid">
			<tagname value="tag_uid"/>
		</member>
		<member name="F:__YSI_gsCompilerEnum">
		</member>
		<member name="F:__gOnce">
		</member>
		<member name="F:_yGA">
			<referrer name="_yGICommand"/>
			<referrer name="_yGACommand"/>
			<referrer name="_Group_IncludeAll_1"/>
		</member>
		<member name="F:_yGI">
			<referrer name="_yGICommand"/>
			<referrer name="_Group_IncludeAll_1"/>
		</member>
		<member name="F:_yGU">
			<referrer name="_yGICommand"/>
			<referrer name="_yGUCommand"/>
			<referrer name="_Group_IncludeAll_1"/>
		</member>
		<member name="F:gArmySpawns">
			<tagname value="Float"/>
		</member>
		<member name="F:gBase">
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanInit"/>
		</member>
		<member name="F:gCodBase">
			<referrer name="CodeScanRunFastPrescan"/>
			<referrer name="CodeScanInit"/>
		</member>
		<member name="F:gCodBase">
			<referrer name="DisasmInit"/>
			<referrer name="DisasmReloc"/>
			<referrer name="DisasmWriteCode"/>
		</member>
		<member name="F:gCodeScanCallback_match">
			<referrer name="YVA2_Initalise"/>
		</member>
		<member name="F:gDat">
			<referrer name="CodeScanRun"/>
			<referrer name="CodeScanInit"/>
			<referrer name="CodeScanGetMatchFunc"/>
			<referrer name="CodeScanGetMatchAddress"/>
		</member>
		<member name="F:gHdr">
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanInit"/>
		</member>
		<member name="F:gHdr">
			<referrer name="ResetStaticAmxHeader"/>
			<referrer name="GetAmxHeader"/>
			<referrer name="GetAmxHeaderComponent"/>
			<referrer name="PrintAmxHeader"/>
			<referrer name="GetPublicIndexFromAddress"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="HookPublic"/>
			<referrer name="GetNativeIndexFromAddress"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="HookNative"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetPubVarIndexFromAddress"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagIndexFromName"/>
			<referrer name="GetTagIndexFromID"/>
		</member>
		<member name="F:gInitialized">
			<tagname value="bool"/>
			<referrer name="ResetStaticAmxHeader"/>
			<referrer name="GetAmxHeader"/>
			<referrer name="GetAmxHeaderComponent"/>
			<referrer name="PrintAmxHeader"/>
			<referrer name="GetPublicIndexFromAddress"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="HookPublic"/>
			<referrer name="GetNativeIndexFromAddress"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="HookNative"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetPubVarIndexFromAddress"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagIndexFromName"/>
			<referrer name="GetTagIndexFromID"/>
		</member>
		<member name="F:gMedicalSpawns">
			<tagname value="Float"/>
		</member>
		<member name="F:gOP_CASETBL">
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanInit"/>
		</member>
		<member name="F:gOP_NOP">
			<referrer name="CodeScanInit"/>
			<referrer name="CodeScanNOPMatch"/>
		</member>
		<member name="F:gOpArgCount">
			<referrer name="CodeScanRunFastPrescan"/>
		</member>
		<member name="F:gPoliceSpawns">
			<tagname value="Float"/>
		</member>
		<member name="F:gPreviousWriteOffset">
			<referrer name="AsmEmitInstruction"/>
			<referrer name="AsmEmitJumpLabelInstruction"/>
			<referrer name="AsmGetPreviousWriteOffset"/>
		</member>
		<member name="F:gRandomSpawns_LasVenturas">
			<tagname value="Float"/>
		</member>
		<member name="F:gRandomSpawns_LosSantos">
			<tagname value="Float"/>
			<referrer name="OnPlayerSpawn"/>
		</member>
		<member name="F:gRandomSpawns_SanFierro">
			<tagname value="Float"/>
		</member>
		<member name="F:g_args">
			<referrer name="Push"/>
			<referrer name="Pop"/>
			<referrer name="Call"/>
			<referrer name="CallN"/>
			<referrer name="SysreqC"/>
			<referrer name="SysreqD"/>
			<referrer name="SysreqCN"/>
			<referrer name="SysreqDN"/>
		</member>
		<member name="F:g_call_depth">
			<referrer name="exit_public"/>
			<referrer name="enter_public"/>
		</member>
		<member name="F:g_call_stack">
			<referrer name="exit_public"/>
			<referrer name="enter_public"/>
		</member>
		<member name="F:g_nargs">
			<referrer name="Push"/>
			<referrer name="Pop"/>
			<referrer name="Call"/>
			<referrer name="CallN"/>
			<referrer name="SysreqC"/>
			<referrer name="SysreqD"/>
			<referrer name="SysreqCN"/>
			<referrer name="SysreqDN"/>
		</member>
		<member name="F:g_num_pecs">
			<referrer name="new_pec"/>
		</member>
		<member name="F:g_num_publics">
			<referrer name="exit_public"/>
			<referrer name="ProfilerInit"/>
			<referrer name="ProfilerWriteData"/>
		</member>
		<member name="F:g_pecs">
			<referrer name="new_pec"/>
			<referrer name="ProfilerInit"/>
		</member>
		<member name="F:g_publics">
			<referrer name="exit_public"/>
			<referrer name="ProfilerInit"/>
			<referrer name="ProfilerWriteData"/>
		</member>
		<member name="F:insn_table">
			<referrer name="GetOpcodeInstructionInformation"/>
			<referrer name="GetOpcodeInstructionName"/>
			<referrer name="GetOpcodeInstructionParameters"/>
			<referrer name="GetOpcodeInstructionRelocatable"/>
		</member>
		<member name="F:iterstart@Fib">
		</member>
		<member name="F:iterstart@Filter">
		</member>
		<member name="F:iterstart@NonNull">
		</member>
		<member name="F:iterstart@Null">
		</member>
		<member name="F:iterstart@Powers">
		</member>
		<member name="F:iterstart@Random">
		</member>
		<member name="F:iterstart@Range">
		</member>
		<member name="F:iterstart@Until">
		</member>
		<member name="F:opcode_table">
			<tagname value="Opcode"/>
			<referrer name="InitOpcodeTable"/>
			<referrer name="RelocateOpcode"/>
			<referrer name="UnrelocateOpcode"/>
		</member>
		<member name="F:opcode_table_is_ready">
			<tagname value="bool"/>
			<referrer name="InitOpcodeTable"/>
			<referrer name="RelocateOpcode"/>
			<referrer name="UnrelocateOpcode"/>
		</member>
		<member name="F:size_l">
			<remarks>  <p>Because of the strange way we manipulate the stack, this function actually  gets called twice as often as you would expect.  Essentially, for this  (psudo-)loop:</p>  <code>  for (new i = iter_func(); Iter_YieldLoop(); )                              <br />  {                                                                          <br />  }  </code>  <p>The loop is entered and <c>iter_func()</c> is called.  This indirectly  calls <c>yield</c>, which returns to the call point of that function.  The  loop check is then entered and <c>Iter_YieldLoop()</c> is called.  Depending  on if <c>yield</c> was actually used, the main loop body is entered.  At the  end of that iteration, the loop check is run again and so  <c>Iter_YieldLoop()</c> is called again.</p>  <p>This is where it gets wierd!</p>  <p><c>Iter_YieldLoop()</c> does a stack copy and a jump in to the earlier  call to <c>iter_func</c>, whose return address is earlier in the code.  When  a <c>yield</c> is done again, that return is to the first part of the  <c>for</c> loop, which then instantly enters the loop check section and calls  <c>Iter_YieldLoop()</c> again (as a side-effect, saving the iterator value in  the loop variable).</p>  <p>So for <c>N</c> iterations of the loop, <c>Iter_YieldLoop()</c> is called  <c>2N + 1</c> times, and should be made aware of which phase of its calls it  is in.</p>  <p>This is, of course, made more complicated by nested loops, but that just  means we need to store the state on our own stack.</p>  </remarks> 
		</member>
		<member name="F:src_l">
		</member>
		<member name="F:using_deprecated_foreach_syntax">
			<tagname value="bool"/>
			The workings of these macros are very extensively documented at:  <a href="http://forum.sa-mp.com/showpost.php?p=2823668" /> 
		</member>

		<!-- functions -->
		<member name="M:operator!(Float:)" syntax="operator!(Float:)(oper)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="cellmax"/>
			<param name="oper">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator%(_:,Float:)" syntax="operator%(_:,Float:)(oper1, oper2)">
			<stacksize value="1"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator%(Float:,_:)" syntax="operator%(Float:,_:)(oper1, oper2)">
			<stacksize value="1"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator%(Float:,Float:)" syntax="operator%(Float:,Float:)(oper1, oper2)">
			<stacksize value="1"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator!=(Float:,_:)" syntax="operator!=(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator!=(Float:,Float:)" syntax="operator!=(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="RandomFloat"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(_:,Float:)" syntax="operator-(_:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatsub"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(Float:,_:)" syntax="operator-(Float:,_:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatsub"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator+(Float:,_:)" syntax="operator+(Float:,_:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatadd"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator/(_:,Float:)" syntax="operator/(_:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatdiv"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator/(Float:,_:)" syntax="operator/(Float:,_:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatdiv"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator*(Float:,_:)" syntax="operator*(Float:,_:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatmul"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator++(Float:)" syntax="operator++(Float:)(oper)">
			<tagname value="Float"/>
			<stacksize value="1"/>
			<dependency name="operator+(Float:,Float:)"/>
			<param name="oper">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(Float:)" syntax="operator-(Float:)(oper)">
			<tagname value="Float"/>
			<stacksize value="1"/>
			<referrer name="RandomFloat"/>
			<dependency name="cellmin"/>
			<param name="oper">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator--(Float:)" syntax="operator--(Float:)(oper)">
			<tagname value="Float"/>
			<stacksize value="1"/>
			<dependency name="operator-(Float:,Float:)"/>
			<param name="oper">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(Float:,Float:)" syntax="operator-(Float:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator--(Float:)"/>
			<referrer name="RandomFloat"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator+(Float:,Float:)" syntax="operator+(Float:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator++(Float:)"/>
			<referrer name="RandomFloat"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator/(Float:,Float:)" syntax="operator/(Float:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="__TU"/>
			<referrer name="RandomFloat"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator*(Float:,Float:)" syntax="operator*(Float:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="RandomFloat"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator==(Float:,Float:)" syntax="operator==(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator==(Float:,_:)" syntax="operator==(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&gt;(Float:,Float:)" syntax="operator&gt;(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&gt;(Float:,_:)" syntax="operator&gt;(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&gt;(_:,Float:)" syntax="operator&gt;(_:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&gt;=(Float:,Float:)" syntax="operator&gt;=(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&gt;=(Float:,_:)" syntax="operator&gt;=(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&gt;=(_:,Float:)" syntax="operator&gt;=(_:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&lt;(Float:,Float:)" syntax="operator&lt;(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="RandomFloat"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&lt;(Float:,_:)" syntax="operator&lt;(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&lt;(_:,Float:)" syntax="operator&lt;(_:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&lt;=(Float:,Float:)" syntax="operator&lt;=(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&lt;=(Float:,_:)" syntax="operator&lt;=(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&lt;=(_:,Float:)" syntax="operator&lt;=(_:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:@CO_HookChain" syntax="@CO_HookChain()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<referrer name="@CO_Master"/>
			<dependency name="@CO_ScriptInit"/>
		</member>
		<member name="M:@CO_Master" syntax="@CO_Master()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="@CO_HookChain"/>
		</member>
		<member name="M:@CO_ScriptInit" syntax="@CO_ScriptInit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<referrer name="@CO_HookChain"/>
		</member>
		<member name="M:@RETOnPlayerCommandText" syntax="@RETOnPlayerCommandText()">
			<attribute name="public"/>
			<stacksize value="1"/>
		</member>
		<member name="M:@RETOnRconCommand" syntax="@RETOnRconCommand()">
			<attribute name="public"/>
			<stacksize value="1"/>
		</member>
		<member name="M:@_" syntax="@_()">
			<attribute name="public"/>
			<stacksize value="7"/>
			<automaton name="@_"/>
			<dependency name="CallLocalFunction"/>
			<dependency name="CallRemoteFunction"/>
			<dependency name="Debug_Print0"/>
			<dependency name="Master_GetCurrentMaster"/>
			<dependency name="_@"/>
			<dependency name="_E_YCM@m"/>
			<dependency name="_E_YCM@n"/>
			<dependency name="_E_YCM@p"/>
			<dependency name="_E_YCM@y"/>
			<dependency name="_Master_Relinquish"/>
			<dependency name="_YCM_g@_"/>
			<dependency name="getproperty"/>
			<dependency name="setproperty"/>
			<transition keep="true" target="_YCM : m" source="_YCM : y" />  <transition keep="true" target="_YCM : p" source="_YCM : y" />  <transition keep="true" target="_YCM : n" source="_YCM : y" />  <transition keep="true" target="_YCM : y" source="_YCM : u" /> <p/> <transition target="La" source="_ALS_go"/>

		</member>
		<member name="M:@_OnScriptInit" syntax="@_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="Master_GetCurrentMaster"/>
		</member>
		<member name="M:@_yCjoinfight" syntax="@_yCjoinfight(playerid, params[], help)">
			<attribute name="public"/>
			<stacksize value="17"/>
			<referrer name="@yC_joinfight"/>
			<dependency name="GetPlayerFacingAngle"/>
			<dependency name="GetPlayerPos"/>
			<dependency name="Iter_CreateVehicle"/>
			<dependency name="PutPlayerInVehicle"/>
			<param name="playerid">
			</param>
			<param name="params">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="help">
			</param>
		</member>
		<member name="M:@_yHCheckpoint" syntax="@_yHCheckpoint()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHCommand" syntax="@_yHCommand()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHContainer" syntax="@_yHContainer()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHDynamic" syntax="@_yHDynamic()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHDynamicCP" syntax="@_yHDynamicCP()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHInventory" syntax="@_yHInventory()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHObject" syntax="@_yHObject()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHTextDraw" syntax="@_yHTextDraw()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHUpdate" syntax="@_yHUpdate()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@a" syntax="@a()">
			<attribute name="public"/>
			<stacksize value="7"/>
			<automaton name="@a"/>
			<dependency name="CallLocalFunction"/>
			<dependency name="CallRemoteFunction"/>
			<dependency name="Debug_Print0"/>
			<dependency name="Master_GetCurrentMaster"/>
			<dependency name="_@"/>
			<dependency name="_E_YCM@m"/>
			<dependency name="_E_YCM@n"/>
			<dependency name="_E_YCM@p"/>
			<dependency name="_E_YCM@y"/>
			<dependency name="_Master_Relinquish"/>
			<dependency name="_YCM_g@a"/>
			<dependency name="getproperty"/>
			<dependency name="setproperty"/>
			<transition keep="true" target="_YCM : m" source="_YCM : y" />  <transition keep="true" target="_YCM : p" source="_YCM : y" />  <transition keep="true" target="_YCM : n" source="_YCM : y" />  <transition keep="true" target="_YCM : y" source="_YCM : u" /> <p/> <transition target="dd" source="_ALS_go"/>

		</member>
		<member name="M:@receivepacket" syntax="@receivepacket(packet[], size, source[])">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="packet">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:@receivestring" syntax="@receivestring(message[], source[])">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="message">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:@yC_joinfight" syntax="@yC_joinfight(a, b[], c, i)">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="@_yCjoinfight"/>
			<dependency name="U@"/>
			<dependency name="_@"/>
			<param name="a">
			</param>
			<param name="b">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="c">
			</param>
			<param name="i">
			</param>
		</member>
		<member name="M:@yH_OnMasterSystemClose@004" syntax="@yH_OnMasterSystemClose@004(id)">
			<attribute name="public"/>
			<stacksize value="17"/>
			<automaton name="@_"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_Read"/>
			<dependency name="Command_Remove"/>
			<dependency name="Debug_Print0"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="E_COMMAND_POINTER"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sMasterData"/>
			<dependency name="_@"/>
			<dependency name="cellmin"/>
			<dependency name="funcidx"/>
			<dependency name="strpack"/>
			<param name="id">
			</param>
		</member>
		<member name="M:@yH_OnPlayerCommandText@004" syntax="@yH_OnPlayerCommandText@004(playerid, cmdtext[])">
			<attribute name="public"/>
			<stacksize value="6"/>
			<automaton name="@_"/>
			<dependency name="Command_ReProcess"/>
			<param name="playerid">
				Player who typed a command.
			</param>
			<param name="cmdtext">
				<paraminfo> [] </paraminfo>
				What they typed.
			</param>
			    <returns>  0 - Could not process the command.  1 - Called the command.  </returns>  <remarks>  The core of the command processor.  Now vsatly simplified.  This function first finds the command in our hash map.  If it exists, it  checks if the player can use it.  If they can, it checks if it is only in  the current script.  If it is it calls it directly, if it isn't it calls it  using "CallRemoteFunction", which takes in to account master states in  multiple scripts and the special master 23, which calls it in only one  other script.  </remarks> 
		</member>
		<member name="M:@yH_OnPlayerConnect@003" syntax="@yH_OnPlayerConnect@003(playerid)">
			<attribute name="public"/>
			<stacksize value="7"/>
			<dependency name="IsPlayerNPC"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_Single@Bot"/>
			<dependency name="Iter_Single@Character"/>
			<dependency name="Iter_Single@Player"/>
			<dependency name="Iterator@Bot"/>
			<dependency name="Iterator@Character"/>
			<dependency name="Iterator@Player"/>
			<param name="playerid">
				Player who joined.
			</param>
			  <remarks>  Adds a player to the loop data.  Now sorts the list too.  Note that I found  the most bizzare bug ever (I *think* it may be a compiler but, but it  requires further investigation), basically it seems that multiple variables  were being treated as the same variable (namely @YSII_EgotS and  @YSII_CgharacterS were the same and @YSII_EgotC and @YSII_CgharacterC were the  same).  Adding print statements which reference these variables seem to fix  the problem, and I've tried to make sure that the values will never actually  get printed.  </remarks> 
		</member>
		<member name="M:@yH_OnPlayerDisconnect@003" syntax="@yH_OnPlayerDisconnect@003(playerid, reason)">
			<attribute name="public"/>
			<stacksize value="7"/>
			<dependency name="SetTimerEx"/>
			<dependency name="false"/>
			<param name="playerid">
				Player who left.
			</param>
			<param name="reason">
			</param>
			  <remarks>  Removes a player from the loop data.  No longer uses "hook" to ENSURE  that this is always last.  Previously I think that the order of  evaluation in y_hooks meant that this got called before the user  "OnPlayerDisconnect".  </remarks> 
		</member>
		<member name="M:@yH_OnPlayerText@004" syntax="@yH_OnPlayerText@004(playerid, text[])">
			<attribute name="public"/>
			<stacksize value="6"/>
			<automaton name="@_"/>
			<dependency name="Command_ReProcess"/>
			<param name="playerid">
				Player who typed something.
			</param>
			<param name="text">
				<paraminfo> [] </paraminfo>
				What they typed.
			</param>
			    <returns>  0 - Could not process the command.  1 - Called the command.  </returns>  <remarks>  Used to implement alternate command prefixes.  </remarks> 
		</member>
		<member name="M:@yH_OnScriptExit@004" syntax="@yH_OnScriptExit@004()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="Command_DecOPCP"/>
			<dependency name="Command_DecOPCR"/>
			<dependency name="YSI_gscOPCP"/>
			<dependency name="YSI_gscOPCR"/>
			<dependency name="funcidx"/>
			<remarks>  When a script ends, update the status of any new callback hooks.  </remarks> 
		</member>
		<member name="M:@yH_OnScriptInit@002" syntax="@yH_OnScriptInit@002()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<dependency name="YSI_g_sStack"/>
			<dependency name="YSI_g_sStackPtr"/>
			<remarks>  </remarks> 
		</member>
		<member name="M:@yH_OnScriptInit@003" syntax="@yH_OnScriptInit@003()">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="GetVehicleModel"/>
			<dependency name="IsPlayerConnected"/>
			<dependency name="IsPlayerNPC"/>
			<dependency name="IsValidActor"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_Clear_InternalC"/>
			<dependency name="Iter_Single@Actor"/>
			<dependency name="Iter_Single@Bot"/>
			<dependency name="Iter_Single@Character"/>
			<dependency name="Iter_Single@Player"/>
			<dependency name="Iter_Single@Vehicle"/>
			<dependency name="Iterator@Actor"/>
			<dependency name="Iterator@Bot"/>
			<dependency name="Iterator@Character"/>
			<dependency name="Iterator@Player"/>
			<dependency name="Iterator@Vehicle"/>
			<remarks>  Sets up all existing iterators.  Does nothing for "XXLocal" ones, since they  are by definition empty when a script starts.  </remarks> 
		</member>
		<member name="M:@yH_OnScriptInit@004" syntax="@yH_OnScriptInit@004()">
			<attribute name="public"/>
			<stacksize value="18"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_ReadString"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="Command_Add"/>
			<dependency name="Command_IncOPCP"/>
			<dependency name="Command_IncOPCR"/>
			<dependency name="Debug_Print0"/>
			<dependency name="E_COMMAND_HASH_MAP"/>
			<dependency name="E_COMMAND_POINTER"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="YSI_g_sCommandMap"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_gscOPCP"/>
			<dependency name="YSI_gscOPCR"/>
			<dependency name="_HashMap_Init"/>
			<dependency name="e_COMMAND_FLAGS_OK"/>
			<dependency name="funcidx"/>
			<dependency name="tolower"/>
			<remarks>  Add all local commands in to the system.  </remarks> 
		</member>
		<member name="M:AMX_DoNothing" syntax="AMX_DoNothing()">
			<stacksize value="1"/>
			<referrer name="AMX_GetGlobal"/>
		</member>
		<member name="M:AMX_GetBaseCount" syntax="AMX_GetBaseCount(table, &amp;base, &amp;count)">
			<stacksize value="1"/>
			<referrer name="AMX_GetEntry"/>
			<referrer name="AMX_GetEntryPrefix"/>
			<referrer name="AMX_GetEntrySuffix"/>
			<referrer name="AMX_GetName"/>
			<referrer name="AMX_GetNamePrefix"/>
			<referrer name="AMX_GetNameSuffix"/>
			<dependency name="AMX_HEADER_LIBRARIES"/>
			<dependency name="AMX_HEADER_NAMETABLE"/>
			<dependency name="AMX_HEADER_NATIVES"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_HEADER_PUBVARS"/>
			<dependency name="AMX_HEADER_TAGS"/>
			<dependency name="AMX_TABLE_LIBRARIES"/>
			<dependency name="AMX_TABLE_NATIVES"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="AMX_TABLE_PUBVARS"/>
			<dependency name="AMX_TABLE_TAGS"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="base">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:AMX_GetEntry" syntax="AMX_GetEntry(table, idx, &amp;buffer, pattern[], exact)">
			<stacksize value="42"/>
			<referrer name="AMX_GetPointer"/>
			<referrer name="Hooks_GetPreHooks"/>
			<referrer name="Hooks_GetFunctionWritePoint"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<dependency name="AMX_ReadString"/>
			<dependency name="strcmp"/>
			<dependency name="strfind"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="exact">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AMX_GetEntryFromNativeIndex" syntax="AMX_GetEntryFromNativeIndex(index)">
			<stacksize value="1"/>
			<dependency name="AMX_HEADER_NATIVES"/>
			<param name="index">
			</param>
		</member>
		<member name="M:AMX_GetEntryFromPublicIndex" syntax="AMX_GetEntryFromPublicIndex(index)">
			<stacksize value="1"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<param name="index">
			</param>
		</member>
		<member name="M:AMX_GetEntryPointer" syntax="AMX_GetEntryPointer(entry)">
			<stacksize value="1"/>
			<param name="entry">
			</param>
		</member>
		<member name="M:AMX_GetEntryPrefix" syntax="AMX_GetEntryPrefix(table, idx, &amp;buffer, pattern)">
			<stacksize value="9"/>
			<referrer name="AMX_GetPointerPrefix"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_CountInvalidPublics"/>
			<referrer name="VA_OnScriptInit"/>
			<referrer name="@yH_OnScriptInit@004"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetEntrySuffix" syntax="AMX_GetEntrySuffix(table, idx, &amp;buffer, pattern)">
			<stacksize value="10"/>
			<referrer name="AMX_GetPointerSuffix"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetGlobal" syntax="AMX_GetGlobal()">
			<stacksize value="4"/>
			<referrer name="Debug_OnScriptInit"/>
			<dependency name="AMX_DoNothing"/>
			<dependency name="AMX_HEADER_COD"/>
		</member>
		<member name="M:AMX_GetGlobalAddress" syntax="AMX_GetGlobalAddress(...)">
			<stacksize value="2"/>
			<dependency name="AMX_REAL_DATA"/>
			<param name="...">
			</param>
		</member>
		<member name="M:AMX_GetName" syntax="AMX_GetName(table, idx, buffer[], pattern[], exact)">
			<stacksize value="10"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<dependency name="AMX_ReadString"/>
			<dependency name="strcmp"/>
			<dependency name="strfind"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> [32] </paraminfo>
			</param>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="exact">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AMX_GetNamePrefix" syntax="AMX_GetNamePrefix(table, idx, buffer[], pattern)">
			<stacksize value="9"/>
			<referrer name="Hooks_DoAllHooks"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<dependency name="AMX_ReadString"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> [32] </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetNameSuffix" syntax="AMX_GetNameSuffix(table, idx, buffer[], pattern)">
			<stacksize value="10"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<dependency name="AMX_ReadString"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> [32] </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetNativeIndexFromEntry" syntax="AMX_GetNativeIndexFromEntry(entry)">
			<stacksize value="1"/>
			<dependency name="AMX_HEADER_NATIVES"/>
			<param name="entry">
			</param>
		</member>
		<member name="M:AMX_GetPointer" syntax="AMX_GetPointer(table, idx, &amp;buffer, pattern[], exact)">
			<stacksize value="9"/>
			<referrer name="AMX_GetValue"/>
			<dependency name="AMX_GetEntry"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="exact">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AMX_GetPointerPrefix" syntax="AMX_GetPointerPrefix(table, idx, &amp;buffer, pattern)">
			<stacksize value="8"/>
			<referrer name="AMX_GetValuePrefix"/>
			<referrer name="_yGICommand"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetPointerSuffix" syntax="AMX_GetPointerSuffix(table, idx, &amp;buffer, pattern)">
			<stacksize value="8"/>
			<referrer name="AMX_GetValueSuffix"/>
			<dependency name="AMX_GetEntrySuffix"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetPublicIndexFromEntry" syntax="AMX_GetPublicIndexFromEntry(entry)">
			<stacksize value="1"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<param name="entry">
			</param>
		</member>
		<member name="M:AMX_GetRelativeAddress" syntax="AMX_GetRelativeAddress(...)">
			<stacksize value="2"/>
			<param name="...">
			</param>
		</member>
		<member name="M:AMX_GetStringFromEntry" syntax="AMX_GetStringFromEntry(entry, str[], size)">
			<stacksize value="6"/>
			<referrer name="Hooks_GetAllHooks"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_ReadString"/>
			<param name="entry">
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:AMX_GetValue" syntax="AMX_GetValue(table, idx, &amp;buffer, pattern[], exact)">
			<stacksize value="9"/>
			<dependency name="AMX_GetPointer"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="exact">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AMX_GetValuePrefix" syntax="AMX_GetValuePrefix(table, idx, &amp;buffer, pattern)">
			<stacksize value="8"/>
			<dependency name="AMX_GetPointerPrefix"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetValueSuffix" syntax="AMX_GetValueSuffix(table, idx, &amp;buffer, pattern)">
			<stacksize value="8"/>
			<dependency name="AMX_GetPointerSuffix"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_OnScriptInit" syntax="AMX_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="YSI_g_sInitialised"/>
			<dependency name="YVA2_Initalise"/>
		</member>
		<member name="M:AMX_RawRead" syntax="AMX_RawRead(addr)">
			<stacksize value="1"/>
			<referrer name="AMX_Read"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:AMX_RawWrite" syntax="AMX_RawWrite(addr, value)">
			<stacksize value="1"/>
			<param name="addr">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AMX_Read" syntax="AMX_Read(addr)">
			<stacksize value="33"/>
			<referrer name="CGen_GetAddr"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GenerateCode"/>
			<referrer name="Hooks_InvalidateName"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_CompareNextCell"/>
			<referrer name="Hooks_ComparePublics"/>
			<referrer name="Hooks_SortPublics"/>
			<referrer name="VA_OnScriptInit"/>
			<referrer name="HashMap_RemoveKeyWithHash"/>
			<referrer name="HashMap_GetBranchEnd"/>
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="@yH_OnMasterSystemClose@004"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_RawRead"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmEmitLrefSPri"/>
			<dependency name="AsmEmitNop"/>
			<dependency name="AsmEmitPopAlt"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="Debug_Print0"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmDecodeInsn"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmInit"/>
			<dependency name="GetCurrentFrameReturn"/>
			<dependency name="OP_PUSH_C"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:AMX_ReadArray" syntax="AMX_ReadArray(addr, dest[], len)">
			<stacksize value="1"/>
			<param name="addr">
			</param>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:AMX_ReadString" syntax="AMX_ReadString(addr, str[], len)">
			<stacksize value="3"/>
			<referrer name="AMX_GetEntry"/>
			<referrer name="AMX_GetName"/>
			<referrer name="AMX_GetNamePrefix"/>
			<referrer name="AMX_GetNameSuffix"/>
			<referrer name="AMX_GetStringFromEntry"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="@yH_OnScriptInit@004"/>
			<param name="addr">
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:AMX_ReadUnpackedString" syntax="AMX_ReadUnpackedString(addr, str[], len)">
			<stacksize value="2"/>
			<param name="addr">
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:AMX_TraceCode" syntax="AMX_TraceCode(pattern[], &amp;addrRet, &amp;dataRet, size)">
			<stacksize value="4"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_HEADER_DAT"/>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="addrRet">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="dataRet">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:AMX_TraceMemory" syntax="AMX_TraceMemory(pattern[], &amp;addrRet, &amp;dataRet, size)">
			<stacksize value="4"/>
			<dependency name="AMX_HEADER_DAT"/>
			<dependency name="AMX_HEADER_HEA"/>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="addrRet">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="dataRet">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:AMX_Write" syntax="AMX_Write(addr, value)">
			<stacksize value="1"/>
			<referrer name="CGen_SetupCodeSpace"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GenerateCode"/>
			<referrer name="Hooks_InvalidateName"/>
			<referrer name="Hooks_ComparePublics"/>
			<referrer name="Hooks_SortPublics"/>
			<referrer name="HashMap_Add"/>
			<referrer name="HashMap_RemoveKeyWithHash"/>
			<param name="addr">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AMX_WriteArray" syntax="AMX_WriteArray(addr, src[], len)">
			<stacksize value="1"/>
			<param name="addr">
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:AMX_WriteString" syntax="AMX_WriteString(addr, str[], len)">
			<stacksize value="4"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<param name="addr">
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:AbsToRel" syntax="AbsToRel(address)">
			<stacksize value="3"/>
			<referrer name="ReadPhysMemory"/>
			<referrer name="WritePhysMemory"/>
			<referrer name="ReadPhysMemoryCell"/>
			<referrer name="WritePhysMemoryCell"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetDat"/>
			<param name="address">
			</param>
		</member>
		<member name="M:AddStaticVehicle" syntax="AddStaticVehicle(modelid, spawn_x, spawn_y, spawn_z, z_angle, color1, color2)">
			<attribute name="native"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<param name="modelid">
			</param>
			<param name="spawn_x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z_angle">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="color1">
			</param>
			<param name="color2">
			</param>
		</member>
		<member name="M:AddStaticVehicleEx" syntax="AddStaticVehicleEx(modelid, spawn_x, spawn_y, spawn_z, z_angle, color1, color2, respawn_delay, addsiren)">
			<attribute name="native"/>
			<referrer name="LoadStaticVehiclesFromFile"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<param name="modelid">
			</param>
			<param name="spawn_x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z_angle">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="color1">
			</param>
			<param name="color2">
			</param>
			<param name="respawn_delay">
			</param>
			<param name="addsiren">
			</param>
		</member>
		<member name="M:AsmClearError" syntax="AsmClearError(ctx[])">
			<stacksize value="5"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmSetError"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitAdd" syntax="AsmEmitAdd(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ADD"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitAddC" syntax="AsmEmitAddC(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="bernstein"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ADD_C"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitAddrAlt" syntax="AsmEmitAddrAlt(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ADDR_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitAddrPri" syntax="AsmEmitAddrPri(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ADDR_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitAlignAlt" syntax="AsmEmitAlignAlt(ctx[], number)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ALIGN_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="number">
			</param>
		</member>
		<member name="M:AsmEmitAlignPri" syntax="AsmEmitAlignPri(ctx[], number)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ALIGN_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="number">
			</param>
		</member>
		<member name="M:AsmEmitAnd" syntax="AsmEmitAnd(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="rawMemset"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_AND"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitBounds" syntax="AsmEmitBounds(ctx[], bound)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_BOUNDS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="bound">
			</param>
		</member>
		<member name="M:AsmEmitBreak" syntax="AsmEmitBreak(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_BREAK"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitCall" syntax="AsmEmitCall(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_CALL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitCallAbs" syntax="AsmEmitCallAbs(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="24"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="OP_CALL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitCallLabelStringize" syntax="AsmEmitCallLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_CALL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitCell" syntax="AsmEmitCell(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="AsmEmitJumpStringize"/>
			<referrer name="AsmEmitOpcode"/>
			<referrer name="AsmEmitOperand"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="ASM_ERROR_SPACE"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_buffer_size"/>
			<dependency name="AsmRaiseError"/>
			<dependency name="WriteAmxMemory"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitCmps" syntax="AsmEmitCmps(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_CMPS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitConstAlt" syntax="AsmEmitConstAlt(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="bernstein"/>
			<referrer name="rawMemset"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_CONST_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitConstPri" syntax="AsmEmitConstPri(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_CONST_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitDec" syntax="AsmEmitDec(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_DEC"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitDecAlt" syntax="AsmEmitDecAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_DEC_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitDecI" syntax="AsmEmitDecI(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_DEC_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitDecPri" syntax="AsmEmitDecPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_DEC_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitDecS" syntax="AsmEmitDecS(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_DEC_S"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitEq" syntax="AsmEmitEq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_EQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitEqCAlt" syntax="AsmEmitEqCAlt(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_EQ_C_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitEqCPri" syntax="AsmEmitEqCPri(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_EQ_C_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitFill" syntax="AsmEmitFill(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="rawMemset"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_FILL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitGeq" syntax="AsmEmitGeq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_GEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitGrtr" syntax="AsmEmitGrtr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_GRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitHalt" syntax="AsmEmitHalt(ctx[], code)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_HALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="code">
			</param>
		</member>
		<member name="M:AsmEmitHeap" syntax="AsmEmitHeap(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_HEAP"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitIdxaddr" syntax="AsmEmitIdxaddr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_IDXADDR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitIdxaddrB" syntax="AsmEmitIdxaddrB(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_IDXADDR_B"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitInc" syntax="AsmEmitInc(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INC"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitIncAlt" syntax="AsmEmitIncAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INC_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitIncI" syntax="AsmEmitIncI(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INC_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitIncPri" syntax="AsmEmitIncPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INC_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitIncS" syntax="AsmEmitIncS(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INC_S"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitInstruction" syntax="AsmEmitInstruction(ctx[], opcode, ...)">
			<tagname value="AsmError"/>
			<stacksize value="8"/>
			<referrer name="AsmEmitJumpInstruction"/>
			<referrer name="AsmEmitAdd"/>
			<referrer name="AsmEmitAddC"/>
			<referrer name="AsmEmitAddrAlt"/>
			<referrer name="AsmEmitAddrPri"/>
			<referrer name="AsmEmitAlignAlt"/>
			<referrer name="AsmEmitAlignPri"/>
			<referrer name="AsmEmitAnd"/>
			<referrer name="AsmEmitBounds"/>
			<referrer name="AsmEmitBreak"/>
			<referrer name="AsmEmitCall"/>
			<referrer name="AsmEmitCallAbs"/>
			<referrer name="AsmEmitCmps"/>
			<referrer name="AsmEmitConstAlt"/>
			<referrer name="AsmEmitConstPri"/>
			<referrer name="AsmEmitDec"/>
			<referrer name="AsmEmitDecAlt"/>
			<referrer name="AsmEmitDecI"/>
			<referrer name="AsmEmitDecPri"/>
			<referrer name="AsmEmitDecS"/>
			<referrer name="AsmEmitEq"/>
			<referrer name="AsmEmitEqCAlt"/>
			<referrer name="AsmEmitEqCPri"/>
			<referrer name="AsmEmitFill"/>
			<referrer name="AsmEmitGeq"/>
			<referrer name="AsmEmitGrtr"/>
			<referrer name="AsmEmitHalt"/>
			<referrer name="AsmEmitHeap"/>
			<referrer name="AsmEmitIdxaddr"/>
			<referrer name="AsmEmitIdxaddrB"/>
			<referrer name="AsmEmitInc"/>
			<referrer name="AsmEmitIncAlt"/>
			<referrer name="AsmEmitIncI"/>
			<referrer name="AsmEmitIncPri"/>
			<referrer name="AsmEmitIncS"/>
			<referrer name="AsmEmitInvert"/>
			<referrer name="AsmEmitJeq"/>
			<referrer name="AsmEmitJgeq"/>
			<referrer name="AsmEmitJgrtr"/>
			<referrer name="AsmEmitJleq"/>
			<referrer name="AsmEmitJless"/>
			<referrer name="AsmEmitJneq"/>
			<referrer name="AsmEmitJnz"/>
			<referrer name="AsmEmitJsgeq"/>
			<referrer name="AsmEmitJsgrtr"/>
			<referrer name="AsmEmitJsleq"/>
			<referrer name="AsmEmitJsless"/>
			<referrer name="AsmEmitJump"/>
			<referrer name="AsmEmitJzer"/>
			<referrer name="AsmEmitLctrl"/>
			<referrer name="AsmEmitLeq"/>
			<referrer name="AsmEmitLess"/>
			<referrer name="AsmEmitLidx"/>
			<referrer name="AsmEmitLidxB"/>
			<referrer name="AsmEmitLoadAlt"/>
			<referrer name="AsmEmitLoadPri"/>
			<referrer name="AsmEmitLoad"/>
			<referrer name="AsmEmitLoadI"/>
			<referrer name="AsmEmitLoadSAlt"/>
			<referrer name="AsmEmitLoadSPri"/>
			<referrer name="AsmEmitLodbI"/>
			<referrer name="AsmEmitLrefAlt"/>
			<referrer name="AsmEmitLrefPri"/>
			<referrer name="AsmEmitLrefSAlt"/>
			<referrer name="AsmEmitLrefSPri"/>
			<referrer name="AsmEmitMoveAlt"/>
			<referrer name="AsmEmitMovePri"/>
			<referrer name="AsmEmitMovs"/>
			<referrer name="AsmEmitNeg"/>
			<referrer name="AsmEmitNeq"/>
			<referrer name="AsmEmitNop"/>
			<referrer name="AsmEmitNot"/>
			<referrer name="AsmEmitOr"/>
			<referrer name="AsmEmitPopAlt"/>
			<referrer name="AsmEmitPopPri"/>
			<referrer name="AsmEmitProc"/>
			<referrer name="AsmEmitPushAdr"/>
			<referrer name="AsmEmitPushAlt"/>
			<referrer name="AsmEmitPushC"/>
			<referrer name="AsmEmitPushPri"/>
			<referrer name="AsmEmitPush"/>
			<referrer name="AsmEmitPushS"/>
			<referrer name="AsmEmitRet"/>
			<referrer name="AsmEmitRetn"/>
			<referrer name="AsmEmitSctrl"/>
			<referrer name="AsmEmitSdiv"/>
			<referrer name="AsmEmitSdivAlt"/>
			<referrer name="AsmEmitSgeq"/>
			<referrer name="AsmEmitSgrtr"/>
			<referrer name="AsmEmitShl"/>
			<referrer name="AsmEmitShlCAlt"/>
			<referrer name="AsmEmitShlCPri"/>
			<referrer name="AsmEmitShrCAlt"/>
			<referrer name="AsmEmitShrCPri"/>
			<referrer name="AsmEmitShr"/>
			<referrer name="AsmEmitSignAlt"/>
			<referrer name="AsmEmitSignPri"/>
			<referrer name="AsmEmitSleq"/>
			<referrer name="AsmEmitSless"/>
			<referrer name="AsmEmitSmul"/>
			<referrer name="AsmEmitSmulC"/>
			<referrer name="AsmEmitSshr"/>
			<referrer name="AsmEmitSrefAlt"/>
			<referrer name="AsmEmitSrefPri"/>
			<referrer name="AsmEmitSrefSAlt"/>
			<referrer name="AsmEmitSrefSPri"/>
			<referrer name="AsmEmitStack"/>
			<referrer name="AsmEmitStorAlt"/>
			<referrer name="AsmEmitStorPri"/>
			<referrer name="AsmEmitStorI"/>
			<referrer name="AsmEmitStorSAlt"/>
			<referrer name="AsmEmitStorSPri"/>
			<referrer name="AsmEmitStrbI"/>
			<referrer name="AsmEmitSub"/>
			<referrer name="AsmEmitSubAlt"/>
			<referrer name="AsmEmitSwapAlt"/>
			<referrer name="AsmEmitSwapPri"/>
			<referrer name="AsmEmitSysreqC"/>
			<referrer name="AsmEmitSysreqD"/>
			<referrer name="AsmEmitSysreqPri"/>
			<referrer name="AsmEmitUdiv"/>
			<referrer name="AsmEmitUdivAlt"/>
			<referrer name="AsmEmitUmul"/>
			<referrer name="AsmEmitXchg"/>
			<referrer name="AsmEmitXor"/>
			<referrer name="AsmEmitZero"/>
			<referrer name="AsmEmitZeroAlt"/>
			<referrer name="AsmEmitZeroPri"/>
			<referrer name="AsmEmitZeroS"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmEmitOpcode"/>
			<dependency name="AsmEmitOperand"/>
			<dependency name="gPreviousWriteOffset"/>
			<dependency name="getarg"/>
			<dependency name="numargs"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
			<param name="...">
			</param>
		</member>
		<member name="M:AsmEmitInvert" syntax="AsmEmitInvert(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INVERT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJeq" syntax="AsmEmitJeq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJeqLabelStringize" syntax="AsmEmitJeqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJeqRel" syntax="AsmEmitJeqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJgeq" syntax="AsmEmitJgeq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJgeqLabelStringize" syntax="AsmEmitJgeqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJgeqRel" syntax="AsmEmitJgeqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJgrtr" syntax="AsmEmitJgrtr(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJgrtrLabelStringize" syntax="AsmEmitJgrtrLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJgrtrRel" syntax="AsmEmitJgrtrRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJleq" syntax="AsmEmitJleq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJleqLabelStringize" syntax="AsmEmitJleqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJleqRel" syntax="AsmEmitJleqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJless" syntax="AsmEmitJless(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJlessLabelStringize" syntax="AsmEmitJlessLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJlessRel" syntax="AsmEmitJlessRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJneq" syntax="AsmEmitJneq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JNEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJneqLabelStringize" syntax="AsmEmitJneqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JNEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJneqRel" syntax="AsmEmitJneqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JNEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJnz" syntax="AsmEmitJnz(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JNZ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJnzLabelStringize" syntax="AsmEmitJnzLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JNZ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJnzRel" syntax="AsmEmitJnzRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="bernstein"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JNZ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJrel" syntax="AsmEmitJrel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JREL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJrelLabelStringize" syntax="AsmEmitJrelLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JREL"/>
			<dependency name="true"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJsgeq" syntax="AsmEmitJsgeq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JSGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJsgeqLabelStringize" syntax="AsmEmitJsgeqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JSGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJsgeqRel" syntax="AsmEmitJsgeqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JSGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJsgrtr" syntax="AsmEmitJsgrtr(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JSGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJsgrtrLabelStringize" syntax="AsmEmitJsgrtrLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JSGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJsgrtrRel" syntax="AsmEmitJsgrtrRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JSGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJsleq" syntax="AsmEmitJsleq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JSLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJsleqLabelStringize" syntax="AsmEmitJsleqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JSLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJsleqRel" syntax="AsmEmitJsleqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JSLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJsless" syntax="AsmEmitJsless(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JSLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJslessLabelStringize" syntax="AsmEmitJslessLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JSLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJslessRel" syntax="AsmEmitJslessRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JSLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJump" syntax="AsmEmitJump(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JUMP"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJumpInstruction" syntax="AsmEmitJumpInstruction(ctx[], opcode, offset)">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<referrer name="AsmEmitJeqRel"/>
			<referrer name="AsmEmitJgeqRel"/>
			<referrer name="AsmEmitJgrtrRel"/>
			<referrer name="AsmEmitJleqRel"/>
			<referrer name="AsmEmitJlessRel"/>
			<referrer name="AsmEmitJneqRel"/>
			<referrer name="AsmEmitJnzRel"/>
			<referrer name="AsmEmitJsgeqRel"/>
			<referrer name="AsmEmitJsgrtrRel"/>
			<referrer name="AsmEmitJsleqRel"/>
			<referrer name="AsmEmitJslessRel"/>
			<referrer name="AsmEmitJumpRel"/>
			<referrer name="AsmEmitJzerRel"/>
			<referrer name="AsmEmitJrel"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="AsmGetJumpAddressFromOffset"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJumpLabelInstruction" syntax="AsmEmitJumpLabelInstruction(ctx[], opcode, label[], relative)">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<referrer name="AsmEmitCallLabelStringize"/>
			<referrer name="AsmEmitJeqLabelStringize"/>
			<referrer name="AsmEmitJgeqLabelStringize"/>
			<referrer name="AsmEmitJgrtrLabelStringize"/>
			<referrer name="AsmEmitJleqLabelStringize"/>
			<referrer name="AsmEmitJlessLabelStringize"/>
			<referrer name="AsmEmitJneqLabelStringize"/>
			<referrer name="AsmEmitJnzLabelStringize"/>
			<referrer name="AsmEmitJsgeqLabelStringize"/>
			<referrer name="AsmEmitJsgrtrLabelStringize"/>
			<referrer name="AsmEmitJsleqLabelStringize"/>
			<referrer name="AsmEmitJslessLabelStringize"/>
			<referrer name="AsmEmitJumpLabelStringize"/>
			<referrer name="AsmEmitJzerLabelStringize"/>
			<referrer name="AsmEmitJrelLabelStringize"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmEmitJumpStringize"/>
			<dependency name="AsmEmitOpcode"/>
			<dependency name="gPreviousWriteOffset"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="relative">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJumpLabelStringize" syntax="AsmEmitJumpLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JUMP"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJumpRel" syntax="AsmEmitJumpRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JUMP"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJumpStringize" syntax="AsmEmitJumpStringize(ctx[], label[], relative)">
			<tagname value="AsmError"/>
			<stacksize value="10"/>
			<referrer name="AsmEmitJumpLabelInstruction"/>
			<dependency name="ASM_ERROR_LABEL_OVERFLOW"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_label_names"/>
			<dependency name="AsmContext_labels"/>
			<dependency name="AsmEmitCell"/>
			<dependency name="AsmFindLabelIndex"/>
			<dependency name="AsmHashLabel"/>
			<dependency name="AsmRaiseError"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="relative">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJzer" syntax="AsmEmitJzer(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JZER"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJzerLabelStringize" syntax="AsmEmitJzerLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JZER"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJzerRel" syntax="AsmEmitJzerRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="bernstein"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JZER"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitLabelStringize" syntax="AsmEmitLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="11"/>
			<dependency name="ASM_ERROR_LABEL_DUPLICATE"/>
			<dependency name="ASM_ERROR_LABEL_OVERFLOW"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_label_names"/>
			<dependency name="AsmContext_labels"/>
			<dependency name="AsmFindLabelIndex"/>
			<dependency name="AsmGetJumpAddressFromOffset"/>
			<dependency name="AsmHashLabel"/>
			<dependency name="AsmRaiseError"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="WriteAmxMemory"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitLctrl" syntax="AsmEmitLctrl(ctx[], index)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LCTRL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:AsmEmitLeq" syntax="AsmEmitLeq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitLess" syntax="AsmEmitLess(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitLidx" syntax="AsmEmitLidx(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LIDX"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitLidxB" syntax="AsmEmitLidxB(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LIDX_B"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitLoad" syntax="AsmEmitLoad(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitLoadAlt" syntax="AsmEmitLoadAlt(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitLoadI" syntax="AsmEmitLoadI(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitLoadPri" syntax="AsmEmitLoadPri(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="rawMemset"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitLoadSAlt" syntax="AsmEmitLoadSAlt(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="rawMemset"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_S_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitLoadSPri" syntax="AsmEmitLoadSPri(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="rawMemset"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_S_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitLodbI" syntax="AsmEmitLodbI(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LODB_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitLrefAlt" syntax="AsmEmitLrefAlt(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LREF_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitLrefPri" syntax="AsmEmitLrefPri(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LREF_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitLrefSAlt" syntax="AsmEmitLrefSAlt(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LREF_S_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitLrefSPri" syntax="AsmEmitLrefSPri(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AMX_Read"/>
			<referrer name="bernstein"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LREF_S_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitMoveAlt" syntax="AsmEmitMoveAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_MOVE_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitMovePri" syntax="AsmEmitMovePri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_MOVE_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitMovs" syntax="AsmEmitMovs(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_MOVS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitNeg" syntax="AsmEmitNeg(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_NEG"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitNeq" syntax="AsmEmitNeq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_NEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitNop" syntax="AsmEmitNop(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="AMX_Read"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_NOP"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitNot" syntax="AsmEmitNot(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_NOT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitOpcode" syntax="AsmEmitOpcode(ctx[], opcode)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="AsmEmitInstruction"/>
			<referrer name="AsmEmitJumpLabelInstruction"/>
			<dependency name="ASM_ERROR_OPCODE"/>
			<dependency name="AsmEmitCell"/>
			<dependency name="AsmRaiseError"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="RelocateOpcode"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitOperand" syntax="AsmEmitOperand(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="AsmEmitInstruction"/>
			<dependency name="AsmEmitCell"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitOr" syntax="AsmEmitOr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_OR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPadding" syntax="AsmEmitPadding(ctx[], op)">
			<stacksize value="7"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_buffer_size"/>
			<dependency name="GetOpcodeInstructionParameters"/>
			<dependency name="IsOpcodeValid"/>
			<dependency name="OP_NOP"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="WriteAmxMemory"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="op">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPopAlt" syntax="AsmEmitPopAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="AMX_Read"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_POP_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPopArgs" syntax="AsmEmitPopArgs(ctx[], n)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitStack"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="n">
			</param>
		</member>
		<member name="M:AsmEmitPopPri" syntax="AsmEmitPopPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<referrer name="YVA2_CodeGenDeepCleanup"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_POP_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitProc" syntax="AsmEmitProc(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<referrer name="rawMemset"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PROC"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPush" syntax="AsmEmitPush(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitPushAdr" syntax="AsmEmitPushAdr(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH_ADR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitPushAlt" syntax="AsmEmitPushAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPushArg" syntax="AsmEmitPushArg(ctx[], n)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitPushS"/>
			<dependency name="AsmGetArgOffset"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="n">
			</param>
		</member>
		<member name="M:AsmEmitPushC" syntax="AsmEmitPushC(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AsmEmitPushNumArgs"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH_C"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitPushNumArgs" syntax="AsmEmitPushNumArgs(ctx[], n)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitPushC"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="n">
			</param>
		</member>
		<member name="M:AsmEmitPushPri" syntax="AsmEmitPushPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPushS" syntax="AsmEmitPushS(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AsmEmitPushArg"/>
			<referrer name="bernstein"/>
			<referrer name="YVA2_CodeGenPushVariable"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH_S"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitRet" syntax="AsmEmitRet(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_RET"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitRetn" syntax="AsmEmitRetn(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<referrer name="rawMemset"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_RETN"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSctrl" syntax="AsmEmitSctrl(ctx[], index)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SCTRL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:AsmEmitSdiv" syntax="AsmEmitSdiv(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SDIV"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSdivAlt" syntax="AsmEmitSdivAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SDIV_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSgeq" syntax="AsmEmitSgeq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSgrtr" syntax="AsmEmitSgrtr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitShl" syntax="AsmEmitShl(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitShlCAlt" syntax="AsmEmitShlCAlt(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHL_C_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitShlCPri" syntax="AsmEmitShlCPri(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="rawMemset"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHL_C_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitShr" syntax="AsmEmitShr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitShrCAlt" syntax="AsmEmitShrCAlt(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHR_C_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitShrCPri" syntax="AsmEmitShrCPri(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHR_C_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitSignAlt" syntax="AsmEmitSignAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SIGN_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSignPri" syntax="AsmEmitSignPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SIGN_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSleq" syntax="AsmEmitSleq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSless" syntax="AsmEmitSless(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSmul" syntax="AsmEmitSmul(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SMUL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSmulC" syntax="AsmEmitSmulC(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="bernstein"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SMUL_C"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitSrefAlt" syntax="AsmEmitSrefAlt(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SREF_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitSrefPri" syntax="AsmEmitSrefPri(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SREF_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitSrefSAlt" syntax="AsmEmitSrefSAlt(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SREF_S_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitSrefSPri" syntax="AsmEmitSrefSPri(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SREF_S_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitSshr" syntax="AsmEmitSshr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SSHR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitStack" syntax="AsmEmitStack(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AsmEmitPopArgs"/>
			<referrer name="bernstein"/>
			<referrer name="YVA2_CodeGenDeepCleanup"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STACK"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitStorAlt" syntax="AsmEmitStorAlt(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STOR_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitStorI" syntax="AsmEmitStorI(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STOR_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitStorPri" syntax="AsmEmitStorPri(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="rawMemset"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STOR_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitStorSAlt" syntax="AsmEmitStorSAlt(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STOR_S_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitStorSPri" syntax="AsmEmitStorSPri(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STOR_S_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitStrbI" syntax="AsmEmitStrbI(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STRB_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitSub" syntax="AsmEmitSub(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SUB"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSubAlt" syntax="AsmEmitSubAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SUB_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSwapAlt" syntax="AsmEmitSwapAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SWAP_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSwapPri" syntax="AsmEmitSwapPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SWAP_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSysreq" syntax="AsmEmitSysreq(ctx[], name[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitSysreqC"/>
			<dependency name="GetNativeIndexFromName"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSysreqC" syntax="AsmEmitSysreqC(ctx[], index)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AsmEmitSysreq"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SYSREQ_C"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:AsmEmitSysreqD" syntax="AsmEmitSysreqD(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SYSREQ_D"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitSysreqPri" syntax="AsmEmitSysreqPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SYSREQ_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitUdiv" syntax="AsmEmitUdiv(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_UDIV"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitUdivAlt" syntax="AsmEmitUdivAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_UDIV_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitUmul" syntax="AsmEmitUmul(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_UMUL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitXchg" syntax="AsmEmitXchg(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="bernstein"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_XCHG"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitXor" syntax="AsmEmitXor(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_XOR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitZero" syntax="AsmEmitZero(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ZERO"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitZeroAlt" syntax="AsmEmitZeroAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ZERO_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitZeroPri" syntax="AsmEmitZeroPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ZERO_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitZeroS" syntax="AsmEmitZeroS(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ZERO_S"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmFindLabelIndex" syntax="AsmFindLabelIndex(ctx[], hash)">
			<stacksize value="2"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="AsmEmitJumpStringize"/>
			<dependency name="AsmContext_label_names"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="hash">
			</param>
		</member>
		<member name="M:AsmGetArgOffset" syntax="AsmGetArgOffset(n)">
			<stacksize value="1"/>
			<referrer name="AsmEmitPushArg"/>
			<dependency name="ASM_ARGUMENTS_OFFSET"/>
			<param name="n">
			</param>
		</member>
		<member name="M:AsmGetBufferSize" syntax="AsmGetBufferSize(ctx[])">
			<stacksize value="1"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_buffer_size"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmGetCode" syntax="AsmGetCode(ctx[])">
			<stacksize value="21"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="GetAmxHeader"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmGetCodeSize" syntax="AsmGetCodeSize(ctx[])">
			<stacksize value="1"/>
			<dependency name="AsmContext_buffer_offset"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmGetError" syntax="AsmGetError(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="1"/>
			<dependency name="AsmContext_error"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmGetErrorHandler" syntax="AsmGetErrorHandler(ctx[])">
			<stacksize value="1"/>
			<dependency name="AsmContext_error_handler"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmGetJumpAddressFromOffset" syntax="AsmGetJumpAddressFromOffset(ctx[], offset)">
			<stacksize value="22"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="AsmEmitJumpInstruction"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmGetPreviousWriteOffset" syntax="AsmGetPreviousWriteOffset()">
			<stacksize value="1"/>
			<dependency name="gPreviousWriteOffset"/>
		</member>
		<member name="M:AsmHashLabel" syntax="AsmHashLabel(label[])">
			<stacksize value="4"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="AsmEmitJumpStringize"/>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmInit" syntax="AsmInit(ctx[], buffer[], size)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="ref"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="buffer">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:AsmInitPtr" syntax="AsmInitPtr(ctx[], buffer, size)">
			<tagname value="AsmError"/>
			<stacksize value="2"/>
			<referrer name="AsmInit"/>
			<referrer name="CodeScanGetFunctionAsm"/>
			<referrer name="CodeScanGetMatchAsm"/>
			<referrer name="AMX_Read"/>
			<referrer name="bernstein"/>
			<referrer name="rawMemset"/>
			<referrer name="CGen_UseCodeSpace"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_buffer_size"/>
			<dependency name="AsmContext_error_handler"/>
			<dependency name="AsmContext_label_names"/>
			<dependency name="AsmContext_labels"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="buffer">
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:AsmRaiseError" syntax="AsmRaiseError(ctx[], error)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AsmEmitCell"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="AsmEmitJumpStringize"/>
			<referrer name="AsmEmitOpcode"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_error_handler"/>
			<dependency name="AsmSetError"/>
			<dependency name="CallFunction"/>
			<dependency name="ref"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="error">
				<paraminfo>AsmError </paraminfo>
			</param>
		</member>
		<member name="M:AsmSetError" syntax="AsmSetError(ctx[], error)">
			<stacksize value="1"/>
			<referrer name="AsmRaiseError"/>
			<referrer name="AsmClearError"/>
			<dependency name="AsmContext_error"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="error">
				<paraminfo>AsmError </paraminfo>
			</param>
		</member>
		<member name="M:AsmSetErrorHandler" syntax="AsmSetErrorHandler(ctx[], error_handler)">
			<tagname value="AsmError"/>
			<stacksize value="1"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_error_handler"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="error_handler">
			</param>
		</member>
		<member name="M:AsmSetErrorHandlerName" syntax="AsmSetErrorHandlerName(ctx[], error_handler[])">
			<tagname value="AsmError"/>
			<stacksize value="4"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_error_handler"/>
			<dependency name="GetPublicAddressFromName"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="error_handler">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Bit_Display" syntax="Bit_Display(array[], size)">
			<stacksize value="155"/>
			<dependency name="Bit_Display"/>
			<dependency name="Cell_ReverseBits"/>
			<dependency name="format"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Bit_GetCount" syntax="Bit_GetCount(array[], size)">
			<stacksize value="6"/>
			<dependency name="Cell_CountBits"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
				Array to count.
			</param>
			<param name="size">
				Size of array.
			</param>
			    <returns>  Number of 1s in the array.  </returns>  <remarks>  Code from:  <a href="http://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel" />  native Bit_Count(BitArray:array&lt;&gt;, size = sizeof (array));  </remarks> 
		</member>
		<member name="M:Bit_Set" syntax="Bit_Set(array[], slot, set)">
			<stacksize value="1"/>
			<referrer name="Group_SetCommandNew"/>
			<dependency name="cellbits"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
				Array of bits.
			</param>
			<param name="slot">
				Bit slot.
			</param>
			<param name="set">
				<paraminfo>bool </paraminfo>
				State to set the slot to.
			</param>
			      <param name="size">Size of array.</param> 
		</member>
		<member name="M:Bit_SetAll" syntax="Bit_SetAll(array[], set, size)">
			<stacksize value="6"/>
			<dependency name="memset"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
				Array to set all values of.
			</param>
			<param name="set">
				<paraminfo>bool </paraminfo>
				Wether to set them all 0 or 1.
			</param>
			<param name="size">
				Size of array.
			</param>
			     
		</member>
		<member name="M:CGen_AddCodeSpace" syntax="CGen_AddCodeSpace(num)">
			<stacksize value="4"/>
			<referrer name="Hooks_GenerateCode"/>
			<dependency name="Debug_Print0"/>
			<dependency name="YSI_g_sCodeSpace"/>
			<param name="num">
			</param>
		</member>
		<member name="M:CGen_GetAddr" syntax="CGen_GetAddr(func[])">
			<stacksize value="6"/>
			<referrer name="CGen_SetupCodeSpace"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_Read"/>
			<dependency name="funcidx"/>
			<param name="func">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:CGen_GetCodeSpace" syntax="CGen_GetCodeSpace()">
			<stacksize value="3"/>
			<referrer name="Hooks_GenerateCode"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="CGen_SetupCodeSpace"/>
			<dependency name="YSI_g_sCodeSpace"/>
		</member>
		<member name="M:CGen_SetupCodeSpace" syntax="CGen_SetupCodeSpace()">
			<stacksize value="5"/>
			<referrer name="CGen_UseCodeSpace"/>
			<referrer name="CGen_GetCodeSpace"/>
			<dependency name="AMX_Write"/>
			<dependency name="CGen_GetAddr"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_RETN"/>
			<dependency name="OP_ZERO_PRI"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="YSI_g_sCodeEnd"/>
			<dependency name="YSI_g_sCodeSpace"/>
		</member>
		<member name="M:CGen_UseCodeSpace" syntax="CGen_UseCodeSpace(ctx[])">
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="CGen_SetupCodeSpace"/>
			<dependency name="YSI_g_sCodeEnd"/>
			<dependency name="YSI_g_sCodeSpace"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:Call" syntax="Call(address, auto_pop)">
			<stacksize value="5"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="address">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:CallFunction" syntax="CallFunction(address, ...)">
			<stacksize value="5"/>
			<referrer name="AsmRaiseError"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<referrer name="VA_OnScriptInit"/>
			<param name="address">
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:CallLocalFunction" syntax="CallLocalFunction(function[], format[], ...)">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="HookChain_OnScriptInit"/>
			<referrer name="ScriptInit_OnScriptExit"/>
			<referrer name="@_"/>
			<referrer name="@a"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:CallN" syntax="CallN(address, args_to_push, auto_pop)">
			<stacksize value="6"/>
			<dependency name="cellmin"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="address">
			</param>
			<param name="args_to_push">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:CallNative" syntax="CallNative(index, ...)">
			<stacksize value="8"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<param name="index">
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:CallNativeByAddress" syntax="CallNativeByAddress(address, ...)">
			<stacksize value="8"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<param name="address">
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:CallRemoteFunction" syntax="CallRemoteFunction(function[], format[], ...)">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="HookChain_OnScriptInit"/>
			<referrer name="ScriptInit_OnScriptExit"/>
			<referrer name="@_"/>
			<referrer name="_@_y_distribute_@_"/>
			<referrer name="Distribute_Do"/>
			<referrer name="Distribute_So"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="@a"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:Cell_CompressRight" syntax="Cell_CompressRight(x, m)">
			<stacksize value="12"/>
			<dependency name="Cell_CompressRightPrecomputed"/>
			<dependency name="Cell_PrecomputeMaskPermutation"/>
			<param name="x">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				The number to compress.
			</param>
			<param name="m">
				The mask for which bits to compress.
			</param>
			<summary>  Cell_CompressRight(GLOBAL_TAG_TYPES:x, m);  </summary>      <returns>  Selected bits from "x", shifted to be LSBs.  </returns>  <remarks>  Doesn't require precomputation.  </remarks> 
		</member>
		<member name="M:Cell_CompressRightPrecomputed" syntax="Cell_CompressRightPrecomputed(x, m, masks[])">
			<stacksize value="2"/>
			<referrer name="Cell_CompressRight"/>
			<param name="x">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				The number to compress.
			</param>
			<param name="m">
				The mask for which bits to compress.
			</param>
			<param name="masks">
				<paraminfo> [5] </paraminfo>
				Precomputed constants for the compression.
			</param>
			<summary>  Cell_CompressRightPrecomputed(GLOBAL_TAG_TYPES:x, m, masks[5]);  </summary>        <returns>  Selected bits from "x", shifted to be LSBs.  </returns>  <remarks>  Very briefly, do "x &amp; m", to select certain bits, then shift those bits  by various amounts so that they are consecutive:  x = 0b110011  m = 0b011010  x &amp; m = 0b010010  From here, because the mask was three bits we know we want just those three  bits in the LSBs, so the answer becomes:  0b000101  Just read this question, it has a diagram:  <a href="http://stackoverflow.com/questions/28282869/shift-masked-bits-to-the-lsb" />  </remarks> 
		</member>
		<member name="M:Cell_CountBits" syntax="Cell_CountBits(data)">
			<stacksize value="1"/>
			<referrer name="Bit_GetCount"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_CountBits(number);  </summary>  <param name="number">The number to get the number of 1s in.</param>  <returns>  The number of 1s (set bits) in the input.  </returns>  <remarks>  1)  Example: 0  Returns: 0  2)  Example: 1  Returns: 1  3)  Example: 0x01010101  Returns: 4  I rewrote this in assembly just to see if I could pretty much.  I also  rewrote the lookup version in assembly.  In theory it should be faster, but  the marshalling of data was a little awkward.  </remarks> 
		</member>
		<member name="M:Cell_ExpandLeft" syntax="Cell_ExpandLeft(x, m)">
			<stacksize value="12"/>
			<dependency name="Cell_ExpandLeftPrecomputed"/>
			<dependency name="Cell_PrecomputeMaskPermutation"/>
			<param name="x">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				The number to expand.
			</param>
			<param name="m">
				The mask for which bits to expand to.
			</param>
			<summary>  Cell_ExpandLeft(GLOBAL_TAG_TYPES:x, m)  </summary>      <returns>  LSBs from "x", shifted to selected bit positions.  </returns>  <remarks>  Doesn't require precomputation.  </remarks> 
		</member>
		<member name="M:Cell_ExpandLeftPrecomputed" syntax="Cell_ExpandLeftPrecomputed(x, m, masks[])">
			<stacksize value="2"/>
			<referrer name="Cell_ExpandLeft"/>
			<param name="x">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				The number to expand.
			</param>
			<param name="m">
				The mask for which bits to expand to.
			</param>
			<param name="masks">
				<paraminfo> [5] </paraminfo>
				Precomputed constants for the expansion.
			</param>
			<summary>  Cell_ExpandLeftPrecomputed(GLOBAL_TAG_TYPES:x, m, masks[5])  </summary>        <returns>  LSBs from "x", shifted to selected bit positions.  </returns>  <remarks>  The reverse of "Cell_CompressRightPrecomputed".  Doesn't return exactly the  original number before a compression, just the original number ANDed with  the mask "m".  </remarks> 
		</member>
		<member name="M:Cell_GetLowestBit" syntax="Cell_GetLowestBit(data)">
			<stacksize value="1"/>
			<referrer name="Iter_Func@Bits"/>
			<referrer name="Iter_Func@Blanks"/>
			<referrer name="Iter_Func@PA"/>
			<referrer name="Command_ReProcess"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_GetLowestBit(number);  </summary>  <param name="number">The number to get the lowest set bit of.</param>  <returns>  The integer position of the lowest set bit.  </returns>  <remarks>  1)  Example: 0b00000000000000000000000000000001  Returns: 0  2)  Example: 0b00000000000000000000000000001000  Returns: 3  3)  Example: 0b00010001100011000011100010001000  Returns: 3  NOTE: This function returns "0" for both numbers with the "1" bit set AND  the number "0", which has NO bits set.  Check that the number is valid  before passing it to this function.  See: <a href="http://supertech.csail.mit.edu/papers/debruijn.pdf" />  </remarks> 
		</member>
		<member name="M:Cell_GetLowestBitEx" syntax="Cell_GetLowestBitEx(data)">
			<stacksize value="1"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_GetLowestBitEx(number);  </summary>  <param name="number">The number to get the lowest set bit of PLUS ONE.</param>  <returns>  The integer position of the lowest set bit PLUS ONE.  </returns>  <remarks>  This function is identical to "Cell_GetLowestBit", but gives different  results for 0 and non-zero numbers.  The examples below all have a result  one higher than the "Cell_GetLowestBit" function.  1)  Example: 0b00000000000000000000000000000001  Returns: 1  2)  Example: 0b00000000000000000000000000001000  Returns: 4  3)  Example: 0b00010001100011000011100010001000  Returns: 4  4)  Example: 0  Returns: 0  See: <a href="http://supertech.csail.mit.edu/papers/debruijn.pdf" />  </remarks> 
		</member>
		<member name="M:Cell_GetLowestComponent" syntax="Cell_GetLowestComponent(data)">
			<stacksize value="1"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_GetLowestComponent(number);  </summary>  <param name="number">The number to get the number of 1s in.</param>  <returns>  The lowest set bit.  </returns>  <remarks>  Similar to Cell_GetLowestBit, but returns the bit, not the position of the  bit.  1)  Example: 0b00000000000000000000000000000001  Returns: 0b00000000000000000000000000000001  2)  Example: 0b00000000000000000000000000001000  Returns: 0b00000000000000000000000000001000  3)  Example: 0b00010001100011000011100010001000  Returns: 0b00000000000000000000000000001000  </remarks> 
		</member>
		<member name="M:Cell_PrecomputeMaskPermutation" syntax="Cell_PrecomputeMaskPermutation(m)">
			<stacksize value="10"/>
			<referrer name="Cell_CompressRight"/>
			<referrer name="Cell_ExpandLeft"/>
			<dependency name="Cell_PrecomputeMaskPermutation"/>
			<param name="m">
				The mask.
			</param>
			<summary>  Cell_PrecomputeMaskPermutation(m)  </summary>    <returns>  Five precomputed constants to help expand or contract this mask.  </returns>  <remarks>  The full maths for generalised expansion and contraction is quite complex;  however, much of the inner loop relies only on the mask and not on the value  being manipulated.  Given this we can do a lot of work in advance, say  outside a loop, to avoid repeated calculations.  </remarks> 
		</member>
		<member name="M:Cell_ReverseBits" syntax="Cell_ReverseBits(data)">
			<stacksize value="1"/>
			<referrer name="Bit_Display"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_ReverseBits(number);  </summary>  <param name="number">The number to manipulate.</param>  <returns>  All the bits in the input reversed.  </returns>  <remarks>  1)  Example: 0b11110000000000000000000000000000  Becomes: 0b00000000000000000000000000001111  2)  Example: 0b10110011100011110000111110000010  Becomes: 0b01000001111100001111000111001101  3)  Example: 0b01010101010101010101010101010101  Becomes: 0b10101010101010101010101010101010  </remarks> 
		</member>
		<member name="M:Cell_ReverseBytes" syntax="Cell_ReverseBytes(data)">
			<stacksize value="1"/>
			<referrer name="Hooks_CompareNextCell"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_ReverseBytes(number);  </summary>  <param name="number">The number to manipulate.</param>  <returns>  All the bytes in the input reversed.  </returns>  <remarks>  1)  Example: 0x12345678  Becomes: 0x78563412  2)  Example: 0x01020304  Becomes: 0x04030201  3)  Example: 0xFF00FF00  Becomes: 0x00FF00FF  </remarks> 
		</member>
		<member name="M:Cell_ReverseNibbles" syntax="Cell_ReverseNibbles(data)">
			<stacksize value="1"/>
			<param name="data">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_ReverseNibbles(number);  </summary>  <param name="number">The number to manipulate.</param>  <returns>  All the nibbles (4-bit chunks) in the input reversed.  </returns>  <remarks>  1)  Example: 0x12345678  Becomes: 0x87654321  2)  Example: 0x010F0703  Becomes: 0x3070F010  3)  Example: 0xF0F0F0F0  Becomes: 0x0F0F0F0F  </remarks> 
		</member>
		<member name="M:CodeScanAddJumpTarget" syntax="CodeScanAddJumpTarget(cip, stk, hea, jumpTargets[], num)">
			<stacksize value="4"/>
			<referrer name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_jump_heap"/>
			<dependency name="CodeScanner_jump_stack"/>
			<dependency name="CodeScanner_jump_switch"/>
			<dependency name="CodeScanner_jump_target"/>
			<dependency name="CodeScanner_minn"/>
			<dependency name="min"/>
			<param name="cip">
			</param>
			<param name="stk">
			</param>
			<param name="hea">
			</param>
			<param name="jumpTargets">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:CodeScanAddMatcher" syntax="CodeScanAddMatcher(scanner[], searcher[])">
			<stacksize value="4"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="CodeScanner_first"/>
			<dependency name="ref"/>
			<param name="scanner">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="searcher">
				<paraminfo> [171] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanAddSwitchTarget" syntax="CodeScanAddSwitchTarget(dctx[], stk, hea, jumpTargets[], num)">
			<stacksize value="6"/>
			<referrer name="CodeScanStepInternal"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="CodeScanner_jump_heap"/>
			<dependency name="CodeScanner_jump_stack"/>
			<dependency name="CodeScanner_jump_switch"/>
			<dependency name="CodeScanner_jump_target"/>
			<dependency name="CodeScanner_minn"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="cellbits"/>
			<dependency name="gBase"/>
			<dependency name="gHdr"/>
			<dependency name="gOP_CASETBL"/>
			<dependency name="min"/>
			<param name="dctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="stk">
			</param>
			<param name="hea">
			</param>
			<param name="jumpTargets">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:CodeScanCall" syntax="CodeScanCall(cs[], csState[])">
			<stacksize value="3"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<dependency name="CodeScanMatcher_flags"/>
			<dependency name="CodeScanMatcher_func"/>
			<dependency name="CodeScanMatcher_user_data"/>
			<param name="cs">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="csState">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanCheck" syntax="CodeScanCheck(op, dctx[], cs[], fctx[], &amp;next)">
			<tagname value="bool"/>
			<stacksize value="12"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="CodeScanMatch_hole_count"/>
			<dependency name="CodeScanMatch_holes"/>
			<dependency name="CodeScanMatch_size"/>
			<dependency name="CodeScanMatcher_code"/>
			<dependency name="CodeScanMatcher_flags"/>
			<dependency name="CodeScanMatcher_holeidx"/>
			<dependency name="CodeScanMatcher_holes"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="CodeScanMatcher_offset"/>
			<dependency name="CodeScanMatcher_start"/>
			<dependency name="DisasmGetCurIp"/>
			<dependency name="DisasmGetNextIp"/>
			<dependency name="DisasmGetNumOperands"/>
			<dependency name="DisasmGetOperandReloc"/>
			<dependency name="OP_BOUNDS"/>
			<dependency name="OP_BREAK"/>
			<dependency name="OP_HALT"/>
			<dependency name="OP_NOP"/>
			<dependency name="cellbits"/>
			<dependency name="false"/>
			<dependency name="memcpy"/>
			<dependency name="true"/>
			<param name="op">
				<paraminfo>Opcode </paraminfo>
			</param>
			<param name="dctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="cs">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="fctx">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="next">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanCheckJumpTarget" syntax="CodeScanCheckJumpTarget(cip, deloc, &amp;stk, &amp;hea, jumpTargets[], num)">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<referrer name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_jump_heap"/>
			<dependency name="CodeScanner_jump_stack"/>
			<dependency name="CodeScanner_jump_switch"/>
			<dependency name="CodeScanner_jump_target"/>
			<dependency name="CodeScanner_minn"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="cellbits"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="cip">
			</param>
			<param name="deloc">
			</param>
			<param name="stk">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="hea">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="jumpTargets">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:CodeScanClone" syntax="CodeScanClone(dest[], src[])">
			<stacksize value="1"/>
			<dependency name="CodeScanner_first"/>
			<param name="dest">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="src">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanDeref" syntax="CodeScanDeref(v)">
			<stacksize value="1"/>
			<referrer name="CodeScanFindOneFastPattern2"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<dependency name="CodeScanDeref"/>
			<dependency name="CodeScanMatcher"/>
			<param name="v">
			</param>
		</member>
		<member name="M:CodeScanFindOneFastPattern2" syntax="CodeScanFindOneFastPattern2(matcher[], &amp;addr)">
			<tagname value="bool"/>
			<stacksize value="180"/>
			<referrer name="CodeScanRunFast"/>
			<dependency name="CodeScanDeref"/>
			<dependency name="CodeScanFindOneFastPattern3"/>
			<dependency name="CodeScanMatcher_code"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="OP_CALL"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="matcher">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="addr">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanFindOneFastPattern3" syntax="CodeScanFindOneFastPattern3(matcher[], addr, &amp;cur)">
			<tagname value="bool"/>
			<stacksize value="3"/>
			<referrer name="CodeScanFindOneFastPattern2"/>
			<dependency name="CodeScanMatcher_code"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="OP_CALL"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="matcher">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="addr">
			</param>
			<param name="cur">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetFuncName" syntax="CodeScanGetFuncName(addr, name[])">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<referrer name="CodeScanGetMatchType"/>
			<dependency name="GetPublicIndexFromAddress"/>
			<dependency name="GetPublicNameFromIndex"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="addr">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetFunctionAsm" syntax="CodeScanGetFunctionAsm(csm[], ctx[], offset)">
			<stacksize value="6"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="cellmax"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:CodeScanGetFunctionDisasm" syntax="CodeScanGetFunctionDisasm(csm[], ctx[], offset)">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:CodeScanGetFunctionScanner" syntax="CodeScanGetFunctionScanner(csm[], ret[], ctx[])">
			<stacksize value="4"/>
			<referrer name="CodeScanGetMatchScanner"/>
			<dependency name="CodeScanInit"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="CodeScanMatch_type"/>
			<dependency name="CodeScanner_state"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="ret">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetHoleCount" syntax="CodeScanGetHoleCount(csm[])">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_hole_count"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchAddress" syntax="CodeScanGetMatchAddress(csm[])">
			<stacksize value="1"/>
			<referrer name="YVA2_FoundPush"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="gDat"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchAddressData" syntax="CodeScanGetMatchAddressData(csm[])">
			<stacksize value="1"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="CodeScanMatch_cip"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchAsm" syntax="CodeScanGetMatchAsm(csm[], ctx[], offset)">
			<stacksize value="6"/>
			<referrer name="YVA2_FoundPush"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="cellmax"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:CodeScanGetMatchDisasm" syntax="CodeScanGetMatchDisasm(csm[], ctx[], offset)">
			<stacksize value="1"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:CodeScanGetMatchFunc" syntax="CodeScanGetMatchFunc(csm[])">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="gDat"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchFuncData" syntax="CodeScanGetMatchFuncData(csm[])">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_func"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchHeap" syntax="CodeScanGetMatchHeap(csm[])">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_heap"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchHole" syntax="CodeScanGetMatchHole(csm[], idx)">
			<stacksize value="1"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<dependency name="CodeScanMatch_holes"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:CodeScanGetMatchLength" syntax="CodeScanGetMatchLength(csm[])">
			<stacksize value="1"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<dependency name="CodeScanMatch_size"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchName" syntax="CodeScanGetMatchName(csm[], name[])">
			<stacksize value="5"/>
			<dependency name="CodeScanGetMatchType"/>
			<dependency name="CodeScanMatch_name"/>
			<dependency name="CodeScanMatch_type"/>
			<dependency name="strcat"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchScanner" syntax="CodeScanGetMatchScanner(csm[], ret[], ctx[], accurate)">
			<stacksize value="7"/>
			<dependency name="CodeScanGetFunctionScanner"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_param"/>
			<dependency name="CodeScanner_state"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="ret">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="accurate">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchStack" syntax="CodeScanGetMatchStack(csm[])">
			<stacksize value="1"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<dependency name="CodeScanMatch_stack"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchType" syntax="CodeScanGetMatchType(csm[])">
			<stacksize value="5"/>
			<referrer name="CodeScanGetMatchName"/>
			<dependency name="CodeScanGetFuncName"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="CodeScanMatch_name"/>
			<dependency name="CodeScanMatch_type"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanInit" syntax="CodeScanInit(scanner[])">
			<stacksize value="5"/>
			<referrer name="CodeScanGetFunctionScanner"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="CodeScanMatch_heap"/>
			<dependency name="CodeScanMatch_name"/>
			<dependency name="CodeScanMatch_params"/>
			<dependency name="CodeScanMatch_stack"/>
			<dependency name="CodeScanMatch_type"/>
			<dependency name="CodeScanResetJumpTargets"/>
			<dependency name="CodeScanner_first"/>
			<dependency name="CodeScanner_param"/>
			<dependency name="CodeScanner_state"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_NOP"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<dependency name="gBase"/>
			<dependency name="gCodBase"/>
			<dependency name="gDat"/>
			<dependency name="gHdr"/>
			<dependency name="gOP_CASETBL"/>
			<dependency name="gOP_NOP"/>
			<param name="scanner">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanMatcherData" syntax="CodeScanMatcherData(searcher[], val)">
			<stacksize value="1"/>
			<dependency name="CodeScanMatcher_flags"/>
			<dependency name="CodeScanMatcher_user_data"/>
			<param name="searcher">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="val">
			</param>
		</member>
		<member name="M:CodeScanMatcherInit_" syntax="CodeScanMatcherInit_(searcher[], address, flags)">
			<stacksize value="5"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="CodeScanMatcher_flags"/>
			<dependency name="CodeScanMatcher_func"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="CodeScanMatcher_user_data"/>
			<dependency name="CodeScanReset"/>
			<param name="searcher">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="address">
			</param>
			<param name="flags">
			</param>
		</member>
		<member name="M:CodeScanMatcherPattern_" syntax="CodeScanMatcherPattern_(searcher[], ...)">
			<stacksize value="10"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="CodeScanMatcher_code"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="GetOpcodeInstructionParameters"/>
			<dependency name="getarg"/>
			<dependency name="numargs"/>
			<param name="searcher">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Opcode,Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanNOPMatch" syntax="CodeScanNOPMatch(csm[])">
			<stacksize value="3"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="CodeScanMatch_size"/>
			<dependency name="cellbits"/>
			<dependency name="gOP_NOP"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanReset" syntax="CodeScanReset(cs[], &amp;next)">
			<stacksize value="1"/>
			<referrer name="CodeScanMatcherInit_"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<dependency name="CodeScanMatcher_func"/>
			<dependency name="CodeScanMatcher_holeidx"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="CodeScanMatcher_offset"/>
			<param name="cs">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="next">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanResetJumpTargets" syntax="CodeScanResetJumpTargets(jumpTargets[], num)">
			<stacksize value="1"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanInit"/>
			<dependency name="CodeScanner_jump_target"/>
			<dependency name="CodeScanner_minn"/>
			<param name="jumpTargets">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:CodeScanRun" syntax="CodeScanRun(csState[])">
			<tagname value="bool"/>
			<stacksize value="188"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="CodeScanCall"/>
			<dependency name="CodeScanCheck"/>
			<dependency name="CodeScanDeref"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="CodeScanReset"/>
			<dependency name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_first"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmInit"/>
			<dependency name="cellmin"/>
			<dependency name="gDat"/>
			<dependency name="true"/>
			<param name="csState">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanRunFast" syntax="CodeScanRunFast(csState[], searchFuncAddr)">
			<tagname value="bool"/>
			<stacksize value="191"/>
			<dependency name="CodeScanCall"/>
			<dependency name="CodeScanCheck"/>
			<dependency name="CodeScanDeref"/>
			<dependency name="CodeScanFindOneFastPattern2"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="CodeScanReset"/>
			<dependency name="CodeScanRun"/>
			<dependency name="CodeScanRunFastPrescan"/>
			<dependency name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_first"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmInit"/>
			<dependency name="OP_PROC"/>
			<dependency name="cellmin"/>
			<dependency name="false"/>
			<dependency name="printf"/>
			<dependency name="true"/>
			<param name="csState">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="searchFuncAddr">
			</param>
		</member>
		<member name="M:CodeScanRunFastPrescan" syntax="CodeScanRunFastPrescan(&amp;proc, &amp;nextaddr, searchFuncAddr)">
			<stacksize value="6"/>
			<referrer name="CodeScanRunFast"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_PROC"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="UnrelocateOpcode"/>
			<dependency name="false"/>
			<dependency name="gCodBase"/>
			<dependency name="gOpArgCount"/>
			<dependency name="true"/>
			<param name="proc">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="nextaddr">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="searchFuncAddr">
			</param>
		</member>
		<member name="M:CodeScanStep" syntax="CodeScanStep(dctx[], csState[])">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<dependency name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_param"/>
			<dependency name="CodeScanner_state"/>
			<param name="dctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="csState">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanStepInternal" syntax="CodeScanStepInternal(dctx[], csState[], &amp;parseState, &amp;parseParam)">
			<tagname value="bool"/>
			<stacksize value="13"/>
			<referrer name="CodeScanStep"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<referrer name="CodeScanGetMatchScanner"/>
			<dependency name="CodeScanAddJumpTarget"/>
			<dependency name="CodeScanAddSwitchTarget"/>
			<dependency name="CodeScanCheckJumpTarget"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="CodeScanMatch_heap"/>
			<dependency name="CodeScanMatch_stack"/>
			<dependency name="CodeScanMatch_type"/>
			<dependency name="CodeScanResetJumpTargets"/>
			<dependency name="DISASM_DONE"/>
			<dependency name="DISASM_NOP"/>
			<dependency name="DISASM_OK"/>
			<dependency name="DisasmGetCurIp"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmNext"/>
			<dependency name="OP_ADD_C"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CALL_PRI"/>
			<dependency name="OP_HALT"/>
			<dependency name="OP_HEAP"/>
			<dependency name="OP_JEQ"/>
			<dependency name="OP_JGEQ"/>
			<dependency name="OP_JGRTR"/>
			<dependency name="OP_JLEQ"/>
			<dependency name="OP_JLESS"/>
			<dependency name="OP_JNEQ"/>
			<dependency name="OP_JNZ"/>
			<dependency name="OP_JREL"/>
			<dependency name="OP_JSGEQ"/>
			<dependency name="OP_JSGRTR"/>
			<dependency name="OP_JSLEQ"/>
			<dependency name="OP_JSLESS"/>
			<dependency name="OP_JUMP"/>
			<dependency name="OP_JZER"/>
			<dependency name="OP_LCTRL"/>
			<dependency name="OP_LOAD_PRI"/>
			<dependency name="OP_POP_ALT"/>
			<dependency name="OP_POP_PRI"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_PUSH"/>
			<dependency name="OP_PUSH_ADR"/>
			<dependency name="OP_PUSH_ALT"/>
			<dependency name="OP_PUSH_C"/>
			<dependency name="OP_PUSH_PRI"/>
			<dependency name="OP_PUSH_R"/>
			<dependency name="OP_PUSH_S"/>
			<dependency name="OP_SCTRL"/>
			<dependency name="OP_STACK"/>
			<dependency name="OP_SWITCH"/>
			<dependency name="cellbits"/>
			<dependency name="cellmin"/>
			<dependency name="false"/>
			<dependency name="gBase"/>
			<dependency name="true"/>
			<param name="dctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="csState">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="parseState">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="parseParam">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:Command_Add" syntax="Command_Add(cmd[], ptr)">
			<stacksize value="8"/>
			<automaton name="@_"/>
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="Command_Add@"/>
			<dependency name="Command_Find"/>
			<dependency name="Command_GetEmptySlot"/>
			<dependency name="Command_InitialiseFromGroups"/>
			<dependency name="Debug_Print0"/>
			<dependency name="E_COMMAND_POINTER"/>
			<dependency name="E_COMMAND_USERS"/>
			<dependency name="HashMap_Add"/>
			<dependency name="I@"/>
			<dependency name="PA_Init"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="Y@"/>
			<dependency name="YSI_g_sCommandMap"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sHighestID"/>
			<dependency name="YSI_g_sMasterData"/>
			<dependency name="Z@"/>
			<dependency name="_@"/>
			<dependency name="cellmax"/>
			<dependency name="max"/>
			<dependency name="strpack"/>
			<dependency name="true"/>
			<param name="cmd">
				<paraminfo> [] </paraminfo>
				The command name to add.
			</param>
			<param name="ptr">
				The command's pointer.
			</param>
			    <param name="id">Where to store the command (default -1 = find).</param>  <returns>  The command's ID.  </returns>  <remarks>  This was an external API function, but there is no reason for it to be as it  is called for all found commands at mode start.  </remarks> 
		</member>
		<member name="M:Command_Add@" syntax="Command_Add@(cmd[], ptr)">
			<attribute name="public"/>
			<stacksize value="5"/>
			<automaton name="@_"/>
			<dependency name="Command_Add"/>
			<dependency name="X@"/>
			<param name="cmd">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="ptr">
			</param>
		</member>
		<member name="M:Command_AddAlt" syntax="Command_AddAlt(oidx, cmd[])">
			<stacksize value="9"/>
			<automaton name="@_"/>
			<referrer name="Command_AddAlt@"/>
			<referrer name="Command_AddAltNamed"/>
			<dependency name="Command_Find"/>
			<dependency name="Command_GetEmptySlot"/>
			<dependency name="Command_InitialiseFromGroups"/>
			<dependency name="Debug_Print0"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="E_COMMAND_POINTER"/>
			<dependency name="E_COMMAND_USERS"/>
			<dependency name="HashMap_Add"/>
			<dependency name="PA_Init"/>
			<dependency name="Puny_EncodeHash"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandMap"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sHighestID"/>
			<dependency name="YSI_g_sMasterData"/>
			<dependency name="cellmax"/>
			<dependency name="cellmin"/>
			<dependency name="max"/>
			<dependency name="strpack"/>
			<dependency name="true"/>
			<param name="oidx">
				The function this is an alternate to.
			</param>
			<param name="cmd">
				<paraminfo> [] </paraminfo>
				The new name.
			</param>
			    <returns>  The command's ID.  </returns> 
		</member>
		<member name="M:Command_AddAlt@" syntax="Command_AddAlt@(oidx, cmd[])">
			<attribute name="public"/>
			<stacksize value="5"/>
			<automaton name="@_"/>
			<dependency name="Command_AddAlt"/>
			<dependency name="X@"/>
			<param name="oidx">
			</param>
			<param name="cmd">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Command_AddAltNamed" syntax="Command_AddAltNamed(function[], altname[])">
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_AddAltNamed@"/>
			<dependency name="Command_AddAlt"/>
			<dependency name="Command_Find"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
				The function this is an alternate to.
			</param>
			<param name="altname">
				<paraminfo> [] </paraminfo>
				The new name.
			</param>
			    <remarks>  Add an alternate command for an existing command.  native Command_AddAltNamed(function[], altname[]);  </remarks> 
		</member>
		<member name="M:Command_AddAltNamed@" syntax="Command_AddAltNamed@(function[], altname[])">
			<attribute name="public"/>
			<stacksize value="5"/>
			<automaton name="@_"/>
			<dependency name="Command_AddAltNamed"/>
			<dependency name="X@"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="altname">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Command_DecOPCP" syntax="Command_DecOPCP()">
			<stacksize value="4"/>
			<automaton name="@_"/>
			<referrer name="@yH_OnScriptExit@004"/>
			<referrer name="Command_DecOPCP@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="e_COMM_FLAG_OPCP_ADD"/>
		</member>
		<member name="M:Command_DecOPCP@" syntax="Command_DecOPCP@()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="@_"/>
			<dependency name="Command_DecOPCP"/>
		</member>
		<member name="M:Command_DecOPCR" syntax="Command_DecOPCR()">
			<stacksize value="4"/>
			<automaton name="@_"/>
			<referrer name="@yH_OnScriptExit@004"/>
			<referrer name="Command_DecOPCR@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="e_COMM_FLAG_OPCR_ADD"/>
		</member>
		<member name="M:Command_DecOPCR@" syntax="Command_DecOPCR@()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="@_"/>
			<dependency name="Command_DecOPCR"/>
		</member>
		<member name="M:Command_Find" syntax="Command_Find(cmd[])">
			<stacksize value="8"/>
			<automaton name="@_"/>
			<referrer name="Command_GetID"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_GetPlayerNamed"/>
			<referrer name="Command_SetPlayerNamed"/>
			<referrer name="Command_Find@"/>
			<referrer name="Command_TouchNamed"/>
			<referrer name="Command_AddAltNamed"/>
			<referrer name="Command_RemoveNamed"/>
			<referrer name="Command_GetDisplayNamed"/>
			<referrer name="Command_Add"/>
			<dependency name="HashMap_Get"/>
			<dependency name="Puny_EncodeHash"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandMap"/>
			<param name="cmd">
				<paraminfo> [] </paraminfo>
				The command name to find.
			</param>
			  <returns>  The array slot of this command, or -1.  </returns> 
		</member>
		<member name="M:Command_Find@" syntax="Command_Find@(cmd[])">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_Find"/>
			<dependency name="X@"/>
			<param name="cmd">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Command_GetCurrent" syntax="Command_GetCurrent()">
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_GetCurrent@"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCurrentID"/>
			<returns>  The command currently being processed, or "COMMAND_NOT_FOUND".  </returns> 
		</member>
		<member name="M:Command_GetCurrent@" syntax="Command_GetCurrent@()">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_GetCurrent"/>
			<dependency name="X@"/>
		</member>
		<member name="M:Command_GetDeniedReturn" syntax="Command_GetDeniedReturn()">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_GetDeniedReturn@"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="e_COMMAND_FLAGS_DENIED"/>
		</member>
		<member name="M:Command_GetDeniedReturn@" syntax="Command_GetDeniedReturn@()">
			<tagname value="bool"/>
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_GetDeniedReturn"/>
			<dependency name="X@"/>
		</member>
		<member name="M:Command_GetDisconnectReturn" syntax="Command_GetDisconnectReturn()">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_GetDisconnectReturn@"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="e_COMMAND_FLAGS_NO_PLAYER"/>
		</member>
		<member name="M:Command_GetDisconnectReturn@" syntax="Command_GetDisconnectReturn@()">
			<tagname value="bool"/>
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_GetDisconnectReturn"/>
			<dependency name="X@"/>
		</member>
		<member name="M:Command_GetDisplay" syntax="Command_GetDisplay(funcid, playerid)">
			<stacksize value="6"/>
			<automaton name="@_"/>
			<referrer name="Command_GetDisplay@"/>
			<dependency name="Command_GetDisplay"/>
			<dependency name="F@"/>
			<dependency name="Q@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sReturnBuffer"/>
			<dependency name="_Command_GetDisplay"/>
			<param name="funcid">
			</param>
			<param name="playerid">
			</param>
			<param name="f">Command to get the real name of.</param>  <param name="p">Player to get the name for.</param>  <returns>  The name of a command for a single player.  </returns>  <remarks>  Abstracted because there's a crash when chain returning a string from a  foreign function (see "Command_GetDisplayNamed").  native Command_GetDisplay(funcid, playerid);  </remarks> 
		</member>
		<member name="M:Command_GetDisplay@" syntax="Command_GetDisplay@(funcid, playerid)">
			<attribute name="public"/>
			<stacksize value="150"/>
			<automaton name="@_"/>
			<dependency name="Command_GetDisplay"/>
			<dependency name="R@"/>
			<param name="funcid">
			</param>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Command_GetDisplayNamed" syntax="Command_GetDisplayNamed(func[], playerid)">
			<stacksize value="6"/>
			<automaton name="@_"/>
			<referrer name="Command_GetDisplayNamed@"/>
			<dependency name="Command_Find"/>
			<dependency name="Command_GetDisplayNamed"/>
			<dependency name="F@"/>
			<dependency name="Q@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sReturnBuffer"/>
			<dependency name="_Command_GetDisplay"/>
			<param name="func">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="playerid">
			</param>
			<param name="f">Command to get the real name of.</param>  <param name="p">Player to get the name for.</param>  <returns>  The name of a named function for one player.  </returns>  <remarks>  Remote function call for Command_GetDisplayNameNamed - avoids needing to  expose users to the master system's odd way of returning strings.  This is  the only part I've not yet fixed up to be nice and hidden.  native string:Command_GetDisplayNamed(string:funcid[], playerid);  </remarks> 
		</member>
		<member name="M:Command_GetDisplayNamed@" syntax="Command_GetDisplayNamed@(func[], playerid)">
			<attribute name="public"/>
			<stacksize value="150"/>
			<automaton name="@_"/>
			<dependency name="Command_GetDisplayNamed"/>
			<dependency name="R@"/>
			<param name="func">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Command_GetEmptySlot" syntax="Command_GetEmptySlot()">
			<stacksize value="2"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_Add"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="YSI_g_sCommands"/>
			<returns>  The first available slot in "YSI_g_sCommands".  </returns> 
		</member>
		<member name="M:Command_GetID" syntax="Command_GetID(function[])">
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_GetID@"/>
			<dependency name="Command_Find"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
				Function name to find.
			</param>
			  <returns>  The ID of the passed function.  </returns>  <remarks>  -  native Command_GetID(function[])  </remarks> 
		</member>
		<member name="M:Command_GetID@" syntax="Command_GetID@(function[])">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_GetID"/>
			<dependency name="X@"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Command_GetIllegalReturn" syntax="Command_GetIllegalReturn()">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_GetIllegalReturn@"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="e_COMMAND_FLAGS_INVALID_INPUT"/>
		</member>
		<member name="M:Command_GetIllegalReturn@" syntax="Command_GetIllegalReturn@()">
			<tagname value="bool"/>
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_GetIllegalReturn"/>
			<dependency name="X@"/>
		</member>
		<member name="M:Command_GetName" syntax="Command_GetName(f)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Command_GetName@"/>
			<dependency name="Command_GetName"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="F@"/>
			<dependency name="Q@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sReturnBuffer"/>
			<dependency name="cellmin"/>
			<dependency name="strunpack"/>
			<param name="f">
				Command to get the name of.
			</param>
			  <remarks>  native Command_GetName(funcid);  </remarks> 
		</member>
		<member name="M:Command_GetName@" syntax="Command_GetName@(f)">
			<attribute name="public"/>
			<stacksize value="149"/>
			<automaton name="@_"/>
			<dependency name="Command_GetName"/>
			<dependency name="R@"/>
			<param name="f">
			</param>
		</member>
		<member name="M:Command_GetNext" syntax="Command_GetNext(index, playerid)">
			<stacksize value="8"/>
			<automaton name="@_"/>
			<referrer name="Command_GetNext@"/>
			<dependency name="Command_GetNext"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="E_COMMAND_USERS"/>
			<dependency name="F@"/>
			<dependency name="Q@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sHighestID"/>
			<dependency name="YSI_g_sReturnBuffer"/>
			<dependency name="cellbits"/>
			<dependency name="strunpack"/>
			<param name="index">
				Index of the next command for this player.
			</param>
			<param name="playerid">
				Player to get the name for.
			</param>
			    <returns>  The name of a command for a single player.  </returns>  <remarks>  -  native Command_GetNext(index, playerid);  </remarks> 
		</member>
		<member name="M:Command_GetNext@" syntax="Command_GetNext@(index, playerid)">
			<attribute name="public"/>
			<stacksize value="150"/>
			<automaton name="@_"/>
			<dependency name="Command_GetNext"/>
			<dependency name="R@"/>
			<param name="index">
			</param>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Command_GetPlayer" syntax="Command_GetPlayer(cmd, pid)">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_GetPlayer@"/>
			<referrer name="Command_GetPlayerNamed"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="E_COMMAND_USERS"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="cellbits"/>
			<dependency name="cellmin"/>
			<dependency name="false"/>
			<param name="cmd">
			</param>
			<param name="pid">
			</param>
			<param name="command">Command to get for.</param>  <param name="playerid">Player to get.</param>  <returns>  Can this player use this command?  </returns>  <remarks>  native bool:Command_GetPlayer(command, playerid);  </remarks> 
		</member>
		<member name="M:Command_GetPlayer@" syntax="Command_GetPlayer@(cmd, pid)">
			<tagname value="bool"/>
			<attribute name="public"/>
			<stacksize value="5"/>
			<automaton name="@_"/>
			<dependency name="Command_GetPlayer"/>
			<dependency name="X@"/>
			<param name="cmd">
			</param>
			<param name="pid">
			</param>
		</member>
		<member name="M:Command_GetPlayerCommandCount" syntax="Command_GetPlayerCommandCount(playerid)">
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_GetPlayerCommandCount@"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="E_COMMAND_USERS"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sHighestID"/>
			<dependency name="cellbits"/>
			<param name="playerid">
				Player to count for.
			</param>
			  <remarks>  Gets the number of comamnds this player can use.  native Command_GetPlayerCommandCount(playerid);  </remarks> 
		</member>
		<member name="M:Command_GetPlayerCommandCount@" syntax="Command_GetPlayerCommandCount@(playerid)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_GetPlayerCommandCount"/>
			<dependency name="X@"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Command_GetPlayerDisabled" syntax="Command_GetPlayerDisabled(playerid)">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_GetPlayerDisabled@"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sDisabledPlayers"/>
			<dependency name="cellbits"/>
			<param name="playerid">
				Player to get.
			</param>
			  <returns>  Can this player use any commands?  </returns> 
		</member>
		<member name="M:Command_GetPlayerDisabled@" syntax="Command_GetPlayerDisabled@(playerid)">
			<tagname value="bool"/>
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_GetPlayerDisabled"/>
			<dependency name="X@"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Command_GetPlayerNamed" syntax="Command_GetPlayerNamed(func[], playerid)">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_GetPlayerNamed@"/>
			<dependency name="Command_Find"/>
			<dependency name="Command_GetPlayer"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<param name="func">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="playerid">
				Player to get.
			</param>
			<param name="funcname">Command to get for.</param>    <remarks>  Like Command_GetPlayer but for a function name.  native bool:Command_GetPlayerNamed(funcname[], playerid);  </remarks> 
		</member>
		<member name="M:Command_GetPlayerNamed@" syntax="Command_GetPlayerNamed@(func[], playerid)">
			<tagname value="bool"/>
			<attribute name="public"/>
			<stacksize value="5"/>
			<automaton name="@_"/>
			<dependency name="Command_GetPlayerNamed"/>
			<dependency name="X@"/>
			<param name="func">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Command_GetUnknownReturn" syntax="Command_GetUnknownReturn()">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_GetUnknownReturn@"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="e_COMMAND_FLAGS_NOT_FOUND"/>
		</member>
		<member name="M:Command_GetUnknownReturn@" syntax="Command_GetUnknownReturn@()">
			<tagname value="bool"/>
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_GetUnknownReturn"/>
			<dependency name="X@"/>
		</member>
		<member name="M:Command_IncOPCP" syntax="Command_IncOPCP()">
			<stacksize value="4"/>
			<automaton name="@_"/>
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="Command_IncOPCP@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="e_COMM_FLAG_OPCP_ADD"/>
		</member>
		<member name="M:Command_IncOPCP@" syntax="Command_IncOPCP@()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="@_"/>
			<dependency name="Command_IncOPCP"/>
		</member>
		<member name="M:Command_IncOPCR" syntax="Command_IncOPCR()">
			<stacksize value="4"/>
			<automaton name="@_"/>
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="Command_IncOPCR@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="e_COMM_FLAG_OPCR_ADD"/>
			<remarks>  This function, and the three other related ones, increment and decrement the  number of callbacks known to exist on the server.  If they are 0, there's no  point trying to call them on errors etc.  </remarks> 
		</member>
		<member name="M:Command_IncOPCR@" syntax="Command_IncOPCR@()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="@_"/>
			<dependency name="Command_IncOPCR"/>
		</member>
		<member name="M:Command_InitialiseFromGroups" syntax="Command_InitialiseFromGroups(x)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="Group_ExclusiveCommand"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_TouchNamed"/>
			<referrer name="Command_Touch"/>
			<referrer name="Command_Add"/>
			<dependency name="false"/>
			<param name="x">
				The element that was added (maybe).
			</param>
			  <remarks>  The name is a macro, so this function isn't actually called this.  This is  called when a new element is created, and as such it is NOT chained to other  parts of the groups system because each part handles one type of element.  Loop through all players and set up the element for them if they are in a  group that this is also in by default.  If x is "_GROUP_MAKE_LIMIT" then this is the test used in OnPlayerConnect in  various libraries to see if the groups system exists, and if not locally  initialise the player instead of leaving it up to this system.  </remarks> 
		</member>
		<member name="M:Command_IsValid" syntax="Command_IsValid(cmd)">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_IsValid@"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="cellmin"/>
			<param name="cmd">
			</param>
			<param name="command">Command to get for.</param>  <returns>  Is this command ID valid?  </returns> 
		</member>
		<member name="M:Command_IsValid@" syntax="Command_IsValid@(cmd)">
			<tagname value="bool"/>
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_IsValid"/>
			<dependency name="X@"/>
			<param name="cmd">
			</param>
		</member>
		<member name="M:Command_ReProcess" syntax="Command_ReProcess(p, c[], h)">
			<stacksize value="11"/>
			<automaton name="@_"/>
			<referrer name="Command_ReProcess@"/>
			<referrer name="@yH_OnPlayerText@004"/>
			<referrer name="@yH_OnPlayerCommandText@004"/>
			<dependency name="COMMAND_DENIED"/>
			<dependency name="COMMAND_DISABLED"/>
			<dependency name="COMMAND_INVALID_INPUT"/>
			<dependency name="COMMAND_NO_PLAYER"/>
			<dependency name="COMMAND_OK"/>
			<dependency name="COMMAND_UNDEFINED"/>
			<dependency name="CallRemoteFunction"/>
			<dependency name="Cell_GetLowestBit"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="E_COMMAND_POINTER"/>
			<dependency name="E_COMMAND_USERS"/>
			<dependency name="HashMap_GetWithHash"/>
			<dependency name="IsPlayerConnected"/>
			<dependency name="NULL"/>
			<dependency name="Puny_EncodeHash"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="YSI_g_sCommandMap"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sCurrentID"/>
			<dependency name="YSI_g_sDisabledPlayers"/>
			<dependency name="YSI_g_sMasterData"/>
			<dependency name="YSI_gscISI"/>
			<dependency name="YSI_gscISII"/>
			<dependency name="YSI_gscOPCP"/>
			<dependency name="YSI_gscOPCR"/>
			<dependency name="_@"/>
			<dependency name="cellbits"/>
			<dependency name="cellmin"/>
			<dependency name="e_COMM_FLAG_OPCP"/>
			<dependency name="e_COMM_FLAG_OPCR"/>
			<dependency name="getproperty"/>
			<dependency name="strunpack"/>
			<param name="p">
				(playerid) - Player who entered the command.
			</param>
			<param name="c">
				<paraminfo> [] </paraminfo>
				(cmdtext) - Text entered.
			</param>
			<param name="h">
				1 - Called from the help commmand or OnPlayerCommandText.  2 - Bypass permissions checks.  
			</param>
			      <returns>  true - success or hidden fail.  false - fail.  </returns>  <remarks>  Does all the command and error handling.  The macro version takes four  parameters:  <code>Command_ReProcess(playerid,cmdtext,help,force);</code>  <c>help</c> and <c>force</c> are combined together in to a bitmap.  </remarks> 
		</member>
		<member name="M:Command_ReProcess@" syntax="Command_ReProcess@(p, c[], h)">
			<attribute name="public"/>
			<stacksize value="6"/>
			<automaton name="@_"/>
			<dependency name="Command_ReProcess"/>
			<dependency name="X@"/>
			<param name="p">
			</param>
			<param name="c">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="h">
			</param>
		</member>
		<member name="M:Command_Remove" syntax="Command_Remove(func)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Command_Remove@"/>
			<referrer name="Command_RemoveNamed"/>
			<referrer name="@yH_OnMasterSystemClose@004"/>
			<dependency name="E_COMMAND_POINTER"/>
			<dependency name="HashMap_RemoveValue"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandMap"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sCommands"/>
			<param name="func">
				The slot of the command to remove.
			</param>
			  <remarks>  native Command_Remove(func);  </remarks> 
		</member>
		<member name="M:Command_Remove@" syntax="Command_Remove@(func)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_Remove"/>
			<param name="func">
			</param>
		</member>
		<member name="M:Command_RemoveNamed" syntax="Command_RemoveNamed(func[])">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Command_RemoveNamed@"/>
			<dependency name="Command_Find"/>
			<dependency name="Command_Remove"/>
			<dependency name="W@"/>
			<param name="func">
				<paraminfo> [] </paraminfo>
				The name of the command to remove.
			</param>
			  <remarks>  native Command_RemoveNamed(string:func[]);  </remarks> 
		</member>
		<member name="M:Command_RemoveNamed@" syntax="Command_RemoveNamed@(func[])">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_RemoveNamed"/>
			<param name="func">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Command_SetDeniedReturn" syntax="Command_SetDeniedReturn(set)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Command_SetDeniedReturn@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="e_COMMAND_FLAGS_DENIED"/>
			<param name="set">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Command_SetDeniedReturn@" syntax="Command_SetDeniedReturn@(set)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_SetDeniedReturn"/>
			<param name="set">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Command_SetDisconnectReturn" syntax="Command_SetDisconnectReturn(set)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Command_SetDisconnectReturn@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="e_COMMAND_FLAGS_NO_PLAYER"/>
			<param name="set">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Command_SetDisconnectReturn@" syntax="Command_SetDisconnectReturn@(set)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_SetDisconnectReturn"/>
			<param name="set">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Command_SetIllegalReturn" syntax="Command_SetIllegalReturn(set)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Command_SetIllegalReturn@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="e_COMMAND_FLAGS_INVALID_INPUT"/>
			<param name="set">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Command_SetIllegalReturn@" syntax="Command_SetIllegalReturn@(set)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_SetIllegalReturn"/>
			<param name="set">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Command_SetPlayer" syntax="Command_SetPlayer(c, p, s)">
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Group_FullPlayerUpdate"/>
			<referrer name="_Group_IncludeAll_1"/>
			<referrer name="Command_SetPlayer@"/>
			<referrer name="Command_SetPlayerNamed"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="E_COMMAND_USERS"/>
			<dependency name="PA_Set"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="cellmin"/>
			<param name="c">
			</param>
			<param name="p">
			</param>
			<param name="s">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="command">Command to set for.</param>  <param name="playerid">Player to set.</param>  <param name="set">Wether or not this player can use this command.</param>  <remarks>  native bool:Command_SetPlayer(command, playerid, bool:set);  </remarks> 
		</member>
		<member name="M:Command_SetPlayer@" syntax="Command_SetPlayer@(c, p, s)">
			<attribute name="public"/>
			<stacksize value="6"/>
			<automaton name="@_"/>
			<dependency name="Command_SetPlayer"/>
			<param name="c">
			</param>
			<param name="p">
			</param>
			<param name="s">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Command_SetPlayerDisabled" syntax="Command_SetPlayerDisabled(playerid, set)">
			<stacksize value="6"/>
			<automaton name="@_"/>
			<referrer name="Command_SetPlayerDisabled@"/>
			<dependency name="PA_Set"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sDisabledPlayers"/>
			<param name="playerid">
				Player to set.
			</param>
			<param name="set">
				<paraminfo>bool </paraminfo>
				Can they use any commands at all.
			</param>
			    <remarks>  Enables or disables using commands for this player.  Enabling commands does  not enable ALL commands, just allows them to use the ones for which they  have otherwise set permissions.  Disabling prevents them from using ANY  commands at all (though this can be overridden by returning `COMMAND_OK` in  `OnPlayerCommandReceived`).  </remarks> 
		</member>
		<member name="M:Command_SetPlayerDisabled@" syntax="Command_SetPlayerDisabled@(playerid, set)">
			<attribute name="public"/>
			<stacksize value="5"/>
			<automaton name="@_"/>
			<dependency name="Command_SetPlayerDisabled"/>
			<param name="playerid">
			</param>
			<param name="set">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Command_SetPlayerNamed" syntax="Command_SetPlayerNamed(f[], p, s)">
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Command_SetPlayerNamed@"/>
			<dependency name="Command_Find"/>
			<dependency name="Command_SetPlayer"/>
			<dependency name="W@"/>
			<param name="f">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="p">
			</param>
			<param name="s">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="funcname">Command to set for.</param>  <param name="playerid">Player to set.</param>  <param name="set">Wether or not this player can use this command.</param>  <remarks>  Like Command_SetPlayer but for a function name.  native bool:Command_SetPlayerNamed(funcname[], playerid, bool:set);  </remarks> 
		</member>
		<member name="M:Command_SetPlayerNamed@" syntax="Command_SetPlayerNamed@(f[], p, s)">
			<attribute name="public"/>
			<stacksize value="6"/>
			<automaton name="@_"/>
			<dependency name="Command_SetPlayerNamed"/>
			<param name="f">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="p">
			</param>
			<param name="s">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Command_SetUnknownReturn" syntax="Command_SetUnknownReturn(set)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Command_SetUnknownReturn@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<dependency name="e_COMMAND_FLAGS_NOT_FOUND"/>
			<param name="set">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Command_SetUnknownReturn@" syntax="Command_SetUnknownReturn@(set)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_SetUnknownReturn"/>
			<param name="set">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Command_Touch" syntax="Command_Touch(command)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Command_Touch@"/>
			<dependency name="Command_InitialiseFromGroups"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="cellmin"/>
			<param name="command">
				Command to "touch".
			</param>
			  <remarks>  Used within "GROUP_ADD" to quickly assign a load of commands to just one  group.  </remarks> 
		</member>
		<member name="M:Command_Touch@" syntax="Command_Touch@(command)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_Touch"/>
			<param name="command">
			</param>
		</member>
		<member name="M:Command_TouchNamed" syntax="Command_TouchNamed(command[])">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Command_TouchNamed@"/>
			<dependency name="Command_Find"/>
			<dependency name="Command_InitialiseFromGroups"/>
			<dependency name="W@"/>
			<param name="command">
				<paraminfo> [] </paraminfo>
				Command to "touch".
			</param>
			  <remarks>  Used within "GROUP_ADD" to quickly assign a load of commands to just one  group.  </remarks> 
		</member>
		<member name="M:Command_TouchNamed@" syntax="Command_TouchNamed@(command[])">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Command_TouchNamed"/>
			<param name="command">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:CreateActor" syntax="CreateActor(modelid, X, Y, Z, Rotation)">
			<attribute name="native"/>
			<referrer name="Iter_CreateActor"/>
			<param name="modelid">
			</param>
			<param name="X">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="Y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="Z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="Rotation">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:CreatePlayerTextDraw" syntax="CreatePlayerTextDraw(playerid, x, y, text[])">
			<tagname value="PlayerText"/>
			<attribute name="native"/>
			<referrer name="va_CreatePlayerTextDraw"/>
			<param name="playerid">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="text">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:CreateVehicle" syntax="CreateVehicle(vehicletype, x, y, z, rotation, color1, color2, respawn_delay, addsiren)">
			<attribute name="native"/>
			<referrer name="Iter_CreateVehicle"/>
			<param name="vehicletype">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="rotation">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="color1">
			</param>
			<param name="color2">
			</param>
			<param name="respawn_delay">
			</param>
			<param name="addsiren">
			</param>
		</member>
		<member name="M:Debug_Disable" syntax="Debug_Disable()">
			<stacksize value="1"/>
			<remarks>  Turn off level 0 prints.  </remarks>  <transition target="8wQ"/>

		</member>
		<member name="M:Debug_Enable" syntax="Debug_Enable()">
			<stacksize value="1"/>
			<remarks>  Turn on level 0 prints.  </remarks>  <transition target="vQ"/>

		</member>
		<member name="M:Debug_Level" syntax="Debug_Level(level)">
			<stacksize value="1"/>
			<dependency name="YSI_gDebugLevel"/>
			<param name="level">
			</param>
			<remarks>  Set the debug level when the code is compiled with <c>_DEBUG=-1</c>, which  means full run-time selection.  </remarks> 
		</member>
		<member name="M:Debug_OnScriptInit" syntax="Debug_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetGlobal"/>
			<dependency name="AMX_HEADER_AMX_VERSION"/>
			<dependency name="AMX_HEADER_CIP"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_HEADER_DAT"/>
			<dependency name="AMX_HEADER_DEFSIZE"/>
			<dependency name="AMX_HEADER_FILE_VERSION"/>
			<dependency name="AMX_HEADER_FLAGS"/>
			<dependency name="AMX_HEADER_HEA"/>
			<dependency name="AMX_HEADER_LIBRARIES"/>
			<dependency name="AMX_HEADER_MAGIC"/>
			<dependency name="AMX_HEADER_NAMETABLE"/>
			<dependency name="AMX_HEADER_NATIVES"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_HEADER_PUBVARS"/>
			<dependency name="AMX_HEADER_SIZE"/>
			<dependency name="AMX_HEADER_STP"/>
			<dependency name="AMX_HEADER_TAGS"/>
			<dependency name="AMX_REAL_ADDRESS"/>
			<dependency name="AMX_REAL_DATA"/>
		</member>
		<member name="M:Debug_Print0" syntax="Debug_Print0(str[], ...)">
			<stacksize value="1"/>
			<automaton name="ysi_debug"/>
			<referrer name="YVers_OnScriptInit"/>
			<referrer name="AMX_Read"/>
			<referrer name="YVA2_DummyPush"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<referrer name="CGen_AddCodeSpace"/>
			<referrer name="Hooks_IsolateName"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GetStubEntry"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="@_"/>
			<referrer name="HashMap_Add"/>
			<referrer name="Iter_YieldEnter"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="@yH_OnMasterSystemClose@004"/>
			<referrer name="Command_Add"/>
			<referrer name="@a"/>
			<dependency name="printf"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				
			</param>
			<param name="format">str.</param>    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print0("variables: %d, %d", i, j);  </code>  Or:  <code>  P:0("variables: %d, %d", i, j);  </code>  <c>_DEBUG</c> level 0 prints are ALWAYS compiled, but are runtime switched  using the automata <c>ysi_debug</c>.  When then state is <c>ysi_debug :  on</c>, the prints are executed.  When then state is <c>ysi_debug : off</c>,  they aren't.  </remarks> 
		</member>
		<member name="M:Debug_PrintArray" syntax="Debug_PrintArray(arr[], size)">
			<stacksize value="108"/>
			<dependency name="Debug_PrintArray"/>
			<dependency name="format"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Debug_SetState" syntax="Debug_SetState()">
			<stacksize value="1"/>
			<automaton name="ysi_debug"/>
			<referrer name="YVers_OnScriptInit"/>
			<transition keep="true" target="ysi_debug : on" source="ysi_debug : "/>  <remarks>  Mostly exists to define the full range of <c>ysi_debug</c> states.  </remarks> <p/> <transition target="jQ"/>

		</member>
		<member name="M:DestroyActor" syntax="DestroyActor(actorid)">
			<attribute name="native"/>
			<referrer name="Iter_DestroyActor"/>
			<param name="actorid">
			</param>
		</member>
		<member name="M:DestroyVehicle" syntax="DestroyVehicle(vehicleid)">
			<attribute name="native"/>
			<referrer name="Iter_DestroyVehicle"/>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:DisableInteriorEnterExits" syntax="DisableInteriorEnterExits()">
			<attribute name="native"/>
			<referrer name="ScriptInit_OnGameModeInit"/>
		</member>
		<member name="M:DisasmDecodeInsn" syntax="DisasmDecodeInsn(ctx[])">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<referrer name="DisasmNext"/>
			<referrer name="DisasmNextInsn"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="AMX_Read"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="GetOpcodeInstructionParameters"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_NONE"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="UnrelocateOpcode"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmDump" syntax="DisasmDump(filename[])">
			<stacksize value="4"/>
			<dependency name="DisasmWrite"/>
			<param name="filename">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmGetCurIp" syntax="DisasmGetCurIp(ctx[])">
			<stacksize value="1"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="CodeScanStepInternal"/>
			<dependency name="DisasmContext_cip"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmGetInsnName" syntax="DisasmGetInsnName(ctx[], name[], size)">
			<stacksize value="21"/>
			<referrer name="DisasmWriteCode"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="GetOpcodeInstructionName"/>
			<dependency name="strcat"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:DisasmGetNextIp" syntax="DisasmGetNextIp(ctx[])">
			<stacksize value="1"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanCheck"/>
			<dependency name="DisasmContext_nip"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmGetNumOperands" syntax="DisasmGetNumOperands(ctx[])">
			<stacksize value="5"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="Hooks_GetStubEntry"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="GetOpcodeInstructionParameters"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="ReadAmxMemory"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmGetOpcode" syntax="DisasmGetOpcode(ctx[])">
			<tagname value="Opcode"/>
			<stacksize value="1"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<referrer name="AMX_Read"/>
			<dependency name="DisasmContext_opcode"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmGetOperand" syntax="DisasmGetOperand(ctx[], index)">
			<stacksize value="4"/>
			<referrer name="DisasmGetOperandReloc"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="AMX_Read"/>
			<referrer name="Hooks_GetStubEntry"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="ReadAmxMemory"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:DisasmGetOperandReloc" syntax="DisasmGetOperandReloc(ctx[], index)">
			<stacksize value="6"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanCheck"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmNeedReloc"/>
			<dependency name="DisasmReloc"/>
			<dependency name="OP_CASETBL"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:DisasmGetRemaining" syntax="DisasmGetRemaining(ctx[])">
			<stacksize value="1"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmInit" syntax="DisasmInit(ctx[], start, end)">
			<stacksize value="21"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<referrer name="AMX_Read"/>
			<referrer name="Hooks_GetStubEntry"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="gCodBase"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="end">
			</param>
		</member>
		<member name="M:DisasmNeedReloc" syntax="DisasmNeedReloc(ctx[])">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="DisasmGetOperandReloc"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="GetOpcodeInstructionRelocatable"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmNext" syntax="DisasmNext(ctx[])">
			<tagname value="DisasmResult"/>
			<stacksize value="4"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanStepInternal"/>
			<dependency name="DISASM_DONE"/>
			<dependency name="DISASM_NOP"/>
			<dependency name="DISASM_OK"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="DisasmDecodeInsn"/>
			<dependency name="NUM_OPCODES"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmNextInsn" syntax="DisasmNextInsn(ctx[])">
			<tagname value="Opcode"/>
			<stacksize value="4"/>
			<referrer name="YVA2_FoundCall"/>
			<referrer name="YVA2_FoundPush"/>
			<referrer name="Hooks_GetStubEntry"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="DisasmDecodeInsn"/>
			<dependency name="OP_NONE"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmReloc" syntax="DisasmReloc(addr)">
			<stacksize value="1"/>
			<referrer name="DisasmGetOperandReloc"/>
			<dependency name="gCodBase"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:DisasmWrite" syntax="DisasmWrite(filename[])">
			<tagname value="bool"/>
			<stacksize value="5"/>
			<referrer name="DisasmDump"/>
			<dependency name="DisasmWriteFile"/>
			<dependency name="false"/>
			<dependency name="fclose"/>
			<dependency name="fopen"/>
			<dependency name="io_write"/>
			<dependency name="true"/>
			<param name="filename">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmWriteCode" syntax="DisasmWriteCode(file)">
			<stacksize value="159"/>
			<referrer name="DisasmWriteFile"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_CIP"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmDecodeInsn"/>
			<dependency name="DisasmGetCurIp"/>
			<dependency name="DisasmGetInsnName"/>
			<dependency name="DisasmGetNextIp"/>
			<dependency name="DisasmGetNumOperands"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmGetOperandReloc"/>
			<dependency name="DisasmInit"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="GetNativeIndexFromAddress"/>
			<dependency name="GetNativeNameFromIndex"/>
			<dependency name="GetPublicIndexFromAddress"/>
			<dependency name="GetPublicNameFromIndex"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ToHexStr"/>
			<dependency name="fwrite"/>
			<dependency name="gCodBase"/>
			<dependency name="strcat"/>
			<dependency name="strlen"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
		</member>
		<member name="M:DisasmWriteData" syntax="DisasmWriteData(file)">
			<stacksize value="38"/>
			<referrer name="DisasmWriteFile"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_HEA"/>
			<dependency name="DisasmWriteDataRowChar"/>
			<dependency name="DisasmWriteDataRowHex"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="ToHexStr"/>
			<dependency name="fwrite"/>
			<dependency name="min"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
		</member>
		<member name="M:DisasmWriteDataRowChar" syntax="DisasmWriteDataRowChar(file, start, num, max)">
			<stacksize value="13"/>
			<referrer name="DisasmWriteData"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ToPrintableAscii"/>
			<dependency name="fwrite"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="num">
			</param>
			<param name="max">
			</param>
		</member>
		<member name="M:DisasmWriteDataRowHex" syntax="DisasmWriteDataRowHex(file, start, num, max)">
			<stacksize value="19"/>
			<referrer name="DisasmWriteData"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ToHexStr"/>
			<dependency name="fwrite"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="num">
			</param>
			<param name="max">
			</param>
		</member>
		<member name="M:DisasmWriteFile" syntax="DisasmWriteFile(file)">
			<stacksize value="4"/>
			<referrer name="DisasmWrite"/>
			<dependency name="DisasmWriteCode"/>
			<dependency name="DisasmWriteData"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
		</member>
		<member name="M:Distribute_Do" syntax="Distribute_Do(func[], ...)">
			<stacksize value="7"/>
			<referrer name="YSI_g_sCommandFlags_Dist"/>
			<referrer name="YSI_g_sErrorMessages_Dist"/>
			<referrer name="YSI_g_sDisabledPlayers_Dist"/>
			<dependency name="CallRemoteFunction"/>
			<dependency name="Hooks_NumArgs"/>
			<dependency name="getarg"/>
			<param name="func">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:Distribute_So" syntax="Distribute_So(func[], idx, masters[], ...)">
			<stacksize value="8"/>
			<referrer name="YSI_g_sCommands_Dist"/>
			<dependency name="CallRemoteFunction"/>
			<dependency name="Hooks_NumArgs"/>
			<dependency name="_@"/>
			<dependency name="getarg"/>
			<param name="func">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="masters">
				<paraminfo>Bit [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:Distribute_To" syntax="Distribute_To(from[], ss, ...)">
			<stacksize value="7"/>
			<referrer name="YSI_g_sCommandFlags@Dist"/>
			<referrer name="YSI_g_sErrorMessages@Dist"/>
			<referrer name="YSI_g_sDisabledPlayers@Dist"/>
			<referrer name="YSI_g_sCommands@Dist"/>
			<dependency name="Hooks_NumArgs"/>
			<dependency name="getarg"/>
			<dependency name="memcpy"/>
			<dependency name="min"/>
			<param name="from">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="ss">
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:DumpStack" syntax="DumpStack()">
			<stacksize value="9"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="print"/>
			<dependency name="printf"/>
		</member>
		<member name="M:EnableStuntBonusForAll" syntax="EnableStuntBonusForAll(enable)">
			<attribute name="native"/>
			<referrer name="ScriptInit_OnGameModeInit"/>
			<param name="enable">
			</param>
		</member>
		<member name="M:F@" syntax="F@()">
			<stacksize value="6"/>
			<referrer name="Command_GetName"/>
			<referrer name="Command_GetDisplay"/>
			<referrer name="Command_GetDisplayNamed"/>
			<referrer name="Command_GetNext"/>
			<dependency name="Q@"/>
			<dependency name="getproperty"/>
			<dependency name="strunpack"/>
		</member>
		<member name="M:G@" syntax="G@(...)">
			<stacksize value="1"/>
			<dependency name="G@"/>
			<dependency name="Q@"/>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:GameTextForAll" syntax="GameTextForAll(string[], time, style)">
			<attribute name="native"/>
			<referrer name="va_GameTextForAll"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="time">
			</param>
			<param name="style">
			</param>
		</member>
		<member name="M:GameTextForPlayer" syntax="GameTextForPlayer(playerid, string[], time, style)">
			<attribute name="native"/>
			<referrer name="va_GameTextForPlayer"/>
			<referrer name="_y_utils_OnPlayerConnect"/>
			<param name="playerid">
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="time">
			</param>
			<param name="style">
			</param>
		</member>
		<member name="M:GetAmxAddress" syntax="GetAmxAddress()">
			<stacksize value="5"/>
			<referrer name="ReadAmxCell"/>
			<referrer name="WriteAmxCell"/>
			<dependency name="RunShellcode"/>
			<dependency name="refabs"/>
		</member>
		<member name="M:GetAmxBaseAddress" syntax="GetAmxBaseAddress()">
			<stacksize value="3"/>
			<referrer name="AbsToRel"/>
			<referrer name="RelToAbs"/>
			<referrer name="AsmGetJumpAddressFromOffset"/>
			<referrer name="AsmEmitCallAbs"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="DisasmInit"/>
			<referrer name="CodeScanInit"/>
			<referrer name="ProfilerInit"/>
			<referrer name="GetFunctionFromReturnAddress"/>
			<dependency name="GetAmxBaseAddressNow"/>
		</member>
		<member name="M:GetAmxBaseAddressNow" syntax="GetAmxBaseAddressNow()">
			<stacksize value="9"/>
			<referrer name="GetAmxBaseAddress"/>
			<dependency name="GetAmxBaseAddress_helper"/>
		</member>
		<member name="M:GetAmxBaseAddress_helper" syntax="GetAmxBaseAddress_helper()">
			<stacksize value="1"/>
			<referrer name="GetAmxBaseAddressNow"/>
		</member>
		<member name="M:GetAmxFrame" syntax="GetAmxFrame()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxHeader" syntax="GetAmxHeader(amxhdr[])">
			<stacksize value="3"/>
			<referrer name="AsmGetJumpAddressFromOffset"/>
			<referrer name="AsmGetCode"/>
			<referrer name="AsmEmitCallAbs"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="DisasmInit"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DisasmWriteData"/>
			<referrer name="CodeScanInit"/>
			<referrer name="ProfilerInit"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetAmxHeaderComponent" syntax="GetAmxHeaderComponent(comp)">
			<stacksize value="3"/>
			<referrer name="GetPublicNameFromIndex"/>
			<referrer name="GetNativeNameFromIndex"/>
			<referrer name="GetPubVarNameFromIndex"/>
			<referrer name="GetTagNameFromIndex"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="comp">
				<paraminfo>AMX_HDR </paraminfo>
			</param>
		</member>
		<member name="M:GetAmxHeaderNow" syntax="GetAmxHeaderNow(amxhdr[])">
			<stacksize value="21"/>
			<referrer name="ResetStaticAmxHeader"/>
			<dependency name="AMX_HDR_AMX_VERSION"/>
			<dependency name="AMX_HDR_CIP"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_FILE_VERSION"/>
			<dependency name="AMX_HDR_FLAGS"/>
			<dependency name="AMX_HDR_HEA"/>
			<dependency name="AMX_HDR_LIBRARIES"/>
			<dependency name="AMX_HDR_MAGIC"/>
			<dependency name="AMX_HDR_NAMETABLE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="AMX_HDR_OFFSET_AMX_VERSION"/>
			<dependency name="AMX_HDR_OFFSET_CIP"/>
			<dependency name="AMX_HDR_OFFSET_COD"/>
			<dependency name="AMX_HDR_OFFSET_DAT"/>
			<dependency name="AMX_HDR_OFFSET_DEFSIZE"/>
			<dependency name="AMX_HDR_OFFSET_FILE_VERSION"/>
			<dependency name="AMX_HDR_OFFSET_FLAGS"/>
			<dependency name="AMX_HDR_OFFSET_HEA"/>
			<dependency name="AMX_HDR_OFFSET_LIBRARIES"/>
			<dependency name="AMX_HDR_OFFSET_MAGIC"/>
			<dependency name="AMX_HDR_OFFSET_NAMETABLE"/>
			<dependency name="AMX_HDR_OFFSET_NATIVES"/>
			<dependency name="AMX_HDR_OFFSET_PUBLICS"/>
			<dependency name="AMX_HDR_OFFSET_PUBVARS"/>
			<dependency name="AMX_HDR_OFFSET_SIZE"/>
			<dependency name="AMX_HDR_OFFSET_STP"/>
			<dependency name="AMX_HDR_OFFSET_TAGS"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="AMX_HDR_SIZE"/>
			<dependency name="AMX_HDR_STP"/>
			<dependency name="AMX_HDR_TAGS"/>
			<dependency name="GetRawAmxHeader"/>
			<dependency name="copy_1"/>
			<dependency name="copy_2"/>
			<dependency name="copy_4"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetAmxHeapBase" syntax="GetAmxHeapBase()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxHeapTop" syntax="GetAmxHeapTop()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxJITBaseAddress" syntax="GetAmxJITBaseAddress()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxNextInstructionPointer" syntax="GetAmxNextInstructionPointer()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxStackBase" syntax="GetAmxStackBase()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxStackBottom" syntax="GetAmxStackBottom()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetCallerFrame" syntax="GetCallerFrame()">
			<stacksize value="1"/>
			<referrer name="GetCurrentFramePreviousFrame"/>
			<referrer name="GetCurrentFrameReturn"/>
			<referrer name="GetCurrentFrameTotalSize"/>
			<referrer name="GetCurrentFrameTotalCount"/>
			<referrer name="GetCurrentFrameLocalSize"/>
			<referrer name="GetCurrentFrameLocalCount"/>
			<referrer name="GetCurrentFrameHeaderSize"/>
			<referrer name="GetCurrentFrameHeaderCount"/>
			<referrer name="GetCurrentFrameParameterSize"/>
			<referrer name="GetCurrentFrameParameter"/>
			<referrer name="GetCurrentFrameLocal"/>
			<referrer name="GetCurrentFrameParameterCount"/>
			<referrer name="SetCurrentFrameReturn"/>
			<referrer name="SetCurrentFramePreviousFrame"/>
			<referrer name="SetCurrentParameterSize"/>
			<referrer name="SetCurrentParameterCount"/>
			<referrer name="GetCurrentFrameFunction"/>
		</member>
		<member name="M:GetCurrentFrame" syntax="GetCurrentFrame()">
			<stacksize value="1"/>
			<referrer name="GetFrameNextFrame"/>
		</member>
		<member name="M:GetCurrentFrameFunction" syntax="GetCurrentFrameFunction()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameFunction"/>
		</member>
		<member name="M:GetCurrentFrameHeaderCount" syntax="GetCurrentFrameHeaderCount()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameHeaderCount"/>
		</member>
		<member name="M:GetCurrentFrameHeaderSize" syntax="GetCurrentFrameHeaderSize()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameHeaderSize"/>
		</member>
		<member name="M:GetCurrentFrameLocal" syntax="GetCurrentFrameLocal(param)">
			<stacksize value="5"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameLocal"/>
			<param name="param">
			</param>
		</member>
		<member name="M:GetCurrentFrameLocalCount" syntax="GetCurrentFrameLocalCount()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameLocalCount"/>
		</member>
		<member name="M:GetCurrentFrameLocalSize" syntax="GetCurrentFrameLocalSize()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameLocalSize"/>
		</member>
		<member name="M:GetCurrentFrameParameter" syntax="GetCurrentFrameParameter(param, idx)">
			<stacksize value="6"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameParameter"/>
			<param name="param">
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:GetCurrentFrameParameterCount" syntax="GetCurrentFrameParameterCount()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameParameterCount"/>
		</member>
		<member name="M:GetCurrentFrameParameterSize" syntax="GetCurrentFrameParameterSize()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameParameterSize"/>
		</member>
		<member name="M:GetCurrentFramePreviousFrame" syntax="GetCurrentFramePreviousFrame()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFramePreviousFrame"/>
		</member>
		<member name="M:GetCurrentFrameReturn" syntax="GetCurrentFrameReturn()">
			<stacksize value="4"/>
			<referrer name="O@A_"/>
			<referrer name="AMX_Read"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameReturn"/>
		</member>
		<member name="M:GetCurrentFrameTotalCount" syntax="GetCurrentFrameTotalCount()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameTotalCount"/>
		</member>
		<member name="M:GetCurrentFrameTotalSize" syntax="GetCurrentFrameTotalSize()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameTotalSize"/>
		</member>
		<member name="M:GetDat" syntax="GetDat()">
			<stacksize value="1"/>
			<referrer name="AbsToRel"/>
			<referrer name="RelToAbs"/>
		</member>
		<member name="M:GetFrameFunction" syntax="GetFrameFunction(frm_addr)">
			<stacksize value="29"/>
			<referrer name="GetCurrentFrameFunction"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_CIP"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="GetFrameNextFrame"/>
			<dependency name="GetFramePreviousFrame"/>
			<dependency name="GetFrameReturn"/>
			<dependency name="GetFrameVariable"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CONST_PRI"/>
			<dependency name="OP_LOAD_PRI"/>
			<dependency name="OP_LOAD_S_PRI"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_RETN"/>
			<dependency name="OP_SCTRL"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="UnrelocateOpcode"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameHeaderCount" syntax="GetFrameHeaderCount(frm_addr)">
			<stacksize value="4"/>
			<referrer name="GetCurrentFrameHeaderCount"/>
			<dependency name="GetFrameHeaderSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameHeaderSize" syntax="GetFrameHeaderSize(frm_addr)">
			<stacksize value="1"/>
			<referrer name="GetFrameTotalSize"/>
			<referrer name="GetFrameLocalSize"/>
			<referrer name="GetFrameHeaderCount"/>
			<referrer name="GetCurrentFrameHeaderSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameLocal" syntax="GetFrameLocal(frm_addr, param)">
			<stacksize value="1"/>
			<referrer name="GetCurrentFrameLocal"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
		</member>
		<member name="M:GetFrameLocalCount" syntax="GetFrameLocalCount(frm_addr)">
			<stacksize value="4"/>
			<referrer name="GetCurrentFrameLocalCount"/>
			<dependency name="GetFrameLocalSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameLocalSize" syntax="GetFrameLocalSize(frm_addr)">
			<stacksize value="6"/>
			<referrer name="GetFrameTotalSize"/>
			<referrer name="GetFrameLocalCount"/>
			<referrer name="GetCurrentFrameLocalSize"/>
			<dependency name="GetFrameHeaderSize"/>
			<dependency name="GetFrameNextFrame"/>
			<dependency name="GetFrameParameterSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameNextFrame" syntax="GetFrameNextFrame(frm_addr)">
			<stacksize value="6"/>
			<referrer name="GetFrameLocalSize"/>
			<referrer name="GetFrameFunction"/>
			<dependency name="GetCurrentFrame"/>
			<dependency name="GetFramePreviousFrame"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameParameter" syntax="GetFrameParameter(frm_addr, param, idx)">
			<stacksize value="1"/>
			<referrer name="GetCurrentFrameParameter"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:GetFrameParameterCount" syntax="GetFrameParameterCount(frm_addr)">
			<stacksize value="4"/>
			<referrer name="GetCurrentFrameParameterCount"/>
			<dependency name="GetFrameParameterSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameParameterSize" syntax="GetFrameParameterSize(frm_addr)">
			<stacksize value="1"/>
			<referrer name="GetFrameTotalSize"/>
			<referrer name="GetFrameLocalSize"/>
			<referrer name="GetFrameParameterCount"/>
			<referrer name="GetCurrentFrameParameterSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFramePreviousFrame" syntax="GetFramePreviousFrame(frm_addr)">
			<stacksize value="1"/>
			<referrer name="GetFrameNextFrame"/>
			<referrer name="GetCurrentFramePreviousFrame"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="GetStackTrace"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameReturn" syntax="GetFrameReturn(frm_addr)">
			<stacksize value="1"/>
			<referrer name="GetCurrentFrameReturn"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="GetStackTrace"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameTotalCount" syntax="GetFrameTotalCount(frm_addr)">
			<stacksize value="4"/>
			<referrer name="GetCurrentFrameTotalCount"/>
			<dependency name="GetFrameTotalSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameTotalSize" syntax="GetFrameTotalSize(frm_addr)">
			<stacksize value="4"/>
			<referrer name="GetFrameTotalCount"/>
			<referrer name="GetCurrentFrameTotalSize"/>
			<dependency name="GetFrameHeaderSize"/>
			<dependency name="GetFrameLocalSize"/>
			<dependency name="GetFrameParameterSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameVariable" syntax="GetFrameVariable(frm_addr, param, idx)">
			<stacksize value="1"/>
			<referrer name="GetFrameFunction"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:GetFunctionFromReturnAddress" syntax="GetFunctionFromReturnAddress(ret_addr)">
			<stacksize value="4"/>
			<referrer name="PrintStackTrace"/>
			<dependency name="GetAmxBaseAddress"/>
			<param name="ret_addr">
			</param>
		</member>
		<member name="M:GetJITGeneratorVersion" syntax="GetJITGeneratorVersion()">
			<stacksize value="1"/>
			<referrer name="SysreqC"/>
			<referrer name="SysreqD"/>
			<referrer name="SysreqCN"/>
			<referrer name="SysreqDN"/>
			<referrer name="CallNative"/>
			<referrer name="CallNativeByAddress"/>
		</member>
		<member name="M:GetNativeAddressFromIndex" syntax="GetNativeAddressFromIndex(index)">
			<stacksize value="7"/>
			<referrer name="GetNativeAddressFromName"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetNativeInfo"/>
			<param name="index">
			</param>
		</member>
		<member name="M:GetNativeAddressFromName" syntax="GetNativeAddressFromName(name[])">
			<stacksize value="4"/>
			<dependency name="GetNativeAddressFromIndex"/>
			<dependency name="GetNativeIndexFromName"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetNativeIndexFromAddress" syntax="GetNativeIndexFromAddress(address)">
			<stacksize value="7"/>
			<referrer name="GetNativeNameFromAddress"/>
			<referrer name="DisasmWriteCode"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="GetNumNatives"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="address">
			</param>
		</member>
		<member name="M:GetNativeIndexFromName" syntax="GetNativeIndexFromName(name[])">
			<stacksize value="10"/>
			<referrer name="GetNativeAddressFromName"/>
			<referrer name="AsmEmitSysreq"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="GetNumNatives"/>
			<dependency name="NtCompare"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetNativeInfo" syntax="GetNativeInfo(index, info[])">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<referrer name="GetNativeAddressFromIndex"/>
			<referrer name="GetNativeNameFromIndex"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="GetNumNatives"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="false"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="true"/>
			<param name="index">
			</param>
			<param name="info">
				<paraminfo> [2] </paraminfo>
			</param>
		</member>
		<member name="M:GetNativeNameFromAddress" syntax="GetNativeNameFromAddress(address, name[], size)">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<dependency name="GetNativeIndexFromAddress"/>
			<dependency name="GetNativeNameFromIndex"/>
			<param name="address">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetNativeNameFromIndex" syntax="GetNativeNameFromIndex(index, name[], size)">
			<tagname value="bool"/>
			<stacksize value="8"/>
			<referrer name="GetNativeNameFromAddress"/>
			<referrer name="DisasmWriteCode"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="GetAmxHeaderComponent"/>
			<dependency name="GetNativeInfo"/>
			<dependency name="NtCopy"/>
			<dependency name="false"/>
			<param name="index">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetNumNatives" syntax="GetNumNatives(amxhdr[])">
			<stacksize value="1"/>
			<referrer name="GetNativeIndexFromAddress"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="HookNative"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_LIBRARIES"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetNumPubVars" syntax="GetNumPubVars(amxhdr[])">
			<stacksize value="1"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetPubVarIndexFromAddress"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="AMX_HDR_TAGS"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetNumPublics" syntax="GetNumPublics(amxhdr[])">
			<stacksize value="2"/>
			<referrer name="GetPublicIndexFromAddress"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="HookPublic"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetNumTags" syntax="GetNumTags(amxhdr[])">
			<stacksize value="1"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagIndexFromName"/>
			<referrer name="GetTagIndexFromID"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NAMETABLE"/>
			<dependency name="AMX_HDR_TAGS"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetOS" syntax="GetOS()">
			<tagname value="OS"/>
			<stacksize value="4"/>
			<referrer name="IsWindows"/>
			<referrer name="IsLinux"/>
			<dependency name="OP_LOAD_PRI"/>
			<dependency name="OS_LINUX"/>
			<dependency name="OS_UNKNOWN"/>
			<dependency name="OS_WINDOWS"/>
			<dependency name="RelocateOpcode"/>
		</member>
		<member name="M:GetOpcodeInstructionInformation" syntax="GetOpcodeInstructionInformation(opcode)">
			<stacksize value="1"/>
			<dependency name="GetOpcodeInstructionInformation"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="insn_table"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:GetOpcodeInstructionName" syntax="GetOpcodeInstructionName(opcode)">
			<stacksize value="1"/>
			<referrer name="DisasmGetInsnName"/>
			<dependency name="GetOpcodeInstructionName"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="insn_table"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:GetOpcodeInstructionParameters" syntax="GetOpcodeInstructionParameters(opcode)">
			<stacksize value="1"/>
			<referrer name="AsmEmitPadding"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="DisasmGetNumOperands"/>
			<referrer name="CodeScanMatcherPattern_"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="OpcodeInsnInfo_num_opers"/>
			<dependency name="insn_table"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:GetOpcodeInstructionRelocatable" syntax="GetOpcodeInstructionRelocatable(opcode)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="DisasmNeedReloc"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="OpcodeInsnInfo_needs_reloc"/>
			<dependency name="false"/>
			<dependency name="insn_table"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:GetPlayerFacingAngle" syntax="GetPlayerFacingAngle(playerid, &amp;ang)">
			<attribute name="native"/>
			<referrer name="@_yCjoinfight"/>
			<param name="playerid">
			</param>
			<param name="ang">
				<paraminfo>Float &amp; </paraminfo>
			</param>
		</member>
		<member name="M:GetPlayerIp" syntax="GetPlayerIp(playerid, name[], len)">
			<attribute name="native"/>
			<referrer name="OnPlayerConnect"/>
			<param name="playerid">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:GetPlayerName" syntax="GetPlayerName(playerid, name[], len)">
			<attribute name="native"/>
			<referrer name="ReturnUser"/>
			<referrer name="ReturnPlayerName"/>
			<param name="playerid">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:GetPlayerPos" syntax="GetPlayerPos(playerid, &amp;x, &amp;y, &amp;z)">
			<attribute name="native"/>
			<referrer name="@_yCjoinfight"/>
			<param name="playerid">
			</param>
			<param name="x">
				<paraminfo>Float &amp; </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float &amp; </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float &amp; </paraminfo>
			</param>
		</member>
		<member name="M:GetPubVarAddressFromIndex" syntax="GetPubVarAddressFromIndex(index)">
			<stacksize value="7"/>
			<referrer name="GetPubVarAddressFromName"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetPubVarInfo"/>
			<param name="index">
			</param>
		</member>
		<member name="M:GetPubVarAddressFromName" syntax="GetPubVarAddressFromName(name[])">
			<stacksize value="4"/>
			<dependency name="GetPubVarAddressFromIndex"/>
			<dependency name="GetPubVarIndexFromName"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetPubVarIndexFromAddress" syntax="GetPubVarIndexFromAddress(address)">
			<stacksize value="7"/>
			<referrer name="GetPubVarNameFromAddress"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="GetNumPubVars"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="address">
			</param>
		</member>
		<member name="M:GetPubVarIndexFromName" syntax="GetPubVarIndexFromName(name[])">
			<stacksize value="10"/>
			<referrer name="GetPubVarAddressFromName"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="GetNumPubVars"/>
			<dependency name="NtCompare"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetPubVarInfo" syntax="GetPubVarInfo(index, info[])">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<referrer name="GetPubVarAddressFromIndex"/>
			<referrer name="GetPubVarNameFromIndex"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="GetNumPubVars"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="false"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="true"/>
			<param name="index">
			</param>
			<param name="info">
				<paraminfo> [2] </paraminfo>
			</param>
		</member>
		<member name="M:GetPubVarNameFromAddress" syntax="GetPubVarNameFromAddress(address, name[], size)">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<dependency name="GetPubVarIndexFromAddress"/>
			<dependency name="GetPubVarNameFromIndex"/>
			<param name="address">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetPubVarNameFromIndex" syntax="GetPubVarNameFromIndex(index, name[], size)">
			<tagname value="bool"/>
			<stacksize value="8"/>
			<referrer name="GetPubVarNameFromAddress"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="GetAmxHeaderComponent"/>
			<dependency name="GetPubVarInfo"/>
			<dependency name="NtCopy"/>
			<dependency name="false"/>
			<param name="index">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetPublicAddressFromIndex" syntax="GetPublicAddressFromIndex(index)">
			<stacksize value="7"/>
			<referrer name="GetPublicAddressFromName"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetPublicInfo"/>
			<param name="index">
			</param>
		</member>
		<member name="M:GetPublicAddressFromName" syntax="GetPublicAddressFromName(name[])">
			<stacksize value="4"/>
			<referrer name="AsmSetErrorHandlerName"/>
			<dependency name="GetPublicAddressFromIndex"/>
			<dependency name="GetPublicIndexFromName"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetPublicIndexFromAddress" syntax="GetPublicIndexFromAddress(address)">
			<stacksize value="7"/>
			<referrer name="GetPublicNameFromAddress"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanGetFuncName"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetNumPublics"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="address">
			</param>
		</member>
		<member name="M:GetPublicIndexFromName" syntax="GetPublicIndexFromName(name[])">
			<stacksize value="12"/>
			<referrer name="GetPublicAddressFromName"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetNumPublics"/>
			<dependency name="NtCompare"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetPublicInfo" syntax="GetPublicInfo(index, info[])">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<referrer name="GetPublicAddressFromIndex"/>
			<referrer name="GetPublicNameFromIndex"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetNumPublics"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="false"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="true"/>
			<param name="index">
			</param>
			<param name="info">
				<paraminfo> [2] </paraminfo>
			</param>
		</member>
		<member name="M:GetPublicNameFromAddress" syntax="GetPublicNameFromAddress(address, name[], size)">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<referrer name="PrintStackTrace"/>
			<dependency name="GetPublicIndexFromAddress"/>
			<dependency name="GetPublicNameFromIndex"/>
			<param name="address">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetPublicNameFromIndex" syntax="GetPublicNameFromIndex(index, name[], size)">
			<tagname value="bool"/>
			<stacksize value="8"/>
			<referrer name="GetPublicNameFromAddress"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanGetFuncName"/>
			<referrer name="ProfilerWriteData"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="GetAmxHeaderComponent"/>
			<dependency name="GetPublicInfo"/>
			<dependency name="NtCopy"/>
			<dependency name="false"/>
			<param name="index">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetRawAmxHeader" syntax="GetRawAmxHeader(plain_amxhdr[])">
			<stacksize value="6"/>
			<referrer name="GetAmxHeaderNow"/>
			<dependency name="ReadAmxMemory"/>
			<param name="plain_amxhdr">
				<paraminfo> [15] </paraminfo>
			</param>
		</member>
		<member name="M:GetStackTrace" syntax="GetStackTrace(trace[], skip, max)">
			<stacksize value="7"/>
			<dependency name="GetFramePreviousFrame"/>
			<dependency name="GetFrameReturn"/>
			<param name="trace">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="skip">
			</param>
			<param name="max">
			</param>
		</member>
		<member name="M:GetTagIDFromIndex" syntax="GetTagIDFromIndex(index)">
			<stacksize value="7"/>
			<referrer name="GetTagIDFromName"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetTagInfo"/>
			<param name="index">
			</param>
		</member>
		<member name="M:GetTagIDFromName" syntax="GetTagIDFromName(name[])">
			<stacksize value="4"/>
			<dependency name="GetTagIDFromIndex"/>
			<dependency name="GetTagIndexFromName"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetTagIndexFromID" syntax="GetTagIndexFromID(id)">
			<stacksize value="7"/>
			<referrer name="GetTagNameFromID"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_TAGS"/>
			<dependency name="GetNumTags"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="id">
			</param>
		</member>
		<member name="M:GetTagIndexFromName" syntax="GetTagIndexFromName(name[])">
			<stacksize value="10"/>
			<referrer name="GetTagIDFromName"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_TAGS"/>
			<dependency name="GetNumTags"/>
			<dependency name="NtCompare"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetTagInfo" syntax="GetTagInfo(index, info[])">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<referrer name="GetTagIDFromIndex"/>
			<referrer name="GetTagNameFromIndex"/>
			<referrer name="IsTagIndexStrong"/>
			<referrer name="IsTagIndexWeak"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_TAGS"/>
			<dependency name="GetNumTags"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="false"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="true"/>
			<param name="index">
			</param>
			<param name="info">
				<paraminfo> [2] </paraminfo>
			</param>
		</member>
		<member name="M:GetTagNameFromID" syntax="GetTagNameFromID(id, name[], size)">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<dependency name="GetTagIndexFromID"/>
			<dependency name="GetTagNameFromIndex"/>
			<dependency name="true"/>
			<param name="id">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetTagNameFromIndex" syntax="GetTagNameFromIndex(index, name[], size)">
			<tagname value="bool"/>
			<stacksize value="8"/>
			<referrer name="GetTagNameFromID"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="GetAmxHeaderComponent"/>
			<dependency name="GetTagInfo"/>
			<dependency name="NtCopy"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="index">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetVehicleModel" syntax="GetVehicleModel(vehicleid)">
			<attribute name="native"/>
			<referrer name="@yH_OnScriptInit@003"/>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:Group_ExclusiveCommand" syntax="Group_ExclusiveCommand(g, el)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Group_ExclusiveCommand@"/>
			<referrer name="Group_GlobalExclusiveCommand"/>
			<dependency name="Command_InitialiseFromGroups"/>
			<dependency name="H@"/>
			<dependency name="YSI_gTempGroups"/>
			<dependency name="YSI_g_cEmptyGroups"/>
			<dependency name="YSI_g_sDefaultMembership"/>
			<dependency name="YSI_g_sEmpty"/>
			<dependency name="cellbits"/>
			<param name="g">
				<paraminfo>Group </paraminfo>
				Group to add this to.
			</param>
			<param name="el">
				Element to add.
			</param>
			<summary>Group_Exclusive...</summary>      <remarks>  Add this element to ONLY this group and remove it from any others it might  already be in.  This is basically a simplified version of "GROUP_ADD".  </remarks> 
		</member>
		<member name="M:Group_ExclusiveCommand@" syntax="Group_ExclusiveCommand@(g, el)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="Group_ExclusiveCommand"/>
			<param name="g">
				<paraminfo>Group </paraminfo>
			</param>
			<param name="el">
			</param>
		</member>
		<member name="M:Group_FullPlayerUpdate" syntax="Group_FullPlayerUpdate(playerid, el, p[], c[], r[])">
			<stacksize value="6"/>
			<referrer name="Group_SetCommand"/>
			<referrer name="Group_SetCommandDefault"/>
			<referrer name="_yGUCommand"/>
			<dependency name="Command_SetPlayer"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="playerid">
				Player to check.
			</param>
			<param name="el">
				Element to show or hide.
			</param>
			<param name="p">
				<paraminfo>Bit [] </paraminfo>
			</param>
			<param name="c">
				<paraminfo>Bit [] </paraminfo>
			</param>
			<param name="r">
				<paraminfo>Bit [] </paraminfo>
			</param>
			    <param name="previous">(p) The old state of affairs.</param>  <param name="current">(c) The new state of affairs.</param>  <param name="reference">(r) What to compare changes to.</param>  <remarks>  I did have a good reason for calling this "FU", but I forgot it!  Anyway,  the state of some groups has changed - either a player's groups or an  elements groups have changed.  If the player could previously see the  element but now can't, hide it.  If the player previously couldn't see it  but now can, show it.  If there is no change do nothing.  The old version of  this library would just re-show the element even if they could already see  it, but this was a bad design as it could incur large overheads in other  libraries when they had to do IO to enable or disable something for a  player.  The change can be in either the player's groups or the element's groups,  either way this code will work regardless.  </remarks> 
		</member>
		<member name="M:Group_GetCommand" syntax="Group_GetCommand(g, el)">
			<tagname value="bool"/>
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Group_GetCommand@"/>
			<referrer name="Group_GetGlobalCommand"/>
			<dependency name="H@"/>
			<dependency name="YSI_g_sElementMembership"/>
			<dependency name="cellbits"/>
			<param name="g">
				<paraminfo>Group </paraminfo>
				Group to get from.
			</param>
			<param name="el">
				Element to get.
			</param>
			<summary>Group_Get...</summary>      <returns>  bool: Does the group have the element?  </returns> 
		</member>
		<member name="M:Group_GetCommand@" syntax="Group_GetCommand@(g, el)">
			<tagname value="bool"/>
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="Group_GetCommand"/>
			<param name="g">
				<paraminfo>Group </paraminfo>
			</param>
			<param name="el">
			</param>
		</member>
		<member name="M:Group_GetGlobalCommand" syntax="Group_GetGlobalCommand(el)">
			<tagname value="bool"/>
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Group_GetGlobalCommand@"/>
			<dependency name="Group_GetCommand"/>
			<dependency name="H@"/>
			<param name="el">
				Element to get.
			</param>
			<summary>Group_GetGlobal...</summary>    <returns>  bool: Does the global group have the element?  </returns> 
		</member>
		<member name="M:Group_GetGlobalCommand@" syntax="Group_GetGlobalCommand@(el)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="Group_GetGlobalCommand"/>
			<param name="el">
			</param>
		</member>
		<member name="M:Group_GlobalExclusiveCommand" syntax="Group_GlobalExclusiveCommand(el)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Group_GlobalExclusiveCommand@"/>
			<dependency name="Group_ExclusiveCommand"/>
			<dependency name="H@"/>
			<param name="el">
				Element to add.
			</param>
			<summary>Group_GlobalExclusive...</summary>    <remarks>  Add this element to ONLY the global group and remove it from any others it  might already be in.  </remarks> 
		</member>
		<member name="M:Group_GlobalExclusiveCommand@" syntax="Group_GlobalExclusiveCommand@(el)">
			<stacksize value="4"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="Group_GlobalExclusiveCommand"/>
			<param name="el">
			</param>
		</member>
		<member name="M:Group_Handoff" syntax="Group_Handoff(i, a[], s)">
			<stacksize value="7"/>
			<referrer name="HANDOFF_SOURCE@_Group"/>
			<dependency name="YSI_g_sDefaultMembership"/>
			<dependency name="YSI_g_sElementMembership"/>
			<dependency name="cellbits"/>
			<dependency name="memcpy"/>
			<dependency name="min"/>
			<param name="i">
			</param>
			<param name="a">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="s">
			</param>
		</member>
		<member name="M:Group_SetCommand" syntax="Group_SetCommand(g, el, s)">
			<stacksize value="11"/>
			<automaton name="@_"/>
			<referrer name="Group_SetCommand@"/>
			<referrer name="Group_SetGlobalCommand"/>
			<dependency name="Group_FullPlayerUpdate"/>
			<dependency name="H@"/>
			<dependency name="Iterator@Player"/>
			<dependency name="YSI_gGroupPlayers"/>
			<dependency name="YSI_gTempGroups"/>
			<dependency name="YSI_g_sElementMembership"/>
			<dependency name="YSI_g_sElementMembership"/>
			<dependency name="cellbits"/>
			<param name="g">
				<paraminfo>Group </paraminfo>
				Group to set for.
			</param>
			<param name="el">
				Element to set.
			</param>
			<param name="s">
				<paraminfo>bool </paraminfo>
				Set or unset?
			</param>
			<summary>Group_Set...</summary>        <remarks>  If "s" is true, then one element is added to the current group.  False it is  removed.  </remarks> 
		</member>
		<member name="M:Group_SetCommand@" syntax="Group_SetCommand@(g, el, s)">
			<stacksize value="6"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="Group_SetCommand"/>
			<param name="g">
				<paraminfo>Group </paraminfo>
			</param>
			<param name="el">
			</param>
			<param name="s">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Group_SetCommandDefault" syntax="Group_SetCommandDefault(g, s)">
			<stacksize value="1014"/>
			<automaton name="@_"/>
			<referrer name="Group_SetCommandDefault@"/>
			<referrer name="Group_SetGlobalCommandDefault"/>
			<dependency name="Group_FullPlayerUpdate"/>
			<dependency name="H@"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iterator@Player"/>
			<dependency name="YSI_gGroupPlayers"/>
			<dependency name="YSI_g_sDefaultMembership"/>
			<dependency name="YSI_g_sElementMembership"/>
			<dependency name="YSI_g_sElementMembership"/>
			<dependency name="YSI_g_sMaxEncountered"/>
			<dependency name="cellbits"/>
			<param name="g">
				<paraminfo>Group </paraminfo>
				Group to set for.
			</param>
			<param name="s">
				<paraminfo>bool </paraminfo>
				Set or unset?
			</param>
			<summary>Group_Set...Default</summary>      <remarks>  If "s" is true, then all elements are added to this group (i.e. the default  is set to true and all previous settings are wiped out).  If it is false  then all elements are removed and a full update is done.  </remarks> 
		</member>
		<member name="M:Group_SetCommandDefault@" syntax="Group_SetCommandDefault@(g, s)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="Group_SetCommandDefault"/>
			<param name="g">
				<paraminfo>Group </paraminfo>
			</param>
			<param name="s">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Group_SetCommandNew" syntax="Group_SetCommandNew(g, s)">
			<stacksize value="6"/>
			<automaton name="@_"/>
			<referrer name="Group_SetCommandNew@"/>
			<referrer name="Group_SetGlobalCommandNew"/>
			<dependency name="Bit_Set"/>
			<dependency name="H@"/>
			<dependency name="YSI_g_sDefaultMembership"/>
			<param name="g">
				<paraminfo>Group </paraminfo>
				Group to set for.
			</param>
			<param name="s">
				<paraminfo>bool </paraminfo>
				Set or unset?
			</param>
			<summary>Group_Set...New</summary>      <remarks>  Similar to "Group_Set...Default", but doesn't reset all existing elements,  just sets the permissions for any future items.  </remarks> 
		</member>
		<member name="M:Group_SetCommandNew@" syntax="Group_SetCommandNew@(g, s)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="Group_SetCommandNew"/>
			<param name="g">
				<paraminfo>Group </paraminfo>
			</param>
			<param name="s">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Group_SetGlobalCommand" syntax="Group_SetGlobalCommand(el, s)">
			<stacksize value="6"/>
			<automaton name="@_"/>
			<referrer name="Group_SetGlobalCommand@"/>
			<dependency name="Group_SetCommand"/>
			<dependency name="H@"/>
			<param name="el">
				Element to set.
			</param>
			<param name="s">
				<paraminfo>bool </paraminfo>
				Set or unset?
			</param>
			<summary>Group_SetGlobal...</summary>      <remarks>  If "s" is true, then one element is added to the global group.  False it is  removed.  </remarks> 
		</member>
		<member name="M:Group_SetGlobalCommand@" syntax="Group_SetGlobalCommand@(el, s)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="Group_SetGlobalCommand"/>
			<param name="el">
			</param>
			<param name="s">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Group_SetGlobalCommandDefault" syntax="Group_SetGlobalCommandDefault(s)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Group_SetGlobalCommandDefault@"/>
			<dependency name="Group_SetCommandDefault"/>
			<dependency name="H@"/>
			<param name="s">
				<paraminfo>bool </paraminfo>
				Set or unset?
			</param>
			<summary>Group_SetGlobal...Default</summary>    <remarks>  If "s" is true, then all elements are added to the global group (i.e. the  default is set to true and all previous settings are wiped out).  If it is  false then all elements are removed and a full update is done.  </remarks> 
		</member>
		<member name="M:Group_SetGlobalCommandDefault@" syntax="Group_SetGlobalCommandDefault@(s)">
			<stacksize value="4"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="Group_SetGlobalCommandDefault"/>
			<param name="s">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Group_SetGlobalCommandNew" syntax="Group_SetGlobalCommandNew(s)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="Group_SetGlobalCommandNew@"/>
			<dependency name="Group_SetCommandNew"/>
			<dependency name="H@"/>
			<param name="s">
				<paraminfo>bool </paraminfo>
				Set or unset?
			</param>
			<summary>Group_SetGlobal...New</summary>    <remarks>  All elements created FROM THIS POINT ON will have this default setting.  </remarks> 
		</member>
		<member name="M:Group_SetGlobalCommandNew@" syntax="Group_SetGlobalCommandNew@(s)">
			<stacksize value="4"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="Group_SetGlobalCommandNew"/>
			<param name="s">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:H@" syntax="H@(...)">
			<stacksize value="1"/>
			<referrer name="Group_SetCommand"/>
			<referrer name="Group_GetCommand"/>
			<referrer name="Group_SetCommandDefault"/>
			<referrer name="Group_SetCommandNew"/>
			<referrer name="Group_ExclusiveCommand"/>
			<referrer name="Group_SetGlobalCommand"/>
			<referrer name="Group_GetGlobalCommand"/>
			<referrer name="Group_SetGlobalCommandDefault"/>
			<referrer name="Group_SetGlobalCommandNew"/>
			<referrer name="Group_GlobalExclusiveCommand"/>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:HANDOFF_SOURCE@_" syntax="HANDOFF_SOURCE@_()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="@_"/>
			<dependency name="YSI_g_sCommandFlags_Dist"/>
			<dependency name="YSI_g_sCommands_Dist"/>
			<dependency name="YSI_g_sDisabledPlayers_Dist"/>
			<dependency name="YSI_g_sErrorMessages_Dist"/>
			<dependency name="_Command_Rebuild"/>
			<remarks>  Passes additional commands data to the new master.  </remarks> 
		</member>
		<member name="M:HANDOFF_SOURCE@_Group" syntax="HANDOFF_SOURCE@_Group()">
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="Group_Handoff"/>
			<dependency name="YSI_g_sDefaultMembership"/>
			<dependency name="YSI_g_sElementMembership"/>
		</member>
		<member name="M:HashMap_Add" syntax="HashMap_Add(m[], str[], value, ignorecase)">
			<tagname value="bool"/>
			<stacksize value="8"/>
			<referrer name="HashMap_Set"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="_Command_Rebuild"/>
			<referrer name="Command_Add"/>
			<dependency name="AMX_Write"/>
			<dependency name="Debug_Print0"/>
			<dependency name="YHash"/>
			<dependency name="false"/>
			<dependency name="rawMemcpy"/>
			<dependency name="ref"/>
			<dependency name="strcmp"/>
			<dependency name="true"/>
			<param name="m">
				<paraminfo> [260] </paraminfo>
				
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
				
			</param>
			<param name="value">
				More like the target slot.
			</param>
			<param name="ignorecase">
				<paraminfo>bool </paraminfo>
			</param>
			      <remarks>  Adds a value to the given hash map under the given string key.  Actually more like adding an index, not a value...  </remarks> 
		</member>
		<member name="M:HashMap_Get" syntax="HashMap_Get(m[], str[], ignorecase)">
			<stacksize value="10"/>
			<referrer name="Command_Find"/>
			<dependency name="HashMap_GetWithHash"/>
			<dependency name="YHash"/>
			<param name="m">
				<paraminfo> [260] </paraminfo>
				The hash map to search.
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The key to find.
			</param>
			<param name="ignorecase">
				<paraminfo>bool </paraminfo>
			</param>
			    <returns>  The value associated with this key in the given hash map.  </returns> 
		</member>
		<member name="M:HashMap_GetBranchEnd" syntax="HashMap_GetBranchEnd(cur, &amp;height, &amp;parent, dir)">
			<stacksize value="4"/>
			<referrer name="HashMap_RemoveKeyWithHash"/>
			<dependency name="AMX_Read"/>
			<param name="cur">
			</param>
			<param name="height">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="parent">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="dir">
			</param>
		</member>
		<member name="M:HashMap_GetWithHash" syntax="HashMap_GetWithHash(m[], str[], hash, ignorecase)">
			<stacksize value="5"/>
			<referrer name="HashMap_Get"/>
			<referrer name="Command_ReProcess"/>
			<dependency name="ref"/>
			<dependency name="strcmp"/>
			<param name="m">
				<paraminfo> [260] </paraminfo>
				The hash map to search.
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The key to find.
			</param>
			<param name="hash">
				The hashed key.
			</param>
			<param name="ignorecase">
				<paraminfo>bool </paraminfo>
			</param>
			      <returns>  The value associated with this key in the given hash map.  </returns> 
		</member>
		<member name="M:HashMap_RemoveKey" syntax="HashMap_RemoveKey(m[], str[], ignorecase)">
			<tagname value="bool"/>
			<stacksize value="10"/>
			<referrer name="HashMap_RemoveValue"/>
			<referrer name="HashMap_Set"/>
			<dependency name="HashMap_RemoveKeyWithHash"/>
			<dependency name="YHash"/>
			<param name="m">
				<paraminfo> [260] </paraminfo>
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="ignorecase">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:HashMap_RemoveKeyWithHash" syntax="HashMap_RemoveKeyWithHash(m[], str[], hash, ignorecase)">
			<tagname value="bool"/>
			<stacksize value="17"/>
			<referrer name="HashMap_RemoveKey"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="HashMap_GetBranchEnd"/>
			<dependency name="false"/>
			<dependency name="ref"/>
			<dependency name="strcmp"/>
			<dependency name="true"/>
			<param name="m">
				<paraminfo> [260] </paraminfo>
				The hash map to modify.
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The key to remove from the hash map.
			</param>
			<param name="hash">
			</param>
			<param name="ignorecase">
				<paraminfo>bool </paraminfo>
			</param>
			    <remarks>  Removes a given key and its associated value from the given hash map (if it  can be found in the map in the first place).  </remarks> 
		</member>
		<member name="M:HashMap_RemoveValue" syntax="HashMap_RemoveValue(m[], value)">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<referrer name="HashMap_Set"/>
			<referrer name="Command_Remove"/>
			<dependency name="HashMap_RemoveKey"/>
			<dependency name="false"/>
			<dependency name="min"/>
			<dependency name="rawMemcpy"/>
			<dependency name="ref"/>
			<param name="m">
				<paraminfo> [260] </paraminfo>
				Hash map to modify.
			</param>
			<param name="value">
				Value to remove.
			</param>
			    <remarks>  Removes a value from the hash map.  First it gets the string key for the  value, then removes that (to update associated linked lists correctly).  </remarks> 
		</member>
		<member name="M:HashMap_Set" syntax="HashMap_Set(m[], str[], value)">
			<stacksize value="7"/>
			<dependency name="HashMap_Add"/>
			<dependency name="HashMap_RemoveKey"/>
			<dependency name="HashMap_RemoveValue"/>
			<param name="m">
				<paraminfo> [260] </paraminfo>
				The hash map to modify.
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The key to modify.
			</param>
			<param name="value">
				The new value for the given key.
			</param>
			      <remarks>  If this key is already in the hash map it is removed, and then the new value  is added in its place.  If the string already exists, its associated data is  removed.  If the value already exists, it is removed as well.  </remarks> 
		</member>
		<member name="M:HaveToRelocateOpcodes" syntax="HaveToRelocateOpcodes()">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="RelocateOpcodeNow"/>
			<dependency name="OP_CALL"/>
			<dependency name="ReadOpcodeNearThis"/>
		</member>
		<member name="M:HeapAllocBytes" syntax="HeapAllocBytes(nbytes)">
			<stacksize value="2"/>
			<referrer name="HeapAllocCells"/>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:HeapAllocCells" syntax="HeapAllocCells(ncells)">
			<stacksize value="4"/>
			<dependency name="HeapAllocBytes"/>
			<param name="ncells">
			</param>
		</member>
		<member name="M:HeapRelease" syntax="HeapRelease(address)">
			<stacksize value="1"/>
			<param name="address">
			</param>
		</member>
		<member name="M:HookChain_OnScriptInit" syntax="HookChain_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="8"/>
			<automaton name="_ALS"/>
			<referrer name="VA_OnScriptInit"/>
			<dependency name="CallLocalFunction"/>
			<dependency name="CallRemoteFunction"/>
			<dependency name="Master_OnScriptInit"/>
			<dependency name="_@"/>
			<dependency name="existproperty"/>
			<dependency name="getproperty"/>
			<dependency name="setproperty"/>
			<returns>  OnScriptInit  </returns>  <remarks>  Constructor.  Gets the script a master ID.  Now ALWAYS gets an ID, even if  the master system is disabled - doing otherwise is just too complicated.  </remarks>  <transition keep="true" target="_ALS : _ALS_go" />  <transition target="x>a" source="_ALS_go"/>

		</member>
		<member name="M:HookNative" syntax="HookNative(index, address)">
			<stacksize value="8"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="GetNumNatives"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="WriteAmxMemory"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="index">
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:HookPublic" syntax="HookPublic(index, address)">
			<stacksize value="8"/>
			<referrer name="ProfilerInit"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetNumPublics"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="WriteAmxMemory"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="index">
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:Hooks_Collate" syntax="Hooks_Collate(preloads[][], precount, name[], idx)">
			<stacksize value="18"/>
			<referrer name="Hooks_DoAllHooks"/>
			<dependency name="Hooks_GenerateCode"/>
			<dependency name="Hooks_GetAllHooks"/>
			<dependency name="Hooks_GetPointerRewrite"/>
			<dependency name="Hooks_GetPreHooks"/>
			<dependency name="Hooks_IsolateName"/>
			<dependency name="Hooks_MakeLongName"/>
			<dependency name="strlen"/>
			<dependency name="strunpack"/>
			<param name="preloads">
				<paraminfo> [][17] </paraminfo>
			</param>
			<param name="precount">
			</param>
			<param name="name">
				<paraminfo> [32] </paraminfo>
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:Hooks_CompareNextCell" syntax="Hooks_CompareNextCell(addr0, addr1)">
			<stacksize value="6"/>
			<referrer name="Hooks_ComparePublics"/>
			<dependency name="AMX_Read"/>
			<dependency name="Cell_ReverseBytes"/>
			<param name="addr0">
				The 1st address to read.
			</param>
			<param name="addr1">
				The 2nd address to read.
			</param>
			    <returns>  -1 - The first address is bigger.  0  - The addresses are the same  1  - The second address is bigger.  </returns>  <remarks>  Reads two addresses, converts them to big endian, and compares them as four  characters of a string at once.  </remarks> 
		</member>
		<member name="M:Hooks_ComparePublics" syntax="Hooks_ComparePublics(idx0, idx1)">
			<stacksize value="9"/>
			<referrer name="Hooks_SortPublics"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="Hooks_CompareNextCell"/>
			<param name="idx0">
				The index of the 1st public.
			</param>
			<param name="idx1">
				The index of the 2nd public.
			</param>
			    <remarks>  Compares two public function entries, and if need-be, swaps them over.  </remarks> 
		</member>
		<member name="M:Hooks_CountInvalidPublics" syntax="Hooks_CountInvalidPublics()">
			<stacksize value="10"/>
			<referrer name="Hooks_SortPublics"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<remarks>  Counts the number of public functions that have had their names erased.  </remarks> 
		</member>
		<member name="M:Hooks_DoAllHooks" syntax="Hooks_DoAllHooks()">
			<stacksize value="185"/>
			<referrer name="VA_OnScriptInit"/>
			<dependency name="AMX_GetNamePrefix"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="E_PRE_HOOK"/>
			<dependency name="Hooks_Collate"/>
			<dependency name="Hooks_GetPreloadLibraries"/>
			<dependency name="Hooks_SortPublics"/>
		</member>
		<member name="M:Hooks_GenerateCode" syntax="Hooks_GenerateCode(name[], hooks[], count, write, hasprehooks)">
			<stacksize value="7"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_REAL_DATA"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="CGen_AddCodeSpace"/>
			<dependency name="CGen_GetCodeSpace"/>
			<dependency name="Hooks_GetDefaultReturn"/>
			<dependency name="Hooks_WriteFunction"/>
			<param name="name">
				<paraminfo> [64] </paraminfo>
				Name of the function to generate.
			</param>
			<param name="hooks">
				<paraminfo> [] </paraminfo>
				All the functions to call.
			</param>
			<param name="count">
				Number of functions to call.
			</param>
			<param name="write">
				Where to write the new function's pointer.
			</param>
			<param name="hasprehooks">
				<paraminfo>bool </paraminfo>
				Needs to call other stuff first.
			</param>
			         
		</member>
		<member name="M:Hooks_GetAllHooks" syntax="Hooks_GetAllHooks(name[], hooks[], idx, &amp;namelen)">
			<stacksize value="73"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<dependency name="AMX_GetStringFromEntry"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="Debug_Print0"/>
			<dependency name="Hooks_InvalidateName"/>
			<dependency name="Hooks_IsolateName"/>
			<dependency name="Hooks_MakeLongName"/>
			<dependency name="strcmp"/>
			<dependency name="strlen"/>
			<dependency name="strunpack"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The name of the callback (with y_hooks prefix).
			</param>
			<param name="hooks">
				<paraminfo> [128] </paraminfo>
				Array in which to store the function headers.
			</param>
			<param name="idx">
				Current position in the AMX header.
			</param>
			<param name="namelen">
				<paraminfo> &amp; </paraminfo>
				Min bound of space used by all these names.
			</param>
			        <returns>  The number of hooks found.  </returns>  <remarks>  The name of the function currently being processed is derived from the first  found hook.  This means we already know of one hook, but to simplify the  code we get that one again here.  Above we only know the name not the  address.  Hence the "- 1" in "i = idx - 1" (to go back one function name).  Our "namelen" variable already contains the full length of the first found  hook - this is the length of "name", plus N extra characters.  The following  are all valid, and may occur when orders are played with:  @yH_OnX@  @yH_OnX@1  @yH_OnX@01  @yH_OnX@024  @yH_OnX@ZZZ  @yH_OnX@999@024  If we want to get the EXACT space taken up by all these hook names we would  need to get the string of the name in this function then measure it.  There  is really no point in doing this - if we have a second we will always have  enough space for our new names.  Instead, we assume that they are all just  @yH_OnX@  And add on that minimum length accordingly (plus 1 for the NULL character).  This length is used if the original callback doesn't exist but hooks do.  In  that case we need to add the callback to the AMX header, and there is a tiny  chance that the original name will be longer than one hook's name.  In that  case, having two or more hooks will (AFAIK) always ensure that we have  enough space to write the longer name.  If there is only one hook, no original function, and the name of the hook is  shorter than the name of the original function then we have an issue and  will have to do something else instead.  </remarks> 
		</member>
		<member name="M:Hooks_GetDefaultReturn" syntax="Hooks_GetDefaultReturn(name[])">
			<stacksize value="9"/>
			<referrer name="Hooks_GenerateCode"/>
			<dependency name="AMX_GetEntry"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="CallFunction"/>
			<dependency name="Hooks_MakeShortName"/>
			<dependency name="strins"/>
			<dependency name="true"/>
			<param name="name">
				<paraminfo> [64] </paraminfo>
				The function to get the default return of.
			</param>
			  <returns>  The default return for a callback, normally 1.  </returns> 
		</member>
		<member name="M:Hooks_GetFunctionWritePoint" syntax="Hooks_GetFunctionWritePoint(name[], &amp;write)">
			<stacksize value="8"/>
			<dependency name="AMX_GetEntry"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="true"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The function to get the address pointer of.
			</param>
			<param name="write">
				<paraminfo> &amp; </paraminfo>
				Destination variable.
			</param>
			    <returns>  The address at which this function's pointer is stored in the AMX header, if  the function exists of course.  </returns> 
		</member>
		<member name="M:Hooks_GetPointerRewrite" syntax="Hooks_GetPointerRewrite(hooks[], num, &amp;ptr, &amp;next, name[], nlen)">
			<stacksize value="39"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_REAL_DATA"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="AMX_WriteString"/>
			<dependency name="Debug_Print0"/>
			<dependency name="Hooks_GetStubEntry"/>
			<dependency name="OP_JUMP"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="strlen"/>
			<dependency name="strpack"/>
			<param name="hooks">
				<paraminfo> [] </paraminfo>
				All the prehooks for this callback.
			</param>
			<param name="num">
				The number of prehooks.
			</param>
			<param name="ptr">
				<paraminfo> &amp; </paraminfo>
				A pointer to write the new stub address to.
			</param>
			<param name="next">
				<paraminfo> &amp; </paraminfo>
				The pointer for the function called after y_hooks.
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The name of the callback being processed.
			</param>
			<param name="nlen">
				Space available in the header to write text in.
			</param>
			           
		</member>
		<member name="M:Hooks_GetPreHooks" syntax="Hooks_GetPreHooks(preloads[][], precount, name[], hooks[], &amp;count)">
			<stacksize value="73"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="AMX_GetEntry"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="E_PRE_HOOK_NAME"/>
			<dependency name="Hooks_MakeShortName"/>
			<dependency name="strcat"/>
			<dependency name="true"/>
			<param name="preloads">
				<paraminfo> [][17] </paraminfo>
				Names of libraries that come before y_hooks.
			</param>
			<param name="precount">
				Number of pre libraries.
			</param>
			<param name="name">
				<paraminfo> [64] </paraminfo>
				Name of the callback.
			</param>
			<param name="hooks">
				<paraminfo> [] </paraminfo>
				Destination in which to store the headers.
			</param>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
				Number of headers found.
			</param>
			          <remarks>  Finds all the AMX file headers for functions with a similar name to the  given callback that should be called before (or near) the given callback.  </remarks> 
		</member>
		<member name="M:Hooks_GetPreloadLibraries" syntax="Hooks_GetPreloadLibraries(preloads[][], &amp;precount, size)">
			<stacksize value="20"/>
			<referrer name="Hooks_DoAllHooks"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_ReadString"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="CallFunction"/>
			<dependency name="Debug_Print0"/>
			<dependency name="E_PRE_HOOK"/>
			<dependency name="E_PRE_HOOK_NAME"/>
			<dependency name="E_PRE_HOOK_VALUE"/>
			<dependency name="Hooks_InvalidateName"/>
			<dependency name="strunpack"/>
			<param name="preloads">
				<paraminfo> [][17] </paraminfo>
				Desination in which to store all the preloads.
			</param>
			<param name="precount">
				<paraminfo> &amp; </paraminfo>
				Number of found preload libraries.
			</param>
			<param name="size">
				Maximum number of libraries to store.
			</param>
			      <remarks>  Some includes, like "fixes.inc" and anti-cheats MUST come before all other  includes in order for everything to function correctly (at least fixes.inc  must).  This function looks for these definitions:  PRE_HOOK(FIXES)  Which tell y_hooks that any "FIXES_" prefixed callbacks are part of one of  these chains.  </remarks> 
		</member>
		<member name="M:Hooks_GetStubEntry" syntax="Hooks_GetStubEntry(stub)">
			<stacksize value="13"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<dependency name="Debug_Print0"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmGetNumOperands"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmInit"/>
			<dependency name="DisasmNextInsn"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_JUMP"/>
			<dependency name="OP_LOAD_PRI"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_SWITCH"/>
			<param name="stub">
				Starting address of the function.
			</param>
			  <returns>  The address at which the actual code in this function starts.  </returns>  <remarks>  This handles three cases.  Regular functions end instantly as found.  Functions that start with a switch (even before "PROC") are assumed to be  state-based functions, and we find the most likely state to be used (i.e. we  remove all future state changes).  </remarks> 
		</member>
		<member name="M:Hooks_InvalidateName" syntax="Hooks_InvalidateName(entry)">
			<stacksize value="5"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="VA_OnScriptInit"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<param name="entry">
				The public function slot to destroy.
			</param>
			  <remarks>  Basically, once we know a function has been included, wipe it from the AMX  header.  </remarks> 
		</member>
		<member name="M:Hooks_IsolateName" syntax="Hooks_IsolateName(name[])">
			<stacksize value="152"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="Debug_Print0"/>
			<dependency name="false"/>
			<dependency name="strdel"/>
			<dependency name="strfind"/>
			<dependency name="unpack"/>
			<dependency name="unpack"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The string to get the hooked function name from.
			</param>
			  <returns>  The input string without y_hooks name decorations.  </returns> 
		</member>
		<member name="M:Hooks_MakeLongName" syntax="Hooks_MakeLongName(name[])">
			<stacksize value="10"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_LONG"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MAX"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MIN"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_SHORT"/>
			<dependency name="Hooks_MakeShortName"/>
			<dependency name="YSI_g_sReplacePtr"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacementsShortOrder"/>
			<dependency name="false"/>
			<dependency name="strdel"/>
			<dependency name="strfind"/>
			<dependency name="strins"/>
			<param name="name">
				<paraminfo> [64] </paraminfo>
				Function name to modify.
			</param>
			  <remarks>  Expands all name parts like "CP" and "Obj" to their full versions (in this  example "Checkpoint" and "Object").  </remarks> 
		</member>
		<member name="M:Hooks_MakeShortName" syntax="Hooks_MakeShortName(name[])">
			<stacksize value="10"/>
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_GetPreHooks"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_LONG"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MAX"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_SHORT"/>
			<dependency name="YSI_g_sReplacePtr"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacementsLongOrder"/>
			<dependency name="false"/>
			<dependency name="strdel"/>
			<dependency name="strfind"/>
			<dependency name="strins"/>
			<dependency name="strlen"/>
			<param name="name">
				<paraminfo> [64] </paraminfo>
				Function name to modify.
			</param>
			  <remarks>  Compresses function names when required to fit within 32 characters  according to well defined rules (see "YSI_g_sReplacements").  </remarks> 
		</member>
		<member name="M:Hooks_NumArgs" syntax="Hooks_NumArgs()">
			<stacksize value="1"/>
			<referrer name="Iter_Random_Internal"/>
			<referrer name="Distribute_Do"/>
			<referrer name="Distribute_So"/>
			<referrer name="Distribute_To"/>
		</member>
		<member name="M:Hooks_SortPublics" syntax="Hooks_SortPublics()">
			<stacksize value="9"/>
			<referrer name="Hooks_DoAllHooks"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_HEADER_NATIVES"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="Hooks_ComparePublics"/>
			<dependency name="Hooks_CountInvalidPublics"/>
			<dependency name="ResetStaticAmxHeader"/>
			<remarks>  Goes through the whole of the public functions table and sorts them all in  to alphabetical order.  This is done as we move and rename some so we need  to fix the virtual machine's binary search.  </remarks> 
		</member>
		<member name="M:Hooks_SortReplacements" syntax="Hooks_SortReplacements()">
			<stacksize value="6"/>
			<referrer name="VA_OnScriptInit"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MAX"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MIN"/>
			<dependency name="YSI_g_sReplacePtr"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacementsLongOrder"/>
			<dependency name="YSI_g_sReplacementsShortOrder"/>
			<remarks>  Once all the replacement strings have been found, sort them by the length of  the short versions of the strings.  This is so that the longest (and special  case, e.g. "DynamicCP"-> "DynamicCP") replacements are always done first.  </remarks> 
		</member>
		<member name="M:Hooks_WriteFunction" syntax="Hooks_WriteFunction(pointers[], size, ret, skipable)">
			<stacksize value="29"/>
			<referrer name="Hooks_GenerateCode"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_REAL_ADDRESS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmEmitAddC"/>
			<dependency name="AsmEmitAnd"/>
			<dependency name="AsmEmitCall"/>
			<dependency name="AsmEmitInvert"/>
			<dependency name="AsmEmitJsgeqRel"/>
			<dependency name="AsmEmitJslessRel"/>
			<dependency name="AsmEmitJumpRel"/>
			<dependency name="AsmEmitLctrl"/>
			<dependency name="AsmEmitLoadSAlt"/>
			<dependency name="AsmEmitMoveAlt"/>
			<dependency name="AsmEmitMovePri"/>
			<dependency name="AsmEmitMovs"/>
			<dependency name="AsmEmitOr"/>
			<dependency name="AsmEmitProc"/>
			<dependency name="AsmEmitPushC"/>
			<dependency name="AsmEmitRetn"/>
			<dependency name="AsmEmitSctrl"/>
			<dependency name="AsmEmitStorPri"/>
			<dependency name="AsmEmitStorSPri"/>
			<dependency name="AsmEmitSub"/>
			<dependency name="AsmEmitXchg"/>
			<dependency name="AsmEmitZeroAlt"/>
			<dependency name="CGen_GetCodeSpace"/>
			<dependency name="CGen_UseCodeSpace"/>
			<dependency name="Debug_Print0"/>
			<param name="pointers">
				<paraminfo> [] </paraminfo>
				The hooks to link together.
			</param>
			<param name="size">
				The number of functions in the array.
			</param>
			<param name="ret">
				The default return.
			</param>
			<param name="skipable">
				Can future hooks be ignored on -1?
			</param>
			        <returns>  The number of bytes written to memory.  </returns>  <remarks>  Generate some new code, very nicely :D.  </remarks> 
		</member>
		<member name="M:IPToInt" syntax="IPToInt(ip[])">
			<stacksize value="5"/>
			<referrer name="OnPlayerConnect"/>
			<dependency name="strval"/>
			<param name="ip">
				<paraminfo> [] </paraminfo>
				Dot notation IP to convert to an integer.
			</param>
			 
		</member>
		<member name="M:InitOpcodeTable" syntax="InitOpcodeTable()">
			<stacksize value="5"/>
			<referrer name="RelocateOpcode"/>
			<referrer name="UnrelocateOpcode"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="RelocateOpcodeNow"/>
			<dependency name="opcode_table"/>
			<dependency name="opcode_table_is_ready"/>
			<dependency name="true"/>
		</member>
		<member name="M:InterpolateColour" syntax="InterpolateColour(startcolor, endcolor, value, maxvalue, minvalue)">
			<stacksize value="3"/>
			<param name="startcolor">
				One of the two colours.
			</param>
			<param name="endcolor">
				The other of the two colours.
			</param>
			<param name="value">
				The interpolation value between the endpoints.
			</param>
			<param name="maxvalue">
				One of the two numbers.
			</param>
			<param name="minvalue">
				The other of the two numbers.
			</param>
			<summary>  InterpolateColour(startcolor, endcolor, value, maxvalue, minvalue = 0);  </summary>            <remarks>  This function takes two endpoint values (minvalue and maxvalue, with  minvalue defaulting to 0), along with a third value (value) whose distance  between the two endpoints is calculated (as a percentage).  This percentage  value is then applied to the two colours given to find a third colour at  some point between those two colours.  For example, if the endpoints given are "0" and "10", and the value given is  "3", then that is "30%" of the way between the two endpoints.  We therefore  want to find a colour that is 30% of the way between the two given colours.  </remarks> 
		</member>
		<member name="M:IsKeyJustDown" syntax="IsKeyJustDown(key, newkeys, oldkeys)">
			<stacksize value="1"/>
			<param name="key">
			</param>
			<param name="newkeys">
			</param>
			<param name="oldkeys">
			</param>
		</member>
		<member name="M:IsLinux" syntax="IsLinux()">
			<tagname value="bool"/>
			<stacksize value="3"/>
			<dependency name="GetOS"/>
			<dependency name="OS_LINUX"/>
		</member>
		<member name="M:IsOpcodeValid" syntax="IsOpcodeValid(opcode)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="AsmEmitPadding"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:IsPlayerConnected" syntax="IsPlayerConnected(playerid)">
			<attribute name="native"/>
			<referrer name="PlaySoundForAll"/>
			<referrer name="PlaySoundForPlayersInRange"/>
			<referrer name="ReturnUser"/>
			<referrer name="@yH_OnScriptInit@003"/>
			<referrer name="Iter_OPDCInternal"/>
			<referrer name="Iter_Func@PA"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="OnPlayerUpdate"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:IsPlayerInRangeOfPoint" syntax="IsPlayerInRangeOfPoint(playerid, range, x, y, z)">
			<attribute name="native"/>
			<referrer name="PlaySoundForPlayersInRange"/>
			<param name="playerid">
			</param>
			<param name="range">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:IsPlayerNPC" syntax="IsPlayerNPC(playerid)">
			<attribute name="native"/>
			<referrer name="@yH_OnScriptInit@003"/>
			<referrer name="@yH_OnPlayerConnect@003"/>
			<referrer name="Iter_OPDCInternal"/>
			<referrer name="OnPlayerSpawn"/>
			<referrer name="OnPlayerRequestClass"/>
			<referrer name="OnPlayerUpdate"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:IsPrintableAscii" syntax="IsPrintableAscii(c)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="ToPrintableAscii"/>
			<param name="c">
			</param>
		</member>
		<member name="M:IsTagIDEmpty" syntax="IsTagIDEmpty(tag)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagIDStrong" syntax="IsTagIDStrong(tag)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="IsTagIndexStrong"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagIDWeak" syntax="IsTagIDWeak(tag)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="IsTagIndexWeak"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagIndexEmpty" syntax="IsTagIndexEmpty(tag)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagIndexStrong" syntax="IsTagIndexStrong(tag)">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetTagInfo"/>
			<dependency name="IsTagIDStrong"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagIndexWeak" syntax="IsTagIndexWeak(tag)">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetTagInfo"/>
			<dependency name="IsTagIDWeak"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagNameEmpty" syntax="IsTagNameEmpty(tag[])">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="tag">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:IsTagNameStrong" syntax="IsTagNameStrong(tag[])">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="tag">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:IsTagNameWeak" syntax="IsTagNameWeak(tag[])">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="tag">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:IsValidActor" syntax="IsValidActor(actorid)">
			<attribute name="native"/>
			<referrer name="@yH_OnScriptInit@003"/>
			<param name="actorid">
			</param>
		</member>
		<member name="M:IsWindows" syntax="IsWindows()">
			<tagname value="bool"/>
			<stacksize value="3"/>
			<dependency name="GetOS"/>
			<dependency name="OS_WINDOWS"/>
		</member>
		<member name="M:Iter_ActorDo" syntax="Iter_ActorDo(add, actorid)">
			<stacksize value="7"/>
			<referrer name="Iter_ActorDo_"/>
			<referrer name="Iter_ActorDo@"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_Remove_InternalC"/>
			<dependency name="Iter_Single@Actor"/>
			<dependency name="Iterator@Actor"/>
			<param name="add">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="actorid">
			</param>
		</member>
		<member name="M:Iter_ActorDo@" syntax="Iter_ActorDo@(add, actorid, __m)">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="Iter_ActorDo"/>
			<dependency name="_@"/>
			<param name="add">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="actorid">
			</param>
			<param name="__m">
			</param>
		</member>
		<member name="M:Iter_ActorDo_" syntax="Iter_ActorDo_(add, actorid)">
			<stacksize value="7"/>
			<referrer name="Iter_CreateActor"/>
			<referrer name="Iter_DestroyActor"/>
			<dependency name="I@"/>
			<dependency name="Iter_ActorDo"/>
			<dependency name="J@"/>
			<dependency name="W@"/>
			<param name="add">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="actorid">
			</param>
		</member>
		<member name="M:Iter_AddStaticVehicle" syntax="Iter_AddStaticVehicle(modelid, spawn_x, spawn_y, spawn_z, angle, color1, color2)">
			<stacksize value="10"/>
			<dependency name="AddStaticVehicle"/>
			<dependency name="I@"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_Single@LocalVehicle"/>
			<dependency name="Iter_VehicleDo_"/>
			<dependency name="Iterator@LocalVehicle"/>
			<dependency name="J@"/>
			<dependency name="true"/>
			<param name="modelid">
			</param>
			<param name="spawn_x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="angle">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="color1">
			</param>
			<param name="color2">
			</param>
		</member>
		<member name="M:Iter_AddStaticVehicleEx" syntax="Iter_AddStaticVehicleEx(modelid, spawn_x, spawn_y, spawn_z, angle, color1, color2, respawn_delay, addsiren)">
			<stacksize value="12"/>
			<dependency name="AddStaticVehicleEx"/>
			<dependency name="I@"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_Single@LocalVehicle"/>
			<dependency name="Iter_VehicleDo_"/>
			<dependency name="Iterator@LocalVehicle"/>
			<dependency name="J@"/>
			<dependency name="true"/>
			<param name="modelid">
			</param>
			<param name="spawn_x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="spawn_z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="angle">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="color1">
			</param>
			<param name="color2">
			</param>
			<param name="respawn_delay">
			</param>
			<param name="addsiren">
			</param>
		</member>
		<member name="M:Iter_Add_InternalC" syntax="Iter_Add_InternalC(&amp;count, array[], size, value)">
			<stacksize value="3"/>
			<referrer name="Iter_RandomAdd_InternalC"/>
			<referrer name="@yH_OnScriptInit@003"/>
			<referrer name="@yH_OnPlayerConnect@003"/>
			<referrer name="Iter_ActorDo"/>
			<referrer name="Iter_CreateActor"/>
			<referrer name="Iter_VehicleDo"/>
			<referrer name="Iter_CreateVehicle"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<referrer name="Group_SetCommandDefault"/>
			<dependency name="cellmin"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="size">
				Array start index.
			</param>
			<param name="value">
				Item to add.
			</param>
			        <remarks>  Adds a value to a given iterator set.  Now detects when you try and add the  last item multiple times, as well as all the other items.  Now simplified  even further with the new internal representation.  The modulo code is for  iterator reversal.  </remarks> 
		</member>
		<member name="M:Iter_Add_InternalD" syntax="Iter_Add_InternalD(&amp;count, array[], start, size, value)">
			<stacksize value="3"/>
			<referrer name="Iter_RandomAdd_InternalD"/>
			<dependency name="cellmin"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="size">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:Iter_All_Internal" syntax="Iter_All_Internal(array[], size, value)">
			<stacksize value="1"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:Iter_Alloc_InternalC" syntax="Iter_Alloc_InternalC(&amp;count, array[], size)">
			<stacksize value="4"/>
			<dependency name="cellmin"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="size">
				Array start index.
			</param>
			      <remarks>  Finds the first free slot in the iterator and add it.  </remarks> 
		</member>
		<member name="M:Iter_Alloc_InternalD" syntax="Iter_Alloc_InternalD(&amp;count, array[], start, size)">
			<stacksize value="4"/>
			<dependency name="cellmin"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Iter_Clear_InternalC" syntax="Iter_Clear_InternalC(array[], size, entries, lst, ...)">
			<stacksize value="5"/>
			<referrer name="@yH_OnScriptInit@003"/>
			<dependency name="setarg"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="size">
				Size of base array.
			</param>
			<param name="entries">
				Size of the count data.
			</param>
			<param name="lst">
				Last valid index in the iterator array.
			</param>
			<param name="...">
			</param>
			      <param name="count">Number of items in the iterator.</param>  <param name="elems">Number of iterator elements.</param>    <param name="start">Optional single multi-iterator to clear.</param>  <remarks>  Resets an iterator.  </remarks> 
		</member>
		<member name="M:Iter_Clear_InternalD" syntax="Iter_Clear_InternalD(array[], size, entries, elems, counts[], start)">
			<stacksize value="1"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="entries">
			</param>
			<param name="elems">
			</param>
			<param name="counts">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
		</member>
		<member name="M:Iter_Contains_InternalC" syntax="Iter_Contains_InternalC(array[], size, value)">
			<stacksize value="1"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="size">
				Size of the iterator.
			</param>
			<param name="value">
				Item to check.
			</param>
			      <remarks>  Checks if this item is in the iterator.  </remarks> 
		</member>
		<member name="M:Iter_Contains_InternalD" syntax="Iter_Contains_InternalD(count, array[], size, start, value)">
			<stacksize value="1"/>
			<param name="count">
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="start">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:Iter_CreateActor" syntax="Iter_CreateActor(modelid, X, Y, Z, Rotation)">
			<stacksize value="8"/>
			<dependency name="CreateActor"/>
			<dependency name="I@"/>
			<dependency name="Iter_ActorDo_"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_Single@LocalActor"/>
			<dependency name="Iterator@LocalActor"/>
			<dependency name="J@"/>
			<dependency name="true"/>
			<param name="modelid">
			</param>
			<param name="X">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="Y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="Z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="Rotation">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:Iter_CreateVehicle" syntax="Iter_CreateVehicle(modelid, x, y, z, angle, color1, color2, respawn_delay, addsiren)">
			<stacksize value="12"/>
			<referrer name="@_yCjoinfight"/>
			<dependency name="CreateVehicle"/>
			<dependency name="I@"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_Single@LocalVehicle"/>
			<dependency name="Iter_VehicleDo_"/>
			<dependency name="Iterator@LocalVehicle"/>
			<dependency name="J@"/>
			<dependency name="true"/>
			<param name="modelid">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="angle">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="color1">
			</param>
			<param name="color2">
			</param>
			<param name="respawn_delay">
			</param>
			<param name="addsiren">
			</param>
		</member>
		<member name="M:Iter_DestroyActor" syntax="Iter_DestroyActor(actorid)">
			<stacksize value="7"/>
			<dependency name="DestroyActor"/>
			<dependency name="I@"/>
			<dependency name="Iter_ActorDo_"/>
			<dependency name="Iter_Remove_InternalC"/>
			<dependency name="Iter_Single@LocalActor"/>
			<dependency name="Iterator@LocalActor"/>
			<dependency name="J@"/>
			<dependency name="false"/>
			<param name="actorid">
			</param>
		</member>
		<member name="M:Iter_DestroyVehicle" syntax="Iter_DestroyVehicle(vehicleid)">
			<stacksize value="7"/>
			<dependency name="DestroyVehicle"/>
			<dependency name="I@"/>
			<dependency name="Iter_Remove_InternalC"/>
			<dependency name="Iter_Single@LocalVehicle"/>
			<dependency name="Iter_VehicleDo_"/>
			<dependency name="Iterator@LocalVehicle"/>
			<dependency name="J@"/>
			<dependency name="false"/>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:Iter_FreeMulti_Internal" syntax="Iter_FreeMulti_Internal(array[], trueSize, start)">
			<stacksize value="2"/>
			<dependency name="cellmin"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
				multi-iterator data.
			</param>
			<param name="trueSize">
				Size of the multi-iterator.
			</param>
			<param name="start">
				End [?, since start points are backwards] of the multi-iterator.
			</param>
			      <remarks>  Finds the first free multi index in the multi-iterator.  </remarks> 
		</member>
		<member name="M:Iter_Free_Internal" syntax="Iter_Free_Internal(array[], size)">
			<stacksize value="2"/>
			<dependency name="cellmin"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="size">
				Size of the iterator.
			</param>
			    <remarks>  Finds the first free slot in the iterator.  </remarks> 
		</member>
		<member name="M:Iter_Func@Bits" syntax="Iter_Func@Bits(start, data[], size)">
			<stacksize value="6"/>
			<dependency name="Cell_GetLowestBit"/>
			<dependency name="cellbits"/>
			<param name="start">
			</param>
			<param name="data">
				<paraminfo>Bit [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Iter_Func@Blanks" syntax="Iter_Func@Blanks(start, data[], size)">
			<stacksize value="6"/>
			<dependency name="Cell_GetLowestBit"/>
			<dependency name="cellbits"/>
			<param name="start">
			</param>
			<param name="data">
				<paraminfo>Bit [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Iter_Func@Command" syntax="Iter_Func@Command(start)">
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Iter_Func@Command@"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sHighestID"/>
			<param name="start">
				Last value.
			</param>
			  <returns>  The next command.  </returns>  <remarks>  Internal implementation of the "Command()" iterator for "foreach".  Returns  all the commands that exist.  Normally iterator functions take two  parameters, but this needs only one.  Really quite simple, but probably  faster this way as it has access to internal information.  </remarks> 
		</member>
		<member name="M:Iter_Func@Command@" syntax="Iter_Func@Command@(start)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<automaton name="@_"/>
			<dependency name="Iter_Func@Command"/>
			<dependency name="X@"/>
			<param name="start">
			</param>
		</member>
		<member name="M:Iter_Func@Fib" syntax="Iter_Func@Fib(&amp;iterstart, cur)">
			<stacksize value="1"/>
			<param name="iterstart">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="cur">
			</param>
		</member>
		<member name="M:Iter_Func@Filter" syntax="Iter_Func@Filter(cur, val, arr[], size)">
			<stacksize value="1"/>
			<param name="cur">
			</param>
			<param name="val">
			</param>
			<param name="arr">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Iter_Func@NonNull" syntax="Iter_Func@NonNull(cur, arr[], size)">
			<stacksize value="1"/>
			<param name="cur">
			</param>
			<param name="arr">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Iter_Func@Null" syntax="Iter_Func@Null(cur, arr[], size)">
			<stacksize value="1"/>
			<param name="cur">
			</param>
			<param name="arr">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Iter_Func@PA" syntax="Iter_Func@PA(start, data[])">
			<stacksize value="7"/>
			<dependency name="Cell_GetLowestBit"/>
			<dependency name="IsPlayerConnected"/>
			<dependency name="cellbits"/>
			<param name="start">
			</param>
			<param name="data">
				<paraminfo>Bit [] </paraminfo>
			</param>
		</member>
		<member name="M:Iter_Func@PlayerCommand" syntax="Iter_Func@PlayerCommand(start, pid)">
			<stacksize value="7"/>
			<automaton name="@_"/>
			<referrer name="Iter_Func@PlayerCommand@"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="E_COMMAND_USERS"/>
			<dependency name="V@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sHighestID"/>
			<dependency name="cellbits"/>
			<param name="start">
				Last value.
			</param>
			<param name="pid">
				Player to check for.
			</param>
			    <returns>  The next command.  </returns>  <remarks>  Internal implementation of the "PlayerCommand()" iterator for "foreach".  Returns all the commands this player can use.  This is similar to "Command_GetNext", but returns an ID not a string - I  actually think this way is slightly better.  </remarks> 
		</member>
		<member name="M:Iter_Func@PlayerCommand@" syntax="Iter_Func@PlayerCommand@(start, pid)">
			<attribute name="public"/>
			<stacksize value="5"/>
			<automaton name="@_"/>
			<dependency name="Iter_Func@PlayerCommand"/>
			<dependency name="X@"/>
			<param name="start">
			</param>
			<param name="pid">
			</param>
		</member>
		<member name="M:Iter_Func@Powers" syntax="Iter_Func@Powers(&amp;iterstart, cur, base)">
			<stacksize value="1"/>
			<param name="iterstart">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="cur">
			</param>
			<param name="base">
			</param>
		</member>
		<member name="M:Iter_Func@Random" syntax="Iter_Func@Random(&amp;iterstart, cur, count, min, max)">
			<stacksize value="3"/>
			<dependency name="cellmin"/>
			<dependency name="random"/>
			<param name="iterstart">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="cur">
			</param>
			<param name="count">
			</param>
			<param name="min">
			</param>
			<param name="max">
			</param>
		</member>
		<member name="M:Iter_Func@Range" syntax="Iter_Func@Range(cur, min, max, step)">
			<stacksize value="1"/>
			<dependency name="cellmin"/>
			<param name="cur">
			</param>
			<param name="min">
			</param>
			<param name="max">
			</param>
			<param name="step">
			</param>
		</member>
		<member name="M:Iter_Func@Until" syntax="Iter_Func@Until(cur, val, arr[], size)">
			<stacksize value="1"/>
			<param name="cur">
			</param>
			<param name="val">
			</param>
			<param name="arr">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Iter_GetMulti_Internal" syntax="Iter_GetMulti_Internal(array[], trueSize, size, value)">
			<stacksize value="1"/>
			<dependency name="cellmin"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
				multi-iterator data.
			</param>
			<param name="trueSize">
				Size of the multi-iterator per index.
			</param>
			<param name="size">
				Size of the multi-iterator.
			</param>
			<param name="value">
				Item to check.
			</param>
			        <returns>  INVALID_ITERATOR_SLOT on failure.  Index of the multi-iterator the value is contained.  </returns>  <remarks>  Checks if this item is in the multi-iterator at all, and if it is returns which index it is in.  </remarks> 
		</member>
		<member name="M:Iter_Index_Internal" syntax="Iter_Index_Internal(count, array[], start, size, index, wrap)">
			<stacksize value="1"/>
			<dependency name="cellmin"/>
			<param name="count">
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="start">
				Array start index.
			</param>
			<param name="size">
				Array size.
			</param>
			<param name="index">
				Index to find Nth value.
			</param>
			<param name="wrap">
				<paraminfo>bool </paraminfo>
				Keep going around until a value is found?
			</param>
			            <remarks>  Allows you to find the Nth value in the iterator.  DO NOT call this in a  loop to get all values - that totally defeats the purpose of "foreach", just  use a normal "foreach" loop with an index counter for that case.  </remarks> 
		</member>
		<member name="M:Iter_Init_Internal" syntax="Iter_Init_Internal(arr[][], first[], s0, s1, entries)">
			<stacksize value="9"/>
			<dependency name="memcpy"/>
			<param name="arr">
				<paraminfo> [][] </paraminfo>
			</param>
			<param name="first">
				<paraminfo> [] </paraminfo>
				First iterator slot.
			</param>
			<param name="s0">
				Size of first dimension.
			</param>
			<param name="s1">
				Size of second dimension.
			</param>
			<param name="entries">
				Number of start points.
			</param>
			<param name="array">Iterator array to initialise.</param>          <remarks>  Multi-dimensional arrays can't be initialised at compile time, so need to be  done at run time, which is slightly annoying.  </remarks> 
		</member>
		<member name="M:Iter_None_Internal" syntax="Iter_None_Internal(array[], size, value)">
			<stacksize value="1"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:Iter_OPDCInternal" syntax="Iter_OPDCInternal(playerid)">
			<attribute name="public"/>
			<stacksize value="7"/>
			<dependency name="IsPlayerConnected"/>
			<dependency name="IsPlayerNPC"/>
			<dependency name="Iter_Remove_InternalC"/>
			<dependency name="Iter_Single@Bot"/>
			<dependency name="Iter_Single@Character"/>
			<dependency name="Iter_Single@Player"/>
			<dependency name="Iterator@Bot"/>
			<dependency name="Iterator@Character"/>
			<dependency name="Iterator@Player"/>
			<param name="playerid">
				Player who left.
			</param>
			  <remarks>  Called AFTER "OnPlayerDisconnect" so that using "Kick" inside a  "foreach" loop doesn't crash the server due to an OOB error.  </remarks> 
		</member>
		<member name="M:Iter_Prev_Internal" syntax="Iter_Prev_Internal(array[], elems, size, slot)">
			<stacksize value="2"/>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="elems">
				Number of elements in the iterator.
			</param>
			<param name="size">
				Size of the iterator.
			</param>
			<param name="slot">
				The current slot.
			</param>
			        <remarks>  Gets the element in an iterator that points to the current element.  </remarks> 
		</member>
		<member name="M:Iter_RandomAdd_InternalC" syntax="Iter_RandomAdd_InternalC(&amp;count, array[], start)">
			<stacksize value="9"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_RandomFree_InternalC"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="start">
				Size of the iterator.
			</param>
			      <param name="slots">Number of multi-iterator values.</param>  <remarks>  Returns a random unused value from an iterator.  </remarks> 
		</member>
		<member name="M:Iter_RandomAdd_InternalD" syntax="Iter_RandomAdd_InternalD(counts[], array[], size, slots, start, slot)">
			<stacksize value="11"/>
			<dependency name="Iter_Add_InternalD"/>
			<dependency name="Iter_RandomFree_InternalD"/>
			<param name="counts">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="slots">
			</param>
			<param name="start">
			</param>
			<param name="slot">
			</param>
		</member>
		<member name="M:Iter_RandomFree_InternalC" syntax="Iter_RandomFree_InternalC(count, array[], start)">
			<stacksize value="3"/>
			<referrer name="Iter_RandomAdd_InternalC"/>
			<referrer name="Iter_RandomFree_InternalD"/>
			<dependency name="cellmin"/>
			<dependency name="random"/>
			<param name="count">
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="start">
				Size of the iterator.
			</param>
			      <param name="slots">Number of multi-iterator values.</param>  <remarks>  Returns a random unused value from an iterator.  </remarks> 
		</member>
		<member name="M:Iter_RandomFree_InternalD" syntax="Iter_RandomFree_InternalD(counts[], array[], start, slots)">
			<stacksize value="7"/>
			<referrer name="Iter_RandomAdd_InternalD"/>
			<dependency name="Iter_RandomFree_InternalC"/>
			<param name="counts">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="slots">
			</param>
		</member>
		<member name="M:Iter_RandomRemove_InternalC" syntax="Iter_RandomRemove_InternalC(&amp;count, array[], start)">
			<stacksize value="9"/>
			<dependency name="Iter_Random_Internal"/>
			<dependency name="Iter_Remove_InternalC"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="start">
				Size of the iterator.
			</param>
			      <param name="slots">Number of multi-iterator values.</param>  <remarks>  Returns a random unused value from an iterator.  </remarks> 
		</member>
		<member name="M:Iter_RandomRemove_InternalD" syntax="Iter_RandomRemove_InternalD(&amp;count, array[], size, start)">
			<stacksize value="10"/>
			<dependency name="Iter_Random_Internal"/>
			<dependency name="Iter_Remove_InternalD"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="start">
			</param>
		</member>
		<member name="M:Iter_Random_Internal" syntax="Iter_Random_Internal(count, array[], start, ...)">
			<stacksize value="6"/>
			<referrer name="Iter_RandomRemove_InternalC"/>
			<referrer name="Iter_RandomRemove_InternalD"/>
			<dependency name="Hooks_NumArgs"/>
			<dependency name="cellmin"/>
			<dependency name="random"/>
			<param name="count">
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="start">
				Size of the iterator.
			</param>
			<param name="...">
				Excluded elements.
			</param>
			        <remarks>  Returns a random value from an iterator.  If additional parameters are given they are excluded from consideration.  This allows you to chain calls to get multiple random values so follows:  new president     = Iter_Random(Player);  new vicePresident = Iter_Random(Player, president);  new primeMinister = Iter_Random(Player, president, vicePresident);  new minister      = Iter_Random(Player, president, vicePresident, primeMinister);  None of those values can be the same, and this saves horrible random-  dependent loops.  </remarks> 
		</member>
		<member name="M:Iter_Remove_InternalC" syntax="Iter_Remove_InternalC(&amp;count, array[], size, value)">
			<stacksize value="9"/>
			<referrer name="Iter_RandomRemove_InternalC"/>
			<referrer name="Iter_OPDCInternal"/>
			<referrer name="Iter_ActorDo"/>
			<referrer name="Iter_DestroyActor"/>
			<referrer name="Iter_VehicleDo"/>
			<referrer name="Iter_DestroyVehicle"/>
			<dependency name="Iter_SafeRemove_InternalC"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				iterator data.
			</param>
			<param name="size">
				Number of iterator elements.
			</param>
			<param name="value">
				Item to remove.
			</param>
			        <remarks>  Removes a value from an iterator.  </remarks> 
		</member>
		<member name="M:Iter_Remove_InternalD" syntax="Iter_Remove_InternalD(&amp;count, array[], start, size, value)">
			<stacksize value="10"/>
			<referrer name="Iter_RandomRemove_InternalD"/>
			<dependency name="Iter_SafeRemove_InternalD"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="size">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:Iter_SafeRemove_InternalC" syntax="Iter_SafeRemove_InternalC(&amp;count, array[], size, value, &amp;last)">
			<stacksize value="1"/>
			<referrer name="Iter_Remove_InternalC"/>
			<dependency name="cellmin"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
				Number of items in the iterator.
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
				Iterator data.
			</param>
			<param name="size">
				Number of iterator elements.
			</param>
			<param name="value">
				Item to remove.
			</param>
			<param name="last">
				<paraminfo> &amp; </paraminfo>
				Pointer in which to store the last pointer.
			</param>
			          <remarks>  Removes a value from an iterator safely.  </remarks> 
		</member>
		<member name="M:Iter_SafeRemove_InternalD" syntax="Iter_SafeRemove_InternalD(&amp;count, array[], start, size, value, &amp;last)">
			<stacksize value="1"/>
			<referrer name="Iter_Remove_InternalD"/>
			<dependency name="cellmin"/>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="array">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="size">
			</param>
			<param name="value">
			</param>
			<param name="last">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:Iter_VehicleDo" syntax="Iter_VehicleDo(add, vehicleid)">
			<stacksize value="7"/>
			<referrer name="Iter_VehicleDo_"/>
			<referrer name="Iter_VehicleDo@"/>
			<dependency name="Iter_Add_InternalC"/>
			<dependency name="Iter_Remove_InternalC"/>
			<dependency name="Iter_Single@Vehicle"/>
			<dependency name="Iterator@Vehicle"/>
			<param name="add">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:Iter_VehicleDo@" syntax="Iter_VehicleDo@(add, vehicleid, __m)">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="Iter_VehicleDo"/>
			<dependency name="_@"/>
			<param name="add">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="vehicleid">
			</param>
			<param name="__m">
			</param>
		</member>
		<member name="M:Iter_VehicleDo_" syntax="Iter_VehicleDo_(add, vehicleid)">
			<stacksize value="7"/>
			<referrer name="Iter_CreateVehicle"/>
			<referrer name="Iter_AddStaticVehicle"/>
			<referrer name="Iter_AddStaticVehicleEx"/>
			<referrer name="Iter_DestroyVehicle"/>
			<dependency name="I@"/>
			<dependency name="Iter_VehicleDo"/>
			<dependency name="J@"/>
			<dependency name="W@"/>
			<param name="add">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:Iter_YieldEnter" syntax="Iter_YieldEnter()">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="Debug_Print0"/>
			<dependency name="YSI_gIteratorDepth"/>
			<dependency name="YSI_g_sIteratorStack"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<remarks>  </remarks> 
		</member>
		<member name="M:Iter_YieldLoop" syntax="Iter_YieldLoop()">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="E_ITER_YIELD_FIRST"/>
			<dependency name="E_ITER_YIELD_STACK_SIZE"/>
			<dependency name="YSI_gIteratorDepth"/>
			<dependency name="YSI_g_sIteratorStack"/>
			<dependency name="YSI_g_sIteratorStack"/>
			<dependency name="YSI_g_sPtr"/>
			<dependency name="YSI_g_sStackPtr"/>
			<dependency name="false"/>
			<dependency name="memcpy"/>
			<dependency name="true"/>
		</member>
		<member name="M:Iter_YieldReturn" syntax="Iter_YieldReturn(value)">
			<stacksize value="1"/>
			<dependency name="I@"/>
			<dependency name="YSI_gIteratorDepth"/>
			<dependency name="YSI_g_sIteratorStack"/>
			<dependency name="YSI_g_sPtr"/>
			<dependency name="YSI_g_sStackPtr"/>
			<dependency name="memcpy"/>
			<param name="value">
			</param>
		</member>
		<member name="M:LoadStaticVehiclesFromFile" syntax="LoadStaticVehiclesFromFile(filename[])">
			<stacksize value="341"/>
			<dependency name="AddStaticVehicleEx"/>
			<dependency name="fclose"/>
			<dependency name="floatstr"/>
			<dependency name="fopen"/>
			<dependency name="fread"/>
			<dependency name="io_read"/>
			<dependency name="printf"/>
			<dependency name="strval"/>
			<dependency name="token_by_delim"/>
			<param name="filename">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Master_GetCurrentMaster" syntax="Master_GetCurrentMaster()">
			<stacksize value="5"/>
			<referrer name="@_OnScriptInit"/>
			<referrer name="@a"/>
			<dependency name="_E_YCM@n"/>
			<dependency name="_E_YCM@y"/>
			<dependency name="_Master_Get"/>
			<dependency name="_YCM_g@a"/>
			<dependency name="false"/>
			<transition keep="true" target="_YCM : y" />  <transition keep="true" target="_YCM : u" />  <transition keep="true" target="_YCM : y" />  <transition keep="true" target="_YCM : n" /> 
		</member>
		<member name="M:Master_GetCurrentMaster" syntax="Master_GetCurrentMaster()">
			<stacksize value="5"/>
			<referrer name="YSIM_OnMasterSystemInit"/>
			<referrer name="@_"/>
			<dependency name="_E_YCM@n"/>
			<dependency name="_E_YCM@y"/>
			<dependency name="_Master_Get"/>
			<dependency name="_YCM_g@_"/>
			<dependency name="false"/>
			<transition keep="true" target="_YCM : y" />  <transition keep="true" target="_YCM : u" />  <transition keep="true" target="_YCM : y" />  <transition keep="true" target="_YCM : n" /> 
		</member>
		<member name="M:Master_GetNext" syntax="Master_GetNext()">
			<stacksize value="8"/>
			<dependency name="getproperty"/>
			<returns>  Next master ID to be assigned.  </returns> 
		</member>
		<member name="M:Master_OnScriptExit" syntax="Master_OnScriptExit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_ALS"/>
			<referrer name="ScriptInit_OnScriptExit"/>
		</member>
		<member name="M:Master_OnScriptInit" syntax="Master_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_ALS"/>
			<referrer name="HookChain_OnScriptInit"/>
		</member>
		<member name="M:Master_Reassert" syntax="Master_Reassert()">
			<attribute name="public"/>
			<stacksize value="11"/>
			<dependency name="U@"/>
			<dependency name="YSI_g_sMasterCount"/>
			<dependency name="YSI_g_sMasterData"/>
			<dependency name="_@"/>
			<dependency name="getproperty"/>
			<dependency name="setproperty"/>
			<remarks>  Rebuilds the collection of master data whenever a script is restarted.  </remarks> 
		</member>
		<member name="M:Mean" syntax="Mean(arr[], num)">
			<stacksize value="5"/>
			<dependency name="Sum"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array whose values need averaging.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <returns>  The mathematical mean value of the array.  </returns> 
		</member>
		<member name="M:Median" syntax="Median(arr[], num)">
			<stacksize value="5"/>
			<dependency name="Utils_PreSort"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array whose values need averaging.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <returns>  The mathematical median value of the array.  </returns> 
		</member>
		<member name="M:Mode" syntax="Mode(arr[], num)">
			<stacksize value="6"/>
			<dependency name="Utils_PreSort"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array whose values need averaging.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <returns>  The mathematical modal value of the array.  </returns> 
		</member>
		<member name="M:NtCompare" syntax="NtCompare(s1, s2[])">
			<stacksize value="8"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetTagIndexFromName"/>
			<dependency name="ReadAmxMemory"/>
			<param name="s1">
			</param>
			<param name="s2">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:NtCopy" syntax="NtCopy(src, dest[], size)">
			<stacksize value="6"/>
			<referrer name="GetPublicNameFromIndex"/>
			<referrer name="GetNativeNameFromIndex"/>
			<referrer name="GetPubVarNameFromIndex"/>
			<referrer name="GetTagNameFromIndex"/>
			<dependency name="ReadAmxMemory"/>
			<param name="src">
			</param>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:O@A_" syntax="O@A_()">
			<tagname value="bool"/>
			<stacksize value="11"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmGetOperandReloc"/>
			<dependency name="DisasmInit"/>
			<dependency name="DisasmNext"/>
			<dependency name="GetCurrentFrameReturn"/>
			<dependency name="O@V_"/>
			<dependency name="OP_CALL"/>
			<dependency name="false"/>
		</member>
		<member name="M:OnActorStreamIn" syntax="OnActorStreamIn(actorid, forplayerid)">
			<stacksize value="1"/>
			<param name="actorid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:OnActorStreamOut" syntax="OnActorStreamOut(actorid, forplayerid)">
			<stacksize value="1"/>
			<param name="actorid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:OnDialogResponse" syntax="OnDialogResponse(playerid, dialogid, response, listitem, inputtext[])">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="dialogid">
			</param>
			<param name="response">
			</param>
			<param name="listitem">
			</param>
			<param name="inputtext">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:OnEnterExitModShop" syntax="OnEnterExitModShop(playerid, enterexit, interiorid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="enterexit">
			</param>
			<param name="interiorid">
			</param>
		</member>
		<member name="M:OnFilterScriptExit" syntax="OnFilterScriptExit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="ScriptInit_OnFilterScriptExit"/>
			<dependency name="ScriptInit_OnScriptExit"/>
			<dependency name="YSI_FILTERSCRIPT"/>
		</member>
		<member name="M:OnFilterScriptInit" syntax="OnFilterScriptInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="ScriptInit_OnFilterScriptInit"/>
			<dependency name="YSI_FILTERSCRIPT"/>
			<dependency name="true"/>
			<transition keep="true" target="_script_init_fix_state : true"/>  <transition keep="true" target="_ALS : _ALS_go"/> 
		</member>
		<member name="M:OnGameModeExit" syntax="OnGameModeExit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="ScriptInit_OnGameModeExit"/>
			<dependency name="ScriptInit_OnScriptExit"/>
			<dependency name="YSI_FILTERSCRIPT"/>
		</member>
		<member name="M:OnGameModeInit" syntax="OnGameModeInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="ScriptInit_OnGameModeInit"/>
			<dependency name="YSI_FILTERSCRIPT"/>
			<transition keep="true" target="_script_init_fix_state : false"/>  <transition keep="true" target="_ALS : _ALS_go"/> 
		</member>
		<member name="M:OnIncomingConnection" syntax="OnIncomingConnection(playerid, ip_address[], port)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="ip_address">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="port">
			</param>
		</member>
		<member name="M:OnObjectMoved" syntax="OnObjectMoved(objectid)">
			<stacksize value="1"/>
			<param name="objectid">
			</param>
		</member>
		<member name="M:OnPlayerClickMap" syntax="OnPlayerClickMap(playerid, fX, fY, fZ)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="fX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fZ">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerClickPlayer" syntax="OnPlayerClickPlayer(playerid, clickedplayerid, source)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="clickedplayerid">
			</param>
			<param name="source">
			</param>
		</member>
		<member name="M:OnPlayerClickPlayerTextDraw" syntax="OnPlayerClickPlayerTextDraw(playerid, playertextid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="playertextid">
				<paraminfo>PlayerText </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerClickTextDraw" syntax="OnPlayerClickTextDraw(playerid, clickedid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="clickedid">
				<paraminfo>Text </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerCommandPerformed" syntax="OnPlayerCommandPerformed(playerid, cmdtext[], success)">
			<tagname value="e_COMMAND_ERRORS"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="cmdtext">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="success">
				<paraminfo>e_COMMAND_ERRORS </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerCommandReceived" syntax="OnPlayerCommandReceived(playerid, cmdtext[], success)">
			<tagname value="e_COMMAND_ERRORS"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="cmdtext">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="success">
				<paraminfo>e_COMMAND_ERRORS </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerCommandText" syntax="OnPlayerCommandText(playerid, cmdtext[])">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="cmdtext">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerConnect" syntax="OnPlayerConnect(playerid)">
			<attribute name="public"/>
			<stacksize value="21"/>
			<dependency name="GetPlayerIp"/>
			<dependency name="IPToInt"/>
			<dependency name="YSI_gPlayerIP"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerDeath" syntax="OnPlayerDeath(playerid, killerid, reason)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="killerid">
			</param>
			<param name="reason">
			</param>
		</member>
		<member name="M:OnPlayerDisconnect" syntax="OnPlayerDisconnect(playerid, reason)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<dependency name="YSI_gPlayerIP"/>
			<param name="playerid">
			</param>
			<param name="reason">
			</param>
		</member>
		<member name="M:OnPlayerEditAttachedObject" syntax="OnPlayerEditAttachedObject(playerid, response, index, modelid, boneid, fOffsetX, fOffsetY, fOffsetZ, fRotX, fRotY, fRotZ, fScaleX, fScaleY, fScaleZ)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="response">
			</param>
			<param name="index">
			</param>
			<param name="modelid">
			</param>
			<param name="boneid">
			</param>
			<param name="fOffsetX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fOffsetY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fOffsetZ">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fRotX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fRotY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fRotZ">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fScaleX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fScaleY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fScaleZ">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerEditObject" syntax="OnPlayerEditObject(playerid, playerobject, objectid, response, fX, fY, fZ, fRotX, fRotY, fRotZ)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="playerobject">
			</param>
			<param name="objectid">
			</param>
			<param name="response">
			</param>
			<param name="fX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fZ">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fRotX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fRotY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fRotZ">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerEnterCheckpoint" syntax="OnPlayerEnterCheckpoint(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerEnterRaceCheckpoint" syntax="OnPlayerEnterRaceCheckpoint(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerEnterVehicle" syntax="OnPlayerEnterVehicle(playerid, vehicleid, ispassenger)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
			<param name="ispassenger">
			</param>
		</member>
		<member name="M:OnPlayerExitVehicle" syntax="OnPlayerExitVehicle(playerid, vehicleid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:OnPlayerExitedMenu" syntax="OnPlayerExitedMenu(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerGiveDamage" syntax="OnPlayerGiveDamage(playerid, damagedid, amount, weaponid, bodypart)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="damagedid">
			</param>
			<param name="amount">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="weaponid">
			</param>
			<param name="bodypart">
			</param>
		</member>
		<member name="M:OnPlayerGiveDamageActor" syntax="OnPlayerGiveDamageActor(playerid, damaged_actorid, amount, weaponid, bodypart)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="damaged_actorid">
			</param>
			<param name="amount">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="weaponid">
			</param>
			<param name="bodypart">
			</param>
		</member>
		<member name="M:OnPlayerInteriorChange" syntax="OnPlayerInteriorChange(playerid, newinteriorid, oldinteriorid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="newinteriorid">
			</param>
			<param name="oldinteriorid">
			</param>
		</member>
		<member name="M:OnPlayerKeyStateChange" syntax="OnPlayerKeyStateChange(playerid, newkeys, oldkeys)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="newkeys">
			</param>
			<param name="oldkeys">
			</param>
		</member>
		<member name="M:OnPlayerLeaveCheckpoint" syntax="OnPlayerLeaveCheckpoint(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerLeaveRaceCheckpoint" syntax="OnPlayerLeaveRaceCheckpoint(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerObjectMoved" syntax="OnPlayerObjectMoved(playerid, objectid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="objectid">
			</param>
		</member>
		<member name="M:OnPlayerPickUpPickup" syntax="OnPlayerPickUpPickup(playerid, pickupid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="pickupid">
			</param>
		</member>
		<member name="M:OnPlayerRequestClass" syntax="OnPlayerRequestClass(playerid, classid)">
			<attribute name="public"/>
			<stacksize value="15"/>
			<dependency name="IsPlayerNPC"/>
			<dependency name="SetSpawnInfo"/>
			<dependency name="SpawnPlayer"/>
			<param name="playerid">
			</param>
			<param name="classid">
			</param>
		</member>
		<member name="M:OnPlayerRequestSpawn" syntax="OnPlayerRequestSpawn(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerSelectObject" syntax="OnPlayerSelectObject(playerid, type, objectid, modelid, fX, fY, fZ)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="type">
			</param>
			<param name="objectid">
			</param>
			<param name="modelid">
			</param>
			<param name="fX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fZ">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerSelectedMenuRow" syntax="OnPlayerSelectedMenuRow(playerid, row)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="row">
			</param>
		</member>
		<member name="M:OnPlayerSpawn" syntax="OnPlayerSpawn(playerid)">
			<attribute name="public"/>
			<stacksize value="6"/>
			<dependency name="IsPlayerNPC"/>
			<dependency name="SetPlayerFacingAngle"/>
			<dependency name="SetPlayerPos"/>
			<dependency name="TogglePlayerClock"/>
			<dependency name="gRandomSpawns_LosSantos"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerStateChange" syntax="OnPlayerStateChange(playerid, newstate, oldstate)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="newstate">
			</param>
			<param name="oldstate">
			</param>
		</member>
		<member name="M:OnPlayerStreamIn" syntax="OnPlayerStreamIn(playerid, forplayerid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:OnPlayerStreamOut" syntax="OnPlayerStreamOut(playerid, forplayerid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:OnPlayerTakeDamage" syntax="OnPlayerTakeDamage(playerid, issuerid, amount, weaponid, bodypart)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="issuerid">
			</param>
			<param name="amount">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="weaponid">
			</param>
			<param name="bodypart">
			</param>
		</member>
		<member name="M:OnPlayerText" syntax="OnPlayerText(playerid, text[])">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="text">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:OnPlayerUpdate" syntax="OnPlayerUpdate(playerid)">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="IsPlayerConnected"/>
			<dependency name="IsPlayerNPC"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerWeaponShot" syntax="OnPlayerWeaponShot(playerid, weaponid, hittype, hitid, fX, fY, fZ)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="weaponid">
			</param>
			<param name="hittype">
			</param>
			<param name="hitid">
			</param>
			<param name="fX">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fY">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fZ">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnRconCommand" syntax="OnRconCommand(cmd[])">
			<stacksize value="1"/>
			<param name="cmd">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:OnRconLoginAttempt" syntax="OnRconLoginAttempt(ip[], password[], success)">
			<stacksize value="1"/>
			<param name="ip">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="password">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="success">
			</param>
		</member>
		<member name="M:OnTrailerUpdate" syntax="OnTrailerUpdate(playerid, vehicleid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:OnUnoccupiedVehicleUpdate" syntax="OnUnoccupiedVehicleUpdate(vehicleid, playerid, passenger_seat, new_x, new_y, new_z, vel_x, vel_y, vel_z)">
			<stacksize value="1"/>
			<param name="vehicleid">
			</param>
			<param name="playerid">
			</param>
			<param name="passenger_seat">
			</param>
			<param name="new_x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="new_y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="new_z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="vel_x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="vel_y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="vel_z">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:OnVehicleDamageStatusUpdate" syntax="OnVehicleDamageStatusUpdate(vehicleid, playerid)">
			<stacksize value="1"/>
			<param name="vehicleid">
			</param>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnVehicleDeath" syntax="OnVehicleDeath(vehicleid, killerid)">
			<stacksize value="1"/>
			<param name="vehicleid">
			</param>
			<param name="killerid">
			</param>
		</member>
		<member name="M:OnVehicleMod" syntax="OnVehicleMod(playerid, vehicleid, componentid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
			<param name="componentid">
			</param>
		</member>
		<member name="M:OnVehiclePaintjob" syntax="OnVehiclePaintjob(playerid, vehicleid, paintjobid)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
			<param name="paintjobid">
			</param>
		</member>
		<member name="M:OnVehicleRespray" syntax="OnVehicleRespray(playerid, vehicleid, color1, color2)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
			<param name="color1">
			</param>
			<param name="color2">
			</param>
		</member>
		<member name="M:OnVehicleSirenStateChange" syntax="OnVehicleSirenStateChange(playerid, vehicleid, newstate)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
			<param name="newstate">
			</param>
		</member>
		<member name="M:OnVehicleSpawn" syntax="OnVehicleSpawn(vehicleid)">
			<stacksize value="1"/>
			<param name="vehicleid">
			</param>
		</member>
		<member name="M:OnVehicleStreamIn" syntax="OnVehicleStreamIn(vehicleid, forplayerid)">
			<stacksize value="1"/>
			<param name="vehicleid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:OnVehicleStreamOut" syntax="OnVehicleStreamOut(vehicleid, forplayerid)">
			<stacksize value="1"/>
			<param name="vehicleid">
			</param>
			<param name="forplayerid">
			</param>
		</member>
		<member name="M:PA_Init" syntax="PA_Init(a[], init, s)">
			<stacksize value="2"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_Add"/>
			<param name="a">
				<paraminfo>Bit [] </paraminfo>
			</param>
			<param name="init">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="s">
			</param>
		</member>
		<member name="M:PA_Set" syntax="PA_Set(d[], slot, set)">
			<stacksize value="1"/>
			<referrer name="Command_SetPlayerDisabled"/>
			<referrer name="Command_SetPlayer"/>
			<dependency name="cellbits"/>
			<param name="d">
				<paraminfo>Bit [] </paraminfo>
			</param>
			<param name="slot">
			</param>
			<param name="set">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:PlaySoundForAll" syntax="PlaySoundForAll(soundid, x, y, z)">
			<stacksize value="8"/>
			<dependency name="IsPlayerConnected"/>
			<dependency name="PlayerPlaySound"/>
			<param name="soundid">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:PlaySoundForPlayersInRange" syntax="PlaySoundForPlayersInRange(soundid, range, x, y, z)">
			<stacksize value="8"/>
			<dependency name="IsPlayerConnected"/>
			<dependency name="IsPlayerInRangeOfPoint"/>
			<dependency name="PlayerPlaySound"/>
			<param name="soundid">
			</param>
			<param name="range">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:PlayerPlaySound" syntax="PlayerPlaySound(playerid, soundid, x, y, z)">
			<attribute name="native"/>
			<referrer name="PlaySoundForAll"/>
			<referrer name="PlaySoundForPlayersInRange"/>
			<param name="playerid">
			</param>
			<param name="soundid">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:Pop" syntax="Pop(&amp;arg)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="false"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<dependency name="true"/>
			<param name="arg">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:PrintAmxHeader" syntax="PrintAmxHeader()">
			<stacksize value="4"/>
			<dependency name="AMX_HDR_AMX_VERSION"/>
			<dependency name="AMX_HDR_CIP"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_FILE_VERSION"/>
			<dependency name="AMX_HDR_FLAGS"/>
			<dependency name="AMX_HDR_HEA"/>
			<dependency name="AMX_HDR_LIBRARIES"/>
			<dependency name="AMX_HDR_MAGIC"/>
			<dependency name="AMX_HDR_NAMETABLE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="AMX_HDR_SIZE"/>
			<dependency name="AMX_HDR_STP"/>
			<dependency name="AMX_HDR_TAGS"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="printf"/>
		</member>
		<member name="M:PrintStackTrace" syntax="PrintStackTrace(trace[], max)">
			<stacksize value="40"/>
			<dependency name="GetFunctionFromReturnAddress"/>
			<dependency name="GetPublicNameFromAddress"/>
			<dependency name="print"/>
			<dependency name="printf"/>
			<param name="trace">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="max">
			</param>
		</member>
		<member name="M:ProfilerInit" syntax="ProfilerInit()">
			<stacksize value="31"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="HookPublic"/>
			<dependency name="g_num_publics"/>
			<dependency name="g_pecs"/>
			<dependency name="g_publics"/>
			<dependency name="g_publics"/>
			<dependency name="new_pec"/>
			<dependency name="ppi_child_time"/>
			<dependency name="ppi_num_calls"/>
			<dependency name="ppi_total_time"/>
			<dependency name="printf"/>
		</member>
		<member name="M:ProfilerWriteData" syntax="ProfilerWriteData(filename[])">
			<tagname value="bool"/>
			<stacksize value="144"/>
			<dependency name="GetPublicNameFromIndex"/>
			<dependency name="false"/>
			<dependency name="fclose"/>
			<dependency name="fopen"/>
			<dependency name="format"/>
			<dependency name="fwrite"/>
			<dependency name="g_num_publics"/>
			<dependency name="g_publics"/>
			<dependency name="g_publics"/>
			<dependency name="io_write"/>
			<dependency name="ppi_child_time"/>
			<dependency name="ppi_num_calls"/>
			<dependency name="ppi_total_time"/>
			<dependency name="true"/>
			<param name="filename">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Puny_Adapt" syntax="Puny_Adapt(delta, length, firstTime)">
			<stacksize value="2"/>
			<referrer name="Puny_Decode"/>
			<referrer name="Puny_Encode"/>
			<referrer name="Puny_EncodeHash"/>
			<dependency name="PUNY_DAMP"/>
			<dependency name="PUNY_SKEW"/>
			<dependency name="PUNY_TMAX"/>
			<dependency name="PUNY_TMIN"/>
			<param name="delta">
				Part of the state machine.
			</param>
			<param name="length">
				Written string size.
			</param>
			<param name="firstTime">
				<paraminfo>bool </paraminfo>
				Have special characters already been written?
			</param>
			      <remarks>  This is part of how the punycode algorithm encodes numbers as very clever  strings, but honestly I don't fully understand it!  </remarks> 
		</member>
		<member name="M:Puny_Decode" syntax="Puny_Decode(dst[], src[], wlen, delimiter)">
			<stacksize value="14"/>
			<dependency name="PUNY_BIAS"/>
			<dependency name="PUNY_INIT"/>
			<dependency name="PUNY_TMAX"/>
			<dependency name="PUNY_TMIN"/>
			<dependency name="Puny_Adapt"/>
			<dependency name="YSI_gscDecoder"/>
			<dependency name="cellmax"/>
			<dependency name="strcat"/>
			<dependency name="strins"/>
			<dependency name="strlen"/>
			<param name="dst">
				<paraminfo> [] </paraminfo>
				Where to store the converted string.
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
				The string to convert.
			</param>
			<param name="wlen">
				The length of the destination.
			</param>
			<param name="delimiter">
				What character is between the parts.
			</param>
			        <remarks>  Takes a punycode string and converts it to unicode.  </remarks> 
		</member>
		<member name="M:Puny_Encode" syntax="Puny_Encode(dst[], src[], wlen, delimiter)">
			<stacksize value="16"/>
			<dependency name="PUNY_BIAS"/>
			<dependency name="PUNY_INIT"/>
			<dependency name="Puny_Adapt"/>
			<dependency name="Puny_EncodeVar"/>
			<dependency name="cellmax"/>
			<dependency name="strlen"/>
			<param name="dst">
				<paraminfo> [] </paraminfo>
				Where to store the converted string.
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
				The string to convert.
			</param>
			<param name="wlen">
				The length of the destination.
			</param>
			<param name="delimiter">
				What character to place between the parts.
			</param>
			        <remarks>  Takes a unicode string and converts it to punycode.  </remarks> 
		</member>
		<member name="M:Puny_EncodeHash" syntax="Puny_EncodeHash(dst[], src[], &amp;hash, wlen, delimiter)">
			<stacksize value="163"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="Command_Find"/>
			<dependency name="PUNY_BIAS"/>
			<dependency name="PUNY_INIT"/>
			<dependency name="Puny_Adapt"/>
			<dependency name="Puny_EncodeVarHash"/>
			<dependency name="cellmax"/>
			<dependency name="false"/>
			<dependency name="ispacked"/>
			<dependency name="strcat"/>
			<dependency name="strpack"/>
			<dependency name="strunpack"/>
			<dependency name="tolower"/>
			<dependency name="true"/>
			<param name="dst">
				<paraminfo> [] </paraminfo>
				Where to store the converted string.
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
				The string to convert.
			</param>
			<param name="hash">
				<paraminfo> &amp; </paraminfo>
				Store the hash value.
			</param>
			<param name="wlen">
				The length of the destination.
			</param>
			<param name="delimiter">
				What character to place between the parts.
			</param>
			          <returns>  The length of string read.  </returns>  <remarks>  Takes a unicode string and converts it to punycode, while at the same time  generating a Bernstein hash of the string.  CASE INSENSITIVE.  </remarks> 
		</member>
		<member name="M:Puny_EncodeVar" syntax="Puny_EncodeVar(bias, delta, dst[], wlen)">
			<stacksize value="5"/>
			<referrer name="Puny_Encode"/>
			<dependency name="PUNY_TMAX"/>
			<dependency name="PUNY_TMIN"/>
			<param name="bias">
				Part of the state machine.
			</param>
			<param name="delta">
				Part of the state machine.
			</param>
			<param name="dst">
				<paraminfo> [] </paraminfo>
				Array to write to.
			</param>
			<param name="wlen">
				Size of the array.
			</param>
			        <remarks>  This is part of how the punycode algorithm encodes numbers as very clever  strings, but honestly I don't fully understand it!  </remarks> 
		</member>
		<member name="M:Puny_EncodeVarHash" syntax="Puny_EncodeVarHash(bias, delta, dst[], wlen, &amp;hash)">
			<stacksize value="5"/>
			<referrer name="Puny_EncodeHash"/>
			<dependency name="PUNY_TMAX"/>
			<dependency name="PUNY_TMIN"/>
			<param name="bias">
				Part of the state machine.
			</param>
			<param name="delta">
				Part of the state machine.
			</param>
			<param name="dst">
				<paraminfo> [] </paraminfo>
				Array to write to.
			</param>
			<param name="wlen">
				Size of the array.
			</param>
			<param name="hash">
				<paraminfo> &amp; </paraminfo>
				Hashed string.
			</param>
			          <remarks>  This is part of how the punycode algorithm encodes numbers as very clever  strings, but honestly I don't fully understand it!  </remarks> 
		</member>
		<member name="M:Push" syntax="Push(arg)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="PushString"/>
			<dependency name="false"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<dependency name="true"/>
			<param name="arg">
			</param>
		</member>
		<member name="M:PushString" syntax="PushString(string[])">
			<tagname value="bool"/>
			<stacksize value="5"/>
			<dependency name="Push"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:PutPlayerInVehicle" syntax="PutPlayerInVehicle(playerid, vehicleid, seatid)">
			<attribute name="native"/>
			<referrer name="@_yCjoinfight"/>
			<param name="playerid">
			</param>
			<param name="vehicleid">
			</param>
			<param name="seatid">
			</param>
		</member>
		<member name="M:R@" syntax="R@(buffer[])">
			<stacksize value="6"/>
			<referrer name="Command_GetName@"/>
			<referrer name="Command_GetDisplay@"/>
			<referrer name="Command_GetDisplayNamed@"/>
			<referrer name="Command_GetNext@"/>
			<dependency name="setproperty"/>
			<param name="buffer">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Random" syntax="Random(min, max)">
			<stacksize value="3"/>
			<dependency name="cellmin"/>
			<dependency name="random"/>
			<param name="min">
			</param>
			<param name="max">
				Upper bound.
			</param>
			<param name="minmax">Lower bound, or upper bound when only parameter.</param>    <remarks>  Generate a random float between the given numbers (min &lt;= n &lt; max).  Default minimum is 0 (changes the parameter order).  </remarks> 
		</member>
		<member name="M:RandomFloat" syntax="RandomFloat(min, max, dp)">
			<tagname value="Float"/>
			<stacksize value="5"/>
			<dependency name="operator!=(Float:,Float:)"/>
			<dependency name="operator-(Float:)"/>
			<dependency name="operator-(Float:,Float:)"/>
			<dependency name="operator+(Float:,Float:)"/>
			<dependency name="operator/(Float:,Float:)"/>
			<dependency name="operator*(Float:,Float:)"/>
			<dependency name="operator&lt;(Float:,Float:)"/>
			<dependency name="float"/>
			<dependency name="floatpower"/>
			<dependency name="floatround"/>
			<dependency name="random"/>
			<param name="min">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="max">
				<paraminfo>Float </paraminfo>
				Upper bound.
			</param>
			<param name="dp">
				How small to make the differences
			</param>
			<param name="minmax">Lower bound, or upper bound when only parameter.</param>      <remarks>  Generate a random float between the given numbers (min &lt;= n &lt; max).  Default  minimum is 0.0 (changes the parameter order).  </remarks> 
		</member>
		<member name="M:Range" syntax="Range(arr[], num)">
			<stacksize value="4"/>
			<dependency name="cellmax"/>
			<dependency name="cellmin"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array whose values need averaging.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <returns>  The mathematical range of the values of the array.  </returns> 
		</member>
		<member name="M:ReadAmxCell" syntax="ReadAmxCell(offset)">
			<stacksize value="5"/>
			<dependency name="GetAmxAddress"/>
			<dependency name="ReadPhysMemoryCell"/>
			<param name="offset">
			</param>
		</member>
		<member name="M:ReadAmxMemory" syntax="ReadAmxMemory(address)">
			<stacksize value="1"/>
			<referrer name="ReadAmxMemoryArray"/>
			<referrer name="GetRawAmxHeader"/>
			<referrer name="NtCompare"/>
			<referrer name="NtCopy"/>
			<referrer name="GetPublicIndexFromAddress"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="HookPublic"/>
			<referrer name="GetNativeIndexFromAddress"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="HookNative"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetPubVarIndexFromAddress"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagIndexFromName"/>
			<referrer name="GetTagIndexFromID"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="DisasmGetOperand"/>
			<referrer name="DisasmGetNumOperands"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DisasmWriteDataRowChar"/>
			<referrer name="DisasmWriteDataRowHex"/>
			<referrer name="CodeScanCheckJumpTarget"/>
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanRunFastPrescan"/>
			<referrer name="DumpStack"/>
			<referrer name="YVA2_FoundCall"/>
			<param name="address">
			</param>
		</member>
		<member name="M:ReadAmxMemoryArray" syntax="ReadAmxMemoryArray(address, values[], size)">
			<stacksize value="5"/>
			<dependency name="ReadAmxMemory"/>
			<param name="address">
			</param>
			<param name="values">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:ReadOpcodeNearThis" syntax="ReadOpcodeNearThis(offset)">
			<tagname value="Opcode"/>
			<stacksize value="2"/>
			<referrer name="HaveToRelocateOpcodes"/>
			<referrer name="RelocateOpcodeNow"/>
			<dependency name="OP_NONE"/>
			<param name="offset">
			</param>
		</member>
		<member name="M:ReadPhysMemory" syntax="ReadPhysMemory(address, dest[], num)">
			<stacksize value="5"/>
			<dependency name="AbsToRel"/>
			<param name="address">
			</param>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:ReadPhysMemoryCell" syntax="ReadPhysMemoryCell(address)">
			<stacksize value="5"/>
			<referrer name="ReadAmxCell"/>
			<dependency name="AbsToRel"/>
			<param name="address">
			</param>
		</member>
		<member name="M:RelToAbs" syntax="RelToAbs(address)">
			<stacksize value="3"/>
			<referrer name="refabs"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetDat"/>
			<param name="address">
			</param>
		</member>
		<member name="M:RelocateOpcode" syntax="RelocateOpcode(opcode)">
			<tagname value="Opcode"/>
			<stacksize value="3"/>
			<referrer name="SysreqC"/>
			<referrer name="SysreqD"/>
			<referrer name="SysreqCN"/>
			<referrer name="SysreqDN"/>
			<referrer name="CallNative"/>
			<referrer name="CallNativeByAddress"/>
			<referrer name="AsmEmitOpcode"/>
			<referrer name="AsmEmitPadding"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="CodeScanInit"/>
			<referrer name="GetOS"/>
			<referrer name="new_pec"/>
			<referrer name="YVA2_CodeGenShiftCode"/>
			<referrer name="CGen_SetupCodeSpace"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<dependency name="InitOpcodeTable"/>
			<dependency name="opcode_table"/>
			<dependency name="opcode_table_is_ready"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:RelocateOpcodeNow" syntax="RelocateOpcodeNow(opcode)">
			<tagname value="Opcode"/>
			<stacksize value="5"/>
			<referrer name="RelocateOpcodeNow"/>
			<referrer name="InitOpcodeTable"/>
			<dependency name="HaveToRelocateOpcodes"/>
			<dependency name="OP_ADD"/>
			<dependency name="OP_ADDR_ALT"/>
			<dependency name="OP_ADDR_PRI"/>
			<dependency name="OP_ADD_C"/>
			<dependency name="OP_ALIGN_ALT"/>
			<dependency name="OP_ALIGN_PRI"/>
			<dependency name="OP_AND"/>
			<dependency name="OP_BOUNDS"/>
			<dependency name="OP_BREAK"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_CMPS"/>
			<dependency name="OP_CONST_ALT"/>
			<dependency name="OP_CONST_PRI"/>
			<dependency name="OP_DEC"/>
			<dependency name="OP_DEC_ALT"/>
			<dependency name="OP_DEC_I"/>
			<dependency name="OP_DEC_PRI"/>
			<dependency name="OP_DEC_S"/>
			<dependency name="OP_EQ"/>
			<dependency name="OP_EQ_C_ALT"/>
			<dependency name="OP_EQ_C_PRI"/>
			<dependency name="OP_FILL"/>
			<dependency name="OP_GEQ"/>
			<dependency name="OP_GRTR"/>
			<dependency name="OP_HALT"/>
			<dependency name="OP_HEAP"/>
			<dependency name="OP_IDXADDR"/>
			<dependency name="OP_IDXADDR_B"/>
			<dependency name="OP_INC"/>
			<dependency name="OP_INC_ALT"/>
			<dependency name="OP_INC_I"/>
			<dependency name="OP_INC_PRI"/>
			<dependency name="OP_INC_S"/>
			<dependency name="OP_INVERT"/>
			<dependency name="OP_JEQ"/>
			<dependency name="OP_JGEQ"/>
			<dependency name="OP_JGRTR"/>
			<dependency name="OP_JLEQ"/>
			<dependency name="OP_JLESS"/>
			<dependency name="OP_JNEQ"/>
			<dependency name="OP_JNZ"/>
			<dependency name="OP_JSGEQ"/>
			<dependency name="OP_JSGRTR"/>
			<dependency name="OP_JSLEQ"/>
			<dependency name="OP_JSLESS"/>
			<dependency name="OP_JUMP"/>
			<dependency name="OP_JZER"/>
			<dependency name="OP_LCTRL"/>
			<dependency name="OP_LEQ"/>
			<dependency name="OP_LESS"/>
			<dependency name="OP_LIDX"/>
			<dependency name="OP_LIDX_B"/>
			<dependency name="OP_LOAD_ALT"/>
			<dependency name="OP_LOAD_I"/>
			<dependency name="OP_LOAD_PRI"/>
			<dependency name="OP_LOAD_S_ALT"/>
			<dependency name="OP_LOAD_S_PRI"/>
			<dependency name="OP_LODB_I"/>
			<dependency name="OP_LREF_ALT"/>
			<dependency name="OP_LREF_PRI"/>
			<dependency name="OP_LREF_S_ALT"/>
			<dependency name="OP_LREF_S_PRI"/>
			<dependency name="OP_MOVE_ALT"/>
			<dependency name="OP_MOVE_PRI"/>
			<dependency name="OP_MOVS"/>
			<dependency name="OP_NEG"/>
			<dependency name="OP_NEQ"/>
			<dependency name="OP_NOP"/>
			<dependency name="OP_NOT"/>
			<dependency name="OP_OR"/>
			<dependency name="OP_POP_ALT"/>
			<dependency name="OP_POP_PRI"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_PUSH"/>
			<dependency name="OP_PUSH_ADR"/>
			<dependency name="OP_PUSH_ALT"/>
			<dependency name="OP_PUSH_C"/>
			<dependency name="OP_PUSH_PRI"/>
			<dependency name="OP_PUSH_S"/>
			<dependency name="OP_RET"/>
			<dependency name="OP_RETN"/>
			<dependency name="OP_SCTRL"/>
			<dependency name="OP_SDIV"/>
			<dependency name="OP_SDIV_ALT"/>
			<dependency name="OP_SGEQ"/>
			<dependency name="OP_SGRTR"/>
			<dependency name="OP_SHL"/>
			<dependency name="OP_SHL_C_ALT"/>
			<dependency name="OP_SHL_C_PRI"/>
			<dependency name="OP_SHR"/>
			<dependency name="OP_SHR_C_ALT"/>
			<dependency name="OP_SHR_C_PRI"/>
			<dependency name="OP_SIGN_ALT"/>
			<dependency name="OP_SIGN_PRI"/>
			<dependency name="OP_SLEQ"/>
			<dependency name="OP_SLESS"/>
			<dependency name="OP_SMUL"/>
			<dependency name="OP_SMUL_C"/>
			<dependency name="OP_SREF_ALT"/>
			<dependency name="OP_SREF_PRI"/>
			<dependency name="OP_SREF_S_ALT"/>
			<dependency name="OP_SREF_S_PRI"/>
			<dependency name="OP_SSHR"/>
			<dependency name="OP_STACK"/>
			<dependency name="OP_STOR_ALT"/>
			<dependency name="OP_STOR_I"/>
			<dependency name="OP_STOR_PRI"/>
			<dependency name="OP_STOR_S_ALT"/>
			<dependency name="OP_STOR_S_PRI"/>
			<dependency name="OP_STRB_I"/>
			<dependency name="OP_SUB"/>
			<dependency name="OP_SUB_ALT"/>
			<dependency name="OP_SWAP_ALT"/>
			<dependency name="OP_SWAP_PRI"/>
			<dependency name="OP_SWITCH"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="OP_UDIV"/>
			<dependency name="OP_UDIV_ALT"/>
			<dependency name="OP_UMUL"/>
			<dependency name="OP_XCHG"/>
			<dependency name="OP_XOR"/>
			<dependency name="OP_ZERO"/>
			<dependency name="OP_ZERO_ALT"/>
			<dependency name="OP_ZERO_PRI"/>
			<dependency name="OP_ZERO_S"/>
			<dependency name="ReadOpcodeNearThis"/>
			<dependency name="debug"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:ResetStaticAmxHeader" syntax="ResetStaticAmxHeader()">
			<stacksize value="4"/>
			<referrer name="GetAmxHeader"/>
			<referrer name="GetAmxHeaderComponent"/>
			<referrer name="PrintAmxHeader"/>
			<referrer name="GetPublicIndexFromAddress"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="HookPublic"/>
			<referrer name="GetNativeIndexFromAddress"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="HookNative"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetPubVarIndexFromAddress"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagIndexFromName"/>
			<referrer name="GetTagIndexFromID"/>
			<referrer name="Hooks_SortPublics"/>
			<dependency name="GetAmxHeaderNow"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="true"/>
		</member>
		<member name="M:ResolveJITAddress" syntax="ResolveJITAddress(addr)">
			<stacksize value="1"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:ReturnPlayerName" syntax="ReturnPlayerName(playerid)">
			<stacksize value="29"/>
			<dependency name="GetPlayerName"/>
			<dependency name="ReturnPlayerName"/>
			<param name="playerid">
				Player whose name you want to get.
			</param>
			<summary>  ReturnPlayerName  </summary>    <remarks>  Now uses a global array to avoid repeated function calls.  Actually doesn't  because that causes issues with multiple scripts.  </remarks> 
		</member>
		<member name="M:ReturnUser" syntax="ReturnUser(text[])">
			<stacksize value="36"/>
			<dependency name="GetPlayerName"/>
			<dependency name="IsPlayerConnected"/>
			<dependency name="isNumeric"/>
			<dependency name="strcmp"/>
			<dependency name="strlen"/>
			<dependency name="strval"/>
			<dependency name="true"/>
			<param name="text">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:RunShellcode" syntax="RunShellcode(code_ptr, align)">
			<stacksize value="5"/>
			<referrer name="GetAmxAddress"/>
			<dependency name="SysreqD"/>
			<param name="code_ptr">
			</param>
			<param name="align">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:S@" syntax="S@(v)">
			<stacksize value="6"/>
			<dependency name="Q@"/>
			<dependency name="getproperty"/>
			<dependency name="setproperty"/>
			<dependency name="strunpack"/>
			<param name="v">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:ScriptInit_OnFilterScriptExit" syntax="ScriptInit_OnFilterScriptExit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_ALS"/>
			<referrer name="OnFilterScriptExit"/>
		</member>
		<member name="M:ScriptInit_OnFilterScriptInit" syntax="ScriptInit_OnFilterScriptInit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_ALS"/>
			<referrer name="OnFilterScriptInit"/>
		</member>
		<member name="M:ScriptInit_OnGameModeExit" syntax="ScriptInit_OnGameModeExit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_ALS"/>
			<referrer name="OnGameModeExit"/>
		</member>
		<member name="M:ScriptInit_OnGameModeInit" syntax="ScriptInit_OnGameModeInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="_ALS"/>
			<referrer name="OnGameModeInit"/>
			<dependency name="DisableInteriorEnterExits"/>
			<dependency name="EnableStuntBonusForAll"/>
			<dependency name="SetGameModeText"/>
			<dependency name="SetNameTagDrawDistance"/>
			<dependency name="SetWeather"/>
			<dependency name="SetWorldTime"/>
			<dependency name="ShowNameTags"/>
			<dependency name="ShowPlayerMarkers"/>
		</member>
		<member name="M:ScriptInit_OnScriptExit" syntax="ScriptInit_OnScriptExit()">
			<attribute name="public"/>
			<stacksize value="13"/>
			<automaton name="_ALS"/>
			<referrer name="OnFilterScriptExit"/>
			<referrer name="OnGameModeExit"/>
			<dependency name="CallLocalFunction"/>
			<dependency name="CallRemoteFunction"/>
			<dependency name="Master_OnScriptExit"/>
			<dependency name="YSI_g_sMasterCount"/>
			<dependency name="YSI_g_sMasterData"/>
			<dependency name="_@"/>
			<dependency name="getproperty"/>
			<dependency name="setproperty"/>
			<returns>  OnGameModeExit  </returns>  <remarks>  Destructor.  </remarks> 
		</member>
		<member name="M:ScriptInit_OnScriptInit" syntax="ScriptInit_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="print"/>
		</member>
		<member name="M:SendClientMessage" syntax="SendClientMessage(playerid, color, message[])">
			<attribute name="native"/>
			<referrer name="va_SendClientMessage"/>
			<referrer name="_y_utils_OnPlayerConnect"/>
			<param name="playerid">
			</param>
			<param name="color">
			</param>
			<param name="message">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:SendClientMessageToAll" syntax="SendClientMessageToAll(color, message[])">
			<attribute name="native"/>
			<referrer name="va_SendClientMessageToAll"/>
			<param name="color">
			</param>
			<param name="message">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:SendPlayerMessageToAll" syntax="SendPlayerMessageToAll(senderid, message[])">
			<attribute name="native"/>
			<referrer name="va_SendPlayerMessageToAll"/>
			<param name="senderid">
			</param>
			<param name="message">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:SendPlayerMessageToPlayer" syntax="SendPlayerMessageToPlayer(playerid, senderid, message[])">
			<attribute name="native"/>
			<referrer name="va_SendPlayerMessageToPlayer"/>
			<param name="playerid">
			</param>
			<param name="senderid">
			</param>
			<param name="message">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:SetAmxFrame" syntax="SetAmxFrame(ptr)">
			<stacksize value="1"/>
			<param name="ptr">
			</param>
		</member>
		<member name="M:SetAmxHeapTop" syntax="SetAmxHeapTop(ptr)">
			<stacksize value="1"/>
			<param name="ptr">
			</param>
		</member>
		<member name="M:SetAmxNextInstructionPointer" syntax="SetAmxNextInstructionPointer(ptr)">
			<stacksize value="1"/>
			<param name="ptr">
			</param>
		</member>
		<member name="M:SetAmxStackBottom" syntax="SetAmxStackBottom(ptr)">
			<stacksize value="1"/>
			<param name="ptr">
			</param>
		</member>
		<member name="M:SetCurrentFramePreviousFrame" syntax="SetCurrentFramePreviousFrame(addr)">
			<stacksize value="5"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="SetFramePreviousFrame"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:SetCurrentFrameReturn" syntax="SetCurrentFrameReturn(addr)">
			<stacksize value="5"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="SetFrameReturn"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:SetCurrentParameterCount" syntax="SetCurrentParameterCount(count)">
			<stacksize value="5"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="SetFrameParameterCount"/>
			<param name="count">
			</param>
		</member>
		<member name="M:SetCurrentParameterSize" syntax="SetCurrentParameterSize(size)">
			<stacksize value="5"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="SetFrameParameterSize"/>
			<param name="size">
			</param>
		</member>
		<member name="M:SetFrameLocal" syntax="SetFrameLocal(frm_addr, param, value)">
			<stacksize value="1"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:SetFrameParameter" syntax="SetFrameParameter(frm_addr, param, value, idx)">
			<stacksize value="1"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
			<param name="value">
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:SetFrameParameterCount" syntax="SetFrameParameterCount(frm_addr, count)">
			<stacksize value="5"/>
			<referrer name="SetCurrentParameterCount"/>
			<dependency name="SetFrameParameterSize"/>
			<param name="frm_addr">
			</param>
			<param name="count">
			</param>
		</member>
		<member name="M:SetFrameParameterSize" syntax="SetFrameParameterSize(frm_addr, size)">
			<stacksize value="1"/>
			<referrer name="SetFrameParameterCount"/>
			<referrer name="SetCurrentParameterSize"/>
			<param name="frm_addr">
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:SetFramePreviousFrame" syntax="SetFramePreviousFrame(frm_addr, addr)">
			<stacksize value="1"/>
			<referrer name="SetCurrentFramePreviousFrame"/>
			<param name="frm_addr">
			</param>
			<param name="addr">
			</param>
		</member>
		<member name="M:SetFrameReturn" syntax="SetFrameReturn(frm_addr, addr)">
			<stacksize value="1"/>
			<referrer name="SetCurrentFrameReturn"/>
			<param name="frm_addr">
			</param>
			<param name="addr">
			</param>
		</member>
		<member name="M:SetFrameVariable" syntax="SetFrameVariable(frm_addr, param, value, idx)">
			<stacksize value="1"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
			<param name="value">
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:SetGameModeText" syntax="SetGameModeText(string[])">
			<attribute name="native"/>
			<referrer name="ScriptInit_OnGameModeInit"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:SetNameTagDrawDistance" syntax="SetNameTagDrawDistance(distance)">
			<attribute name="native"/>
			<referrer name="ScriptInit_OnGameModeInit"/>
			<param name="distance">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:SetPlayerFacingAngle" syntax="SetPlayerFacingAngle(playerid, ang)">
			<attribute name="native"/>
			<referrer name="OnPlayerSpawn"/>
			<param name="playerid">
			</param>
			<param name="ang">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:SetPlayerPos" syntax="SetPlayerPos(playerid, x, y, z)">
			<attribute name="native"/>
			<referrer name="OnPlayerSpawn"/>
			<param name="playerid">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:SetSpawnInfo" syntax="SetSpawnInfo(playerid, team, skin, x, y, z, rotation, weapon1, weapon1_ammo, weapon2, weapon2_ammo, weapon3, weapon3_ammo)">
			<attribute name="native"/>
			<referrer name="OnPlayerRequestClass"/>
			<param name="playerid">
			</param>
			<param name="team">
			</param>
			<param name="skin">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="rotation">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="weapon1">
			</param>
			<param name="weapon1_ammo">
			</param>
			<param name="weapon2">
			</param>
			<param name="weapon2_ammo">
			</param>
			<param name="weapon3">
			</param>
			<param name="weapon3_ammo">
			</param>
		</member>
		<member name="M:SetTimerEx" syntax="SetTimerEx(funcname[], interval, repeating, format[], ...)">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="_@_y_cgen_@_0"/>
			<referrer name="@yH_OnPlayerDisconnect@003"/>
			<param name="funcname">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="interval">
			</param>
			<param name="repeating">
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:SetWeather" syntax="SetWeather(weatherid)">
			<attribute name="native"/>
			<referrer name="ScriptInit_OnGameModeInit"/>
			<param name="weatherid">
			</param>
		</member>
		<member name="M:SetWorldTime" syntax="SetWorldTime(hour)">
			<attribute name="native"/>
			<referrer name="ScriptInit_OnGameModeInit"/>
			<param name="hour">
			</param>
		</member>
		<member name="M:ShowNameTags" syntax="ShowNameTags(show)">
			<attribute name="native"/>
			<referrer name="ScriptInit_OnGameModeInit"/>
			<param name="show">
			</param>
		</member>
		<member name="M:ShowPlayerMarkers" syntax="ShowPlayerMarkers(mode)">
			<attribute name="native"/>
			<referrer name="ScriptInit_OnGameModeInit"/>
			<param name="mode">
			</param>
		</member>
		<member name="M:SkipWhitespace" syntax="SkipWhitespace(str[], pos)">
			<stacksize value="1"/>
			<dependency name="cellmin"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to skip over part of.
			</param>
			<param name="pos">
				The start of the whitespace.
			</param>
			    <returns>  The end of the whitespace.  </returns>  <remarks>  Doesn't skip over NULL terminators.  </remarks> 
		</member>
		<member name="M:SpawnPlayer" syntax="SpawnPlayer(playerid)">
			<attribute name="native"/>
			<referrer name="OnPlayerRequestClass"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:StrToLower" syntax="StrToLower(str[], len)">
			<stacksize value="5"/>
			<dependency name="tolower"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to convert.
			</param>
			<param name="len">
				How much of the string to convert.
			</param>
			   
		</member>
		<member name="M:StrToUpper" syntax="StrToUpper(str[], len)">
			<stacksize value="5"/>
			<dependency name="toupper"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to convert.
			</param>
			<param name="len">
				How much of the string to convert.
			</param>
			   
		</member>
		<member name="M:Strip" syntax="Strip(str[])">
			<stacksize value="9"/>
			<dependency name="memcpy"/>
			<dependency name="strlen"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to remove whitespace from the start and end of.
			</param>
			 
		</member>
		<member name="M:StripL" syntax="StripL(str[])">
			<stacksize value="9"/>
			<dependency name="memcpy"/>
			<dependency name="strlen"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to remove whitespace from the start of.
			</param>
			 
		</member>
		<member name="M:StripNL" syntax="StripNL(str[])">
			<stacksize value="4"/>
			<dependency name="strlen"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to remove whitespace from the end of.
			</param>
			  <remarks>  Updated from old versions, should be more efficient  </remarks> 
		</member>
		<member name="M:Sum" syntax="Sum(arr[], num)">
			<stacksize value="2"/>
			<referrer name="Mean"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array whose values need summing.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <returns>  All the values in the array added together.  </returns> 
		</member>
		<member name="M:SysreqC" syntax="SysreqC(index, auto_pop)">
			<stacksize value="9"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="index">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:SysreqCN" syntax="SysreqCN(index, args_to_push, auto_pop)">
			<stacksize value="10"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="index">
			</param>
			<param name="args_to_push">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:SysreqD" syntax="SysreqD(address, auto_pop)">
			<stacksize value="9"/>
			<referrer name="RunShellcode"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="address">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:SysreqDN" syntax="SysreqDN(address, args_to_push, auto_pop)">
			<stacksize value="10"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="address">
			</param>
			<param name="args_to_push">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:TextDrawCreate" syntax="TextDrawCreate(x, y, text[])">
			<tagname value="Text"/>
			<attribute name="native"/>
			<referrer name="va_TextDrawCreate"/>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="text">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:ToHexStr" syntax="ToHexStr(x)">
			<stacksize value="15"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DisasmWriteDataRowHex"/>
			<referrer name="DisasmWriteData"/>
			<dependency name="ToHexStr"/>
			<param name="x">
			</param>
		</member>
		<member name="M:ToPrintableAscii" syntax="ToPrintableAscii(c)">
			<stacksize value="4"/>
			<referrer name="DisasmWriteDataRowChar"/>
			<dependency name="IsPrintableAscii"/>
			<param name="c">
			</param>
		</member>
		<member name="M:TogglePlayerClock" syntax="TogglePlayerClock(playerid, toggle)">
			<attribute name="native"/>
			<referrer name="OnPlayerSpawn"/>
			<param name="playerid">
			</param>
			<param name="toggle">
			</param>
		</member>
		<member name="M:Trim" syntax="Trim(str[], &amp;start, &amp;end)">
			<stacksize value="1"/>
			<dependency name="cellmin"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to trim.
			</param>
			<param name="start">
				<paraminfo> &amp; </paraminfo>
				Start of the substring.
			</param>
			<param name="end">
				<paraminfo> &amp; </paraminfo>
				End of the substring.
			</param>
			      <remarks>  Modifies "start" and "end" to be tight on text in "str".  </remarks> 
		</member>
		<member name="M:U@" syntax="U@(id, name[], value, string[])">
			<attribute name="native"/>
			<referrer name="Master_Reassert"/>
			<referrer name="@yC_joinfight"/>
			<param name="id">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="value">
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:UnrelocateOpcode" syntax="UnrelocateOpcode(opcode)">
			<tagname value="Opcode"/>
			<stacksize value="3"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="CodeScanRunFastPrescan"/>
			<dependency name="InitOpcodeTable"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="opcode_table"/>
			<dependency name="opcode_table_is_ready"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:Utils_PreSort" syntax="Utils_PreSort(arr[], num)">
			<stacksize value="4"/>
			<referrer name="Mode"/>
			<referrer name="Median"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array to sort.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <remarks>  Sorts the array in place.  Uses bubble sort because it is easy and fast for  pre-sorted arrays (which the callers are likely to be).  </remarks> 
		</member>
		<member name="M:V@" syntax="V@(id, name[], value, string[])">
			<attribute name="native"/>
			<referrer name="Command_GetID"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="Command_GetPlayerDisabled"/>
			<referrer name="Command_GetPlayer"/>
			<referrer name="Command_GetPlayerNamed"/>
			<referrer name="Command_Find"/>
			<referrer name="Command_GetDeniedReturn"/>
			<referrer name="Command_GetIllegalReturn"/>
			<referrer name="Command_GetUnknownReturn"/>
			<referrer name="Command_GetDisconnectReturn"/>
			<referrer name="Command_AddAltNamed"/>
			<referrer name="Command_IsValid"/>
			<referrer name="Command_GetCurrent"/>
			<referrer name="Command_GetPlayerCommandCount"/>
			<referrer name="Iter_Func@Command"/>
			<referrer name="Iter_Func@PlayerCommand"/>
			<referrer name="Command_Add"/>
			<param name="id">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="value">
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:VA_OnScriptInit" syntax="VA_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="9"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="CallFunction"/>
			<dependency name="HookChain_OnScriptInit"/>
			<dependency name="Hooks_DoAllHooks"/>
			<dependency name="Hooks_InvalidateName"/>
			<dependency name="Hooks_SortReplacements"/>
			<remarks>  Call the main hook run code, then advance the ALS chain.  </remarks>  <transition keep="true" target="_ALS : _ALS_go"/>  <transition target="Jai"/>

		</member>
		<member name="M:W@" syntax="W@(function[], format[], ...)">
			<attribute name="native"/>
			<referrer name="Iter_ActorDo_"/>
			<referrer name="Iter_VehicleDo_"/>
			<referrer name="Command_GetID"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="Command_SetPlayerDisabled"/>
			<referrer name="Command_GetPlayerDisabled"/>
			<referrer name="Command_GetPlayer"/>
			<referrer name="Command_GetPlayerNamed"/>
			<referrer name="Command_SetPlayer"/>
			<referrer name="Command_SetPlayerNamed"/>
			<referrer name="Command_Find"/>
			<referrer name="Command_TouchNamed"/>
			<referrer name="Command_Touch"/>
			<referrer name="Command_SetDeniedReturn"/>
			<referrer name="Command_GetDeniedReturn"/>
			<referrer name="Command_SetIllegalReturn"/>
			<referrer name="Command_GetIllegalReturn"/>
			<referrer name="Command_SetUnknownReturn"/>
			<referrer name="Command_GetUnknownReturn"/>
			<referrer name="Command_SetDisconnectReturn"/>
			<referrer name="Command_GetDisconnectReturn"/>
			<referrer name="Command_AddAltNamed"/>
			<referrer name="Command_Remove"/>
			<referrer name="Command_RemoveNamed"/>
			<referrer name="Command_IsValid"/>
			<referrer name="Command_GetCurrent"/>
			<referrer name="Command_GetPlayerCommandCount"/>
			<referrer name="Command_GetName"/>
			<referrer name="Command_GetDisplay"/>
			<referrer name="Command_GetDisplayNamed"/>
			<referrer name="Command_GetNext"/>
			<referrer name="Iter_Func@Command"/>
			<referrer name="Iter_Func@PlayerCommand"/>
			<referrer name="_Command_Rebuild"/>
			<referrer name="Command_IncOPCR"/>
			<referrer name="Command_DecOPCR"/>
			<referrer name="Command_IncOPCP"/>
			<referrer name="Command_DecOPCP"/>
			<referrer name="Command_Add"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:WriteAmxCell" syntax="WriteAmxCell(offset, value)">
			<stacksize value="6"/>
			<dependency name="GetAmxAddress"/>
			<dependency name="WritePhysMemoryCell"/>
			<param name="offset">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:WriteAmxMemory" syntax="WriteAmxMemory(address, value)">
			<stacksize value="1"/>
			<referrer name="WriteAmxMemoryArray"/>
			<referrer name="HookPublic"/>
			<referrer name="HookNative"/>
			<referrer name="AsmEmitCell"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="AsmEmitPadding"/>
			<param name="address">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:WriteAmxMemoryArray" syntax="WriteAmxMemoryArray(address, values[], size)">
			<stacksize value="6"/>
			<dependency name="WriteAmxMemory"/>
			<param name="address">
			</param>
			<param name="values">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:WritePhysMemory" syntax="WritePhysMemory(address, src[], num)">
			<stacksize value="5"/>
			<dependency name="AbsToRel"/>
			<param name="address">
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:WritePhysMemoryCell" syntax="WritePhysMemoryCell(address, what)">
			<stacksize value="5"/>
			<referrer name="WriteAmxCell"/>
			<dependency name="AbsToRel"/>
			<param name="address">
			</param>
			<param name="what">
			</param>
		</member>
		<member name="M:X@" syntax="X@(n)">
			<stacksize value="6"/>
			<referrer name="Command_GetID@"/>
			<referrer name="Command_AddAlt@"/>
			<referrer name="Command_ReProcess@"/>
			<referrer name="Command_GetPlayerDisabled@"/>
			<referrer name="Command_GetPlayer@"/>
			<referrer name="Command_GetPlayerNamed@"/>
			<referrer name="Command_Find@"/>
			<referrer name="Command_GetDeniedReturn@"/>
			<referrer name="Command_GetIllegalReturn@"/>
			<referrer name="Command_GetUnknownReturn@"/>
			<referrer name="Command_GetDisconnectReturn@"/>
			<referrer name="Command_AddAltNamed@"/>
			<referrer name="Command_IsValid@"/>
			<referrer name="Command_GetCurrent@"/>
			<referrer name="Command_GetPlayerCommandCount@"/>
			<referrer name="Iter_Func@Command@"/>
			<referrer name="Iter_Func@PlayerCommand@"/>
			<referrer name="Command_Add@"/>
			<dependency name="setproperty"/>
			<param name="n">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:Y@" syntax="Y@()">
			<stacksize value="6"/>
			<referrer name="Command_Add"/>
			<dependency name="_@"/>
			<dependency name="setproperty"/>
		</member>
		<member name="M:YHash" syntax="YHash(str[], sensitive, type, len, pack)">
			<stacksize value="5"/>
			<referrer name="HashMap_Add"/>
			<referrer name="HashMap_Get"/>
			<referrer name="HashMap_RemoveKey"/>
			<dependency name="hash_bernstein"/>
			<dependency name="hash_fnv1"/>
			<dependency name="hash_fnv1a"/>
			<dependency name="min"/>
			<dependency name="strlen"/>
			<dependency name="toupper"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="sensitive">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="type">
				<paraminfo>e_HASH_TYPE </paraminfo>
			</param>
			<param name="len">
			</param>
			<param name="pack">
			</param>
		</member>
		<member name="M:YSIM_OnMasterSystemInit" syntax="YSIM_OnMasterSystemInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="Master_GetCurrentMaster"/>
		</member>
		<member name="M:YSI_g_sCommandFlags@Dist" syntax="YSI_g_sCommandFlags@Dist(a[], s)">
			<attribute name="public"/>
			<stacksize value="6"/>
			<automaton name="@_"/>
			<dependency name="Distribute_To"/>
			<dependency name="YSI_g_sCommandFlags"/>
			<param name="a">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="s">
			</param>
		</member>
		<member name="M:YSI_g_sCommandFlags_Dist" syntax="YSI_g_sCommandFlags_Dist()">
			<tagname value="DIST_STRIP"/>
			<stacksize value="5"/>
			<referrer name="HANDOFF_SOURCE@_"/>
			<dependency name="Distribute_Do"/>
			<dependency name="YSI_g_sCommandFlags"/>
		</member>
		<member name="M:YSI_g_sCommands@Dist" syntax="YSI_g_sCommands@Dist(i, m, a[], s)">
			<attribute name="public"/>
			<stacksize value="8"/>
			<automaton name="@_"/>
			<dependency name="Distribute_To"/>
			<dependency name="E_COMMAND"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sMasterData"/>
			<param name="i">
			</param>
			<param name="m">
			</param>
			<param name="a">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="s">
			</param>
		</member>
		<member name="M:YSI_g_sCommands_Dist" syntax="YSI_g_sCommands_Dist()">
			<tagname value="DIST_STRIP"/>
			<stacksize value="10"/>
			<referrer name="HANDOFF_SOURCE@_"/>
			<dependency name="Distribute_So"/>
			<dependency name="E_COMMAND"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sMasterData"/>
		</member>
		<member name="M:YSI_g_sDisabledPlayers@Dist" syntax="YSI_g_sDisabledPlayers@Dist(a[], s)">
			<attribute name="public"/>
			<stacksize value="8"/>
			<automaton name="@_"/>
			<dependency name="Distribute_To"/>
			<dependency name="YSI_g_sDisabledPlayers"/>
			<param name="a">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="s">
			</param>
		</member>
		<member name="M:YSI_g_sDisabledPlayers_Dist" syntax="YSI_g_sDisabledPlayers_Dist()">
			<tagname value="DIST_ST2"/>
			<stacksize value="7"/>
			<referrer name="HANDOFF_SOURCE@_"/>
			<dependency name="Distribute_Do"/>
			<dependency name="YSI_g_sDisabledPlayers"/>
		</member>
		<member name="M:YSI_g_sErrorMessages@Dist" syntax="YSI_g_sErrorMessages@Dist(a[], s)">
			<attribute name="public"/>
			<stacksize value="10"/>
			<automaton name="@_"/>
			<dependency name="Distribute_To"/>
			<dependency name="YSI_g_sErrorMessages"/>
			<dependency name="e_COMMAND_ERRORS"/>
			<param name="a">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="s">
			</param>
		</member>
		<member name="M:YSI_g_sErrorMessages_Dist" syntax="YSI_g_sErrorMessages_Dist()">
			<tagname value="DIST_STRIP"/>
			<stacksize value="9"/>
			<referrer name="HANDOFF_SOURCE@_"/>
			<dependency name="Distribute_Do"/>
			<dependency name="YSI_g_sErrorMessages"/>
			<dependency name="e_COMMAND_ERRORS"/>
		</member>
		<member name="M:YVA2_CodeGenDeepCleanup" syntax="YVA2_CodeGenDeepCleanup(ctx[], depth, returningString)">
			<stacksize value="5"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="AsmEmitPopPri"/>
			<dependency name="AsmEmitStack"/>
			<dependency name="cellbits"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="depth">
			</param>
			<param name="returningString">
			</param>
		</member>
		<member name="M:YVA2_CodeGenMainCleanup" syntax="YVA2_CodeGenMainCleanup(ctx[])">
			<stacksize value="5"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="AsmEmitAdd"/>
			<dependency name="AsmEmitLctrl"/>
			<dependency name="AsmEmitLoadPri"/>
			<dependency name="AsmEmitPopAlt"/>
			<dependency name="AsmEmitSctrl"/>
			<dependency name="AsmEmitStorPri"/>
			<dependency name="ref"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:YVA2_CodeGenPushSite" syntax="YVA2_CodeGenPushSite(ctx[], pushedBytes, skippedBytes, offset)">
			<stacksize value="7"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="AsmEmitAddrPri"/>
			<dependency name="AsmEmitCallAbs"/>
			<dependency name="AsmEmitHeap"/>
			<dependency name="AsmEmitPushC"/>
			<dependency name="AsmEmitPushPri"/>
			<dependency name="O@A_"/>
			<dependency name="O@V_"/>
			<dependency name="YVA2_DoPush"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="pushedBytes">
			</param>
			<param name="skippedBytes">
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:YVA2_CodeGenPushVariable" syntax="YVA2_CodeGenPushVariable(ctx[], stack)">
			<stacksize value="5"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="AsmEmitPushS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="stack">
			</param>
		</member>
		<member name="M:YVA2_CodeGenShiftCode" syntax="YVA2_CodeGenShiftCode(dest, src, end)">
			<stacksize value="4"/>
			<referrer name="YVA2_FoundCall"/>
			<dependency name="OP_NOP"/>
			<dependency name="RelocateOpcode"/>
			<param name="dest">
			</param>
			<param name="src">
			</param>
			<param name="end">
			</param>
		</member>
		<member name="M:YVA2_DoPush" syntax="YVA2_DoPush(skippedBytes, pushedBytes, pushRequirements)">
			<stacksize value="1"/>
			<referrer name="YVA2_DummyPush"/>
			<referrer name="YVA2_CodeGenPushSite"/>
			<dependency name="memcpy"/>
			<param name="skippedBytes">
			</param>
			<param name="pushedBytes">
			</param>
			<param name="pushRequirements">
			</param>
		</member>
		<member name="M:YVA2_DummyPush" syntax="YVA2_DummyPush(skippedBytes, pushedBytes, pushRequirements, dummy0, dummy1, dummy2, dummy3, dummy4, dummy5)">
			<stacksize value="6"/>
			<referrer name="YVA2_Initalise"/>
			<referrer name="va_CreatePlayerTextDraw"/>
			<referrer name="va_TextDrawCreate"/>
			<referrer name="va_SendClientMessage"/>
			<referrer name="va_SendClientMessageToAll"/>
			<referrer name="va_SendPlayerMessageToPlayer"/>
			<referrer name="va_SendPlayerMessageToAll"/>
			<referrer name="va_GameTextForPlayer"/>
			<referrer name="va_GameTextForAll"/>
			<referrer name="va_print"/>
			<referrer name="va_fprintf"/>
			<dependency name="Debug_Print0"/>
			<dependency name="TRUE"/>
			<dependency name="YSI_g_sInitialised"/>
			<dependency name="YVA2_DoPush"/>
			<dependency name="YVA2_Initalise"/>
			<param name="skippedBytes">
			</param>
			<param name="pushedBytes">
			</param>
			<param name="pushRequirements">
			</param>
			<param name="dummy0">
			</param>
			<param name="dummy1">
			</param>
			<param name="dummy2">
			</param>
			<param name="dummy3">
			</param>
			<param name="dummy4">
			</param>
			<param name="dummy5">
			</param>
		</member>
		<member name="M:YVA2_FoundCall" syntax="YVA2_FoundCall(m[])">
			<stacksize value="17"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmEmitHeap"/>
			<dependency name="AsmEmitPushAlt"/>
			<dependency name="AsmEmitStack"/>
			<dependency name="CodeScanGetMatchAddressData"/>
			<dependency name="CodeScanGetMatchDisasm"/>
			<dependency name="CodeScanGetMatchHole"/>
			<dependency name="CodeScanGetMatchLength"/>
			<dependency name="CodeScanGetMatchStack"/>
			<dependency name="Debug_Print0"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmNextInsn"/>
			<dependency name="OP_HEAP"/>
			<dependency name="OP_POP_PRI"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="YSI_g_sContexts"/>
			<dependency name="YSI_g_sContexts"/>
			<dependency name="YSI_g_sLength"/>
			<dependency name="YSI_g_sMaxNesting"/>
			<dependency name="YSI_g_sPassthroughNestings"/>
			<dependency name="YSI_g_sSkips"/>
			<dependency name="YSI_g_sStacks"/>
			<dependency name="YVA2_CodeGenDeepCleanup"/>
			<dependency name="YVA2_CodeGenMainCleanup"/>
			<dependency name="YVA2_CodeGenPushSite"/>
			<dependency name="YVA2_CodeGenPushVariable"/>
			<dependency name="YVA2_CodeGenShiftCode"/>
			<dependency name="cellbits"/>
			<dependency name="cellmax"/>
			<dependency name="cellmin"/>
			<param name="m">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:YVA2_FoundPush" syntax="YVA2_FoundPush(m[])">
			<stacksize value="12"/>
			<referrer name="YVA2_Initalise"/>
			<dependency name="CodeScanGetMatchAddress"/>
			<dependency name="CodeScanGetMatchAsm"/>
			<dependency name="CodeScanGetMatchDisasm"/>
			<dependency name="CodeScanGetMatchHole"/>
			<dependency name="CodeScanGetMatchLength"/>
			<dependency name="CodeScanGetMatchStack"/>
			<dependency name="Debug_Print0"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmNextInsn"/>
			<dependency name="OP_HEAP"/>
			<dependency name="OP_PUSH_ALT"/>
			<dependency name="YSI_g_sContexts"/>
			<dependency name="YSI_g_sInitialised"/>
			<dependency name="YSI_g_sLength"/>
			<dependency name="YSI_g_sMaxNesting"/>
			<dependency name="YSI_g_sPassthroughNestings"/>
			<dependency name="YSI_g_sSkips"/>
			<dependency name="YSI_g_sStacks"/>
			<dependency name="cellbits"/>
			<dependency name="cellmin"/>
			<dependency name="max"/>
			<param name="m">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:YVA2_Initalise" syntax="YVA2_Initalise()">
			<stacksize value="1139"/>
			<referrer name="YVA2_DummyPush"/>
			<referrer name="AMX_OnScriptInit"/>
			<dependency name="CodeScanAddMatcher"/>
			<dependency name="CodeScanInit"/>
			<dependency name="CodeScanMatcher"/>
			<dependency name="CodeScanMatcherInit_"/>
			<dependency name="CodeScanMatcherPattern_"/>
			<dependency name="CodeScanRun"/>
			<dependency name="CodeScanner"/>
			<dependency name="O@A_"/>
			<dependency name="O@V_"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CONST_PRI"/>
			<dependency name="OP_HEAP"/>
			<dependency name="OP_MOVE_PRI"/>
			<dependency name="OP_PUSH_ALT"/>
			<dependency name="OP_PUSH_C"/>
			<dependency name="OP_PUSH_PRI"/>
			<dependency name="OP_STACK"/>
			<dependency name="OP_STOR_I"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="OP_ZERO_PRI"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="YVA2_FoundCall"/>
			<dependency name="YVA2_FoundPush"/>
			<dependency name="gCodeScanCallback_match"/>
		</member>
		<member name="M:YVers_Callback" syntax="YVers_Callback(index, code, data[])">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="false"/>
			<dependency name="print"/>
			<dependency name="printf"/>
			<dependency name="strcmp"/>
			<dependency name="strfind"/>
			<param name="index">
			</param>
			<param name="code">
			</param>
			<param name="data">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:YVers_OnScriptInit" syntax="YVers_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="Debug_Print0"/>
			<dependency name="Debug_SetState"/>
			<dependency name="YSI_FILTERSCRIPT"/>
			<remarks>  Does some strange mangling of <c>YSI_FILTERSCRIPT</c> because at one point I  found a compiler bug where the first automata in the script could conflict  with the first variable in the script.  I don't know what triggered it, and  it has never shown up since I messed about with this file to try mangle some  things.  Never the less, if it ever happens again this code might detect it.  Actually, that's less likely now, since that variable is now very unlikely  to be the first in the script ever.  </remarks> 
		</member>
		<member name="M:Z@" syntax="Z@(v)">
			<stacksize value="7"/>
			<referrer name="Command_Add"/>
			<dependency name="getproperty"/>
			<dependency name="setproperty"/>
			<param name="v">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:_@_y_cgen_@_0" syntax="_@_y_cgen_@_0()">
			<attribute name="public"/>
			<stacksize value="60"/>
			<dependency name="SetTimerEx"/>
		</member>
		<member name="M:_@_y_cgen_@_1" syntax="_@_y_cgen_@_1()">
			<attribute name="public"/>
			<stacksize value="1"/>
		</member>
		<member name="M:_@_y_distribute_@_" syntax="_@_y_distribute_@_()">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="CallRemoteFunction"/>
			<dependency name="memcpy"/>
		</member>
		<member name="M:_@_y_funcinc_@_" syntax="_@_y_funcinc_@_()">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="CallLocalFunction"/>
			<dependency name="CallRemoteFunction"/>
			<dependency name="SetTimerEx"/>
			<dependency name="false"/>
			<dependency name="format"/>
			<dependency name="getproperty"/>
			<dependency name="heapspace"/>
			<dependency name="memcpy"/>
			<dependency name="memset"/>
			<dependency name="printf"/>
			<dependency name="setproperty"/>
			<dependency name="strcat"/>
			<dependency name="strcmp"/>
			<dependency name="strfind"/>
			<dependency name="strlen"/>
			<dependency name="strunpack"/>
		</member>
		<member name="M:_Command_GetDisplay" syntax="_Command_GetDisplay(funcid, playerid)">
			<stacksize value="8"/>
			<referrer name="Command_GetDisplay"/>
			<referrer name="Command_GetDisplayNamed"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="E_COMMAND_POINTER"/>
			<dependency name="E_COMMAND_USERS"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sHighestID"/>
			<dependency name="YSI_g_sReturnBuffer"/>
			<dependency name="cellbits"/>
			<dependency name="cellmin"/>
			<dependency name="strunpack"/>
			<param name="funcid">
			</param>
			<param name="playerid">
			</param>
			<param name="f">Command to get the real name of.</param>  <param name="p">Player to get the name for.</param>  <returns>  The name of a command for a single player.  </returns> 
		</member>
		<member name="M:_Command_Rebuild" syntax="_Command_Rebuild()">
			<stacksize value="16"/>
			<automaton name="@_"/>
			<referrer name="HANDOFF_SOURCE@_"/>
			<referrer name="_Command_Rebuild@"/>
			<dependency name="E_COMMAND_HASH_MAP"/>
			<dependency name="E_COMMAND_NAME"/>
			<dependency name="HashMap_Add"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCommandMap"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sCommands"/>
			<dependency name="YSI_g_sHighestID"/>
			<dependency name="_HashMap_Init"/>
			<dependency name="strpack"/>
			<remarks>  Rebuilds the hashmap of command pointers after a master script hands off.  </remarks> 
		</member>
		<member name="M:_Command_Rebuild@" syntax="_Command_Rebuild@()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="@_"/>
			<dependency name="_Command_Rebuild"/>
		</member>
		<member name="M:_GROUP_PREVIOUS_FUNCTION" syntax="_GROUP_PREVIOUS_FUNCTION()">
			<stacksize value="1"/>
			<referrer name="_Group_IncludeAll_1"/>
			<remarks>  Calls all functions to correctly include them in the AMX when required.  Also all variables as it turns out they were a problem too.  </remarks> 
		</member>
		<member name="M:_Group_IncludeAll_1" syntax="_Group_IncludeAll_1()">
			<stacksize value="9"/>
			<dependency name="Command_SetPlayer"/>
			<dependency name="Group_ExclusiveCommand@"/>
			<dependency name="Group_GetCommand@"/>
			<dependency name="Group_GetGlobalCommand@"/>
			<dependency name="Group_GlobalExclusiveCommand@"/>
			<dependency name="Group_SetCommand@"/>
			<dependency name="Group_SetCommandDefault@"/>
			<dependency name="Group_SetCommandNew@"/>
			<dependency name="Group_SetGlobalCommand@"/>
			<dependency name="Group_SetGlobalCommandDefault@"/>
			<dependency name="Group_SetGlobalCommandNew@"/>
			<dependency name="HANDOFF_SOURCE@_Group"/>
			<dependency name="YSI_g_sDefaultMembership"/>
			<dependency name="YSI_g_sElementMembership"/>
			<dependency name="YSI_g_sElementMembership"/>
			<dependency name="YSI_g_sEmpty"/>
			<dependency name="YSI_g_sMaxEncountered"/>
			<dependency name="_GROUP_PREVIOUS_FUNCTION"/>
			<dependency name="_yGA"/>
			<dependency name="_yGACommand"/>
			<dependency name="_yGI"/>
			<dependency name="_yGICommand"/>
			<dependency name="_yGU"/>
			<dependency name="_yGUCommand"/>
			<dependency name="false"/>
			<dependency name="printf"/>
		</member>
		<member name="M:_HashMap_Init" syntax="_HashMap_Init(m[], &amp;target, size1, size2, &amp;t2)">
			<stacksize value="2"/>
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="_Command_Rebuild"/>
			<param name="m">
				<paraminfo> [260] </paraminfo>
				Hash map to initialise.
			</param>
			<param name="target">
				<paraminfo> &amp; </paraminfo>
				Address of the hashmap data.
			</param>
			<param name="size1">
				Number of entries.
			</param>
			<param name="size2">
				Total Size of each entry IN BYTES.
			</param>
			<param name="t2">
				<paraminfo> &amp; </paraminfo>
				Address of the name AND data start.
			</param>
			          <remarks>  Finds the location of the hash map linked list data in the passed array data  and uses that to read the data through pointers subsequently.  It doesn't  matter WHERE in the enum the hash map data is, and if its not there you'll  get an error, or at least a warning.  </remarks> 
		</member>
		<member name="M:_HookChain_IncludeStates" syntax="_HookChain_IncludeStates()">
			<stacksize value="1"/>
			<automaton name="_ALS"/>
		</member>
		<member name="M:_Hooks_AddReplacement" syntax="_Hooks_AddReplacement(longName[], shortName[])">
			<stacksize value="5"/>
			<referrer name="@_yHCheckpoint"/>
			<referrer name="@_yHContainer"/>
			<referrer name="@_yHInventory"/>
			<referrer name="@_yHDynamic"/>
			<referrer name="@_yHTextDraw"/>
			<referrer name="@_yHUpdate"/>
			<referrer name="@_yHObject"/>
			<referrer name="@_yHCommand"/>
			<referrer name="@_yHDynamicCP"/>
			<dependency name="Debug_Print0"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_LONG"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MAX"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MIN"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_SHORT"/>
			<dependency name="YSI_g_sReplacePtr"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacementsLongOrder"/>
			<dependency name="YSI_g_sReplacementsShortOrder"/>
			<dependency name="strcat"/>
			<dependency name="strlen"/>
			<param name="longName">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="shortName">
				<paraminfo> [] </paraminfo>
			</param>
			<remarks>  Call the main hook run code, then advance the ALS chain.  </remarks> 
		</member>
		<member name="M:_Master_Get" syntax="_Master_Get(library[], force)">
			<tagname value="bool"/>
			<stacksize value="9"/>
			<referrer name="Master_GetCurrentMaster"/>
			<referrer name="Master_GetCurrentMaster"/>
			<dependency name="YSI_g_sMasterCount"/>
			<dependency name="YSI_g_sMasterData"/>
			<dependency name="_@"/>
			<dependency name="existproperty"/>
			<dependency name="false"/>
			<dependency name="getproperty"/>
			<dependency name="setproperty"/>
			<dependency name="true"/>
			<param name="library">
				<paraminfo> [] </paraminfo>
				The name of the library to try become master for.
			</param>
			<param name="force">
				<paraminfo>bool </paraminfo>
			</param>
			 
		</member>
		<member name="M:_Master_Relinquish" syntax="_Master_Relinquish(library[])">
			<stacksize value="3"/>
			<referrer name="@_"/>
			<referrer name="@a"/>
			<dependency name="YSI_g_sMasterCount"/>
			<dependency name="YSI_g_sMasterData"/>
			<param name="library">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:_ScriptInit_FixState" syntax="_ScriptInit_FixState()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_script_init_fix_state"/>
		</member>
		<member name="M:_ScriptInit_IncludeStates" syntax="_ScriptInit_IncludeStates()">
			<stacksize value="1"/>
			<automaton name="_ALS"/>
		</member>
		<member name="M:_Y_G@C_1" syntax="_Y_G@C_1()">
			<stacksize value="1"/>
			<referrer name="_yGACommand"/>
		</member>
		<member name="M:_Y_G@C_3" syntax="_Y_G@C_3()">
			<stacksize value="1"/>
			<referrer name="_yGICommand"/>
			<referrer name="_yGUCommand"/>
		</member>
		<member name="M:__CompilerSecondPass" syntax="__CompilerSecondPass()">
			<stacksize value="1"/>
		</member>
		<member name="M:__CompilerStringReturn" syntax="__CompilerStringReturn(str[], size, dummy)">
			<stacksize value="1"/>
			<dependency name="strcat"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="dummy">
			</param>
		</member>
		<member name="M:__MACRO__Bit_Bits" syntax="__MACRO__Bit_Bits(size)">
			<stacksize value="1"/>
			<param name="size">
				Number of bits required.
			</param>
			  <returns>  Number of cells required for the bit array.  </returns> 
		</member>
		<member name="M:__MACRO__Bit_FastSet" syntax="__MACRO__Bit_FastSet(array[], slot, set, size)">
			<stacksize value="1"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
				Array of bits.
			</param>
			<param name="slot">
				Bit slot.
			</param>
			<param name="set">
				<paraminfo>bool </paraminfo>
				State to set the slot to.
			</param>
			<param name="size">
				Size of array.
			</param>
			        <remarks>  Exactly the same as "Bit_Set", but as a macro not a function.  native Bit_FastSet(BitArray:array&lt;&gt;, slot, bool:set, size = sizeof (array));  </remarks> 
		</member>
		<member name="M:__MACRO__Bit_Get" syntax="__MACRO__Bit_Get(array[], slot)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
				Array of bits.
			</param>
			<param name="slot">
				Bit slot.
			</param>
			    <param name="size">Size of array.</param>  <returns>  State of the provided slot, 0 on fail.  </returns>  <remarks>  -  native Bit_Get(BitArray:array&lt;&gt;, slot);  </remarks> 
		</member>
		<member name="M:__MACRO__Bit_GetBit" syntax="__MACRO__Bit_GetBit(array[], slot)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
				Array of bits.
			</param>
			<param name="slot">
				Bit slot.
			</param>
			    <returns>  State of the provided slot, 0 on fail.  </returns>  <remarks>  Unsafe but faster for when you're sure you're within range.  </remarks> 
		</member>
		<member name="M:__MACRO__Bit_Let" syntax="__MACRO__Bit_Let(array[], slot)">
			<stacksize value="1"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
				Array of bits.
			</param>
			<param name="slot">
				Bit slot.
			</param>
			    <remarks>  Sets the slot to 1.  </remarks> 
		</member>
		<member name="M:__MACRO__Bit_Mask" syntax="__MACRO__Bit_Mask(value)">
			<stacksize value="1"/>
			<param name="value">
				Value to get the mask for
			</param>
			  <returns>  The bit in the array slot to use.  </returns> 
		</member>
		<member name="M:__MACRO__Bit_Slot" syntax="__MACRO__Bit_Slot(value)">
			<stacksize value="1"/>
			<param name="value">
				Value to get the slot for.
			</param>
			  <returns>  The true array slot for this value.  </returns> 
		</member>
		<member name="M:__MACRO__Bit_Vet" syntax="__MACRO__Bit_Vet(array[], slot)">
			<stacksize value="1"/>
			<param name="array">
				<paraminfo>Bit [] </paraminfo>
				Array of bits.
			</param>
			<param name="slot">
				Bit slot.
			</param>
			    <remarks>  Sets the slot to 0.  </remarks> 
		</member>
		<member name="M:__MACRO__Command_Name" syntax="__MACRO__Command_Name(f)">
			<stacksize value="1"/>
			<param name="f">
				Command to get the name of.
			</param>
			 
		</member>
		<member name="M:__MACRO__Debug_Code1" syntax="__MACRO__Debug_Code1(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code1(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:1(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 1</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Code2" syntax="__MACRO__Debug_Code2(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code2(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:2(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 2</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Code3" syntax="__MACRO__Debug_Code3(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code3(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:3(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 3</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Code4" syntax="__MACRO__Debug_Code4(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code4(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:4(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 4</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Code5" syntax="__MACRO__Debug_Code5(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code5(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:5(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 5</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Code6" syntax="__MACRO__Debug_Code6(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code6(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:6(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 6</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Code7" syntax="__MACRO__Debug_Code7(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code7(if (bla == 2) { bla++; printf("%d", bla); });  </code>  Or:  <code>  C:7(if (bla == 2) { bla++; printf("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 7</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Print1" syntax="__MACRO__Debug_Print1(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print1("variables: %d, %d", i, j);  </code>  Or:  <code>  P:1("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 1</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Print2" syntax="__MACRO__Debug_Print2(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print2("variables: %d, %d", i, j);  </code>  Or:  <code>  P:2("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 2</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Print3" syntax="__MACRO__Debug_Print3(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print3("variables: %d, %d", i, j);  </code>  Or:  <code>  P:3("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 3</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Print4" syntax="__MACRO__Debug_Print4(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print4("variables: %d, %d", i, j);  </code>  Or:  <code>  P:4("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 4</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Print5" syntax="__MACRO__Debug_Print5(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print5("variables: %d, %d", i, j);  </code>  Or:  <code>  P:5("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 5</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Print6" syntax="__MACRO__Debug_Print6(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print6("variables: %d, %d", i, j);  </code>  Or:  <code>  P:6("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 6</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Print7" syntax="__MACRO__Debug_Print7(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print7("variables: %d, %d", i, j);  </code>  Or:  <code>  P:7("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 7</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__GetIP" syntax="__MACRO__GetIP(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
				Player to get IP of.
			</param>
			  <returns>  IP as a 32bit int.  </returns> 
		</member>
		<member name="M:__MACRO__HashMap_ByteLen" syntax="__MACRO__HashMap_ByteLen(str[])">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to get the size of.
			</param>
			  <returns>  The number of BYTES this string takes up including the NULL.  </returns>  <remarks>  Caters for both packed and unpacked strings.  The weirdness is basically  just: <code>ispacked(str) ? (* 1) : (* 4)</code>.  </remarks> 
		</member>
		<member name="M:__MACRO__HashMap_Hash" syntax="__MACRO__HashMap_Hash(str[], &amp;hash)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to hash.
			</param>
			<param name="hash">
				<paraminfo> &amp; </paraminfo>
				Desination of the hash.
			</param>
			    <remarks>  Quickly hashes the string using Bernstein.  Caters for both packed and  unpacked strings.  </remarks> 
		</member>
		<member name="M:__MACRO__HashMap_Init" syntax="__MACRO__HashMap_Init(m[], target[][], slot)">
			<stacksize value="1"/>
			<param name="m">
				<paraminfo> [260] </paraminfo>
				Hash map to initialise.
			</param>
			<param name="target">
				<paraminfo> [][] </paraminfo>
				Array to point in to.
			</param>
			<param name="slot">
				Second dimension slot of the hashed data.
			</param>
			      <remarks>  Finds the location of the hash map linked list data in the passed array data  and uses that to read the data through pointers subsequently.  It doesn't  matter WHERE in the enum the hash map data is, and if its not there you'll  get an error, or at least a warning.  </remarks> 
		</member>
		<member name="M:__MACRO__IS_IN_RANGE" syntax="__MACRO__IS_IN_RANGE(value, lower, upper)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="value">
				The number to compare.
			</param>
			<param name="lower">
				The lower limit.
			</param>
			<param name="upper">
				The upper limit.
			</param>
			      <returns>  Is the value in the given range.  </returns>  <remarks>  Equivalent to:  <code>		(%1) &lt;= (%0) &lt; (%2)</code>  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_Add" syntax="__MACRO__Iter_Add(iter[], value)">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to add the data to.
			</param>
			<param name="value">
				Value to add to the iterator.
			</param>
			    <remarks>  Wrapper for Iter_AddInternal.  native Iter_Add(Iterator:Name&lt;&gt;, value);  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_Alloc" syntax="__MACRO__Iter_Alloc(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the first free slot in.
			</param>
			  <remarks>  Finds an empty slot in an iterator, adds that slot to the iterator, and  returns the now added slot.  native Iter_Alloc(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_Begin" syntax="__MACRO__Iter_Begin(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the start of.
			</param>
			  <remarks>  Gets a point BEFORE the start of the iterator (the theoretical beginning).  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_Clear" syntax="__MACRO__Iter_Clear(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to empty.
			</param>
			  <remarks>  Wrapper for Iter_Clear_Internal.  Although it doesn't fit my normal strict spacing, the end of "B" is correct,  namely: "_:F@s(%0),%2)".  This uses the "_:%0,)" macro to consume  a trailing comma when nothing is given in "%2", so I can't have a leading  space sadly.  "- 2" in place of the normal "- 1" is CORRECT!  native Iter_Clear(IteratorArray:Name[]&lt;&gt;);  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_Contains" syntax="__MACRO__Iter_Contains(iter[], value)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to check membership of.
			</param>
			<param name="value">
				Value to check.
			</param>
			    <remarks>  Checks if the given value is in the given iterator.  native Iter_Contains(Iterator:Name&lt;&gt;, value);  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_Count" syntax="__MACRO__Iter_Count(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get a random slot from.
			</param>
			  <remarks>  Returns the number of items in this iterator.  native Iter_Count(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_End" syntax="__MACRO__Iter_End(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the end of.
			</param>
			  <remarks>  Gets a point AFTER the end of the iterator (think "MAX_PLAYERS").  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_FastClear" syntax="__MACRO__Iter_FastClear(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to empty.
			</param>
			  <remarks>  Uses a static array copy to blank the iterator instead of a loop.  BROKEN!  native Iter_FastClear(IteratorArray:Name[]&lt;&gt;);  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_First" syntax="__MACRO__Iter_First(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the first valid element in.
			</param>
			  <remarks>  Gets the first element in an iterator.  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_Free" syntax="__MACRO__Iter_Free(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the first free slot in.
			</param>
			  <remarks>  Wrapper for Iter_Free_Internal.  Returns a slot NOT in the current  iterator.  native Iter_Free(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_FreeMulti" syntax="__MACRO__Iter_FreeMulti(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the multi-iterator to get the first free slot in.
			</param>
			  <remarks>  Wrapper for Iter_FreeMulti_Internal.  Returns a slot NOT in the current  multi-iterator.  native Iter_FreeMulti(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_GetMulti" syntax="__MACRO__Iter_GetMulti(iter[], value)">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to check membership of.
			</param>
			<param name="value">
				Value to check.
			</param>
			    <returns>  Index in which the value is contained in the multi-iterator.  </returns>  <remarks>  Checks if the given value is in the given iterator, and if it is return which index it is contained.  native Iter_GetMulti(Iterator:Name&lt;&gt;, value);  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_Index" syntax="__MACRO__Iter_Index(iter[], index, wrap)">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get a slot in by index.
			</param>
			<param name="index">
				Index.
			</param>
			<param name="wrap">
				<paraminfo>bool </paraminfo>
				Keep going around until a value is found?
			</param>
			      <remarks>  Wrapper for Iter_Index_Internal.  Returns the Nth value in the iterator  (requires looping due to the way iterators are stored and optimised for  loops not direct access).  native Iter_Index(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_Init" syntax="__MACRO__Iter_Init(iter[][])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [][] </paraminfo>
				Name of the iterator array to initialise.
			</param>
			  <remarks>  Wrapper for Iter_Init_Internal.  When <c>__COMPILER_NESTED_ELLIPSIS</c> is  set, this isn't needed because multi-dimensional iterators can be  initialised with the new <c>{{0, 1, ...), ...}</c> feature.  In that case  <c>I@ = 0</c> is called as a <c>void</c> function that does nothing but ends  in a semi-colon (<c>I@</c> is used a lot in YSI as a <c>do nothing</c>  enabler).  <code>native Iter_Init(IteratorArray:Name[]&lt;&gt;);</code>  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_IsEmpty" syntax="__MACRO__Iter_IsEmpty(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to test emptiness of.
			</param>
			  <remarks>  native Iter_IsEmpty(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_Last" syntax="__MACRO__Iter_Last(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to
			</param>
			  <remarks>  Gets the last element in an iterator.  Works by getting the previous item  from the one BEFORE the first element (i.e. the one before the sentinel).  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_Next" syntax="__MACRO__Iter_Next(iter[], cur)">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the next element in.
			</param>
			<param name="cur">
				The current element.
			</param>
			    <remarks>  Gets the element in an iterator after the current one.  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_Prev" syntax="__MACRO__Iter_Prev(iter[], cur)">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the previous element in.
			</param>
			<param name="cur">
				The current element.
			</param>
			    <remarks>  Gets the element in an iterator before the current one.  Slow.  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_Random" syntax="__MACRO__Iter_Random(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get a random slot from.
			</param>
			  <remarks>  Wrapper for Iter_RandomInternal.  native Iter_Random(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_RandomAdd" syntax="__MACRO__Iter_RandomAdd(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to add a random slot to.
			</param>
			  <remarks>  Wrapper for Iter_RandomAddInternal.  native Iter_RandomAdd(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_RandomFree" syntax="__MACRO__Iter_RandomFree(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get a random unused slot for.
			</param>
			  <remarks>  Wrapper for Iter_RandomFree_Internal.  native Iter_RandomFree(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_RandomRemove" syntax="__MACRO__Iter_RandomRemove(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to remove a random slot from.
			</param>
			  <remarks>  Wrapper for Iter_RandomRemoveInternal.  native Iter_RandomRemove(Iterator:Name&lt;&gt;);  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_Remove" syntax="__MACRO__Iter_Remove(iter[], value)">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to remove data from.
			</param>
			<param name="value">
				Data to remove.
			</param>
			    <remarks>  Wrapper for Iter_RemoveInternal.  native Iter_Remove(Iterator:Name&lt;&gt;, value);  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_SafeRemove" syntax="__MACRO__Iter_SafeRemove(iter[], value, &amp;next)">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to remove data from.
			</param>
			<param name="value">
				Data to remove.
			</param>
			<param name="next">
				<paraminfo> &amp; </paraminfo>
				Container for the pointer to the next element.
			</param>
			      <remarks>  Wrapper for Iter_SafeRemoveInternal.  Common use:  Iter_SafeRemove(iter, i, i);  native Iter_SafeRemove(Iterator:Name&lt;&gt;, value, &amp;next);  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_Size" syntax="__MACRO__Iter_Size(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the size of.
			</param>
			  <remarks>  Accesses the size of an iterator.  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_Starts" syntax="__MACRO__Iter_Starts(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the true starts of.
			</param>
			  <remarks>  Accesses the number of starts in a multi-iterator.  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_TrueArray" syntax="__MACRO__Iter_TrueArray(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the true array of.
			</param>
			  <remarks>  Accesses the internal array of an iterator.  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_TrueCount" syntax="__MACRO__Iter_TrueCount(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the true count of.
			</param>
			  <remarks>  Accesses the internal count of an iterator.  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_TrueMulti" syntax="__MACRO__Iter_TrueMulti(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Multi iterator to get the true count of.
			</param>
			  <remarks>  Accesses the internal count of a multi-iterator.  </remarks> 
		</member>
		<member name="M:__MACRO__Iter_TrueSize" syntax="__MACRO__Iter_TrueSize(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Name of the iterator to get the true size of.
			</param>
			  <remarks>  Accesses the internal size of an iterator.  </remarks> 
		</member>
		<member name="M:__MACRO__Iterator" syntax="__MACRO__Iterator(name)">
			<tagname value="Iterator"/>
			<stacksize value="1"/>
			<param name="name">
			</param>
			<remarks>  Creates a new iterator start/array pair.  </remarks> 
		</member>
		<member name="M:__MACRO__Iterator@Reverse" syntax="__MACRO__Iterator@Reverse(iter[])">
			<stacksize value="1"/>
			<param name="iter">
				<paraminfo>Iterator [] </paraminfo>
				Iterator to run backwards.
			</param>
			  <remarks>  Run an iterator backwards.  </remarks> 
		</member>
		<member name="M:__MACRO__NOT_IN_RANGE" syntax="__MACRO__NOT_IN_RANGE(value, lower, upper)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="value">
				The number to compare.
			</param>
			<param name="lower">
				The lower limit.
			</param>
			<param name="upper">
				The upper limit.
			</param>
			      <returns>  Is the value outside the given range.  </returns>  <remarks>  Equivalent to:  <code>		(%1) &lt;= (%0) &lt; (%2)</code>  </remarks> 
		</member>
		<member name="M:__MACRO__UCMP" syntax="__MACRO__UCMP(value, upper)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="value">
				The unsigned number to compare.
			</param>
			<param name="upper">
				The upper limit.
			</param>
			    <returns>  An unsigned comparison between the two values.  </returns> 
		</member>
		<member name="M:__MACRO__VALID_PLAYERID" syntax="__MACRO__VALID_PLAYERID(playerid)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="playerid">
				The player to check.
			</param>
			  <returns>  Is this a valid playerid (NOT, is the player connected).  </returns> 
		</member>
		<member name="M:__MACRO___Command_GetPrefix" syntax="__MACRO___Command_GetPrefix(c)">
			<stacksize value="1"/>
			<param name="c">
				Command to get.
			</param>
			  <returns>  The prefix for this command.  </returns> 
		</member>
		<member name="M:__MACRO___Command_GetReal" syntax="__MACRO___Command_GetReal(&amp;ptr, &amp;idx, name[])">
			<stacksize value="1"/>
			<param name="ptr">
				<paraminfo> &amp; </paraminfo>
				AMX function pointer.
			</param>
			<param name="idx">
				<paraminfo> &amp; </paraminfo>
				Index of the parent command data.
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
				Destination for the parent function name.
			</param>
			      <remarks>  Finds the original version of an alt command.  Updated to not contain long  chains (along with "Command_AddAlt").  </remarks> 
		</member>
		<member name="M:__MACRO___Command_IsActive" syntax="__MACRO___Command_IsActive(command)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="command">
				Command to get for.
			</param>
			  <returns>  Is this command ID active?  </returns>  <remarks>  Doesn't do any bounds checks - use "_Command_IsValid" for that.  </remarks> 
		</member>
		<member name="M:__MACRO___Command_IsAlt" syntax="__MACRO___Command_IsAlt(idx)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="idx">
				Command to test.
			</param>
			  <remarks>  Tests if the given slot is an alternate command.  </remarks> 
		</member>
		<member name="M:__MACRO___Command_IsEmptySlot" syntax="__MACRO___Command_IsEmptySlot(idx)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="idx">
				Command to test.
			</param>
			  <remarks>  Tests if the given slot is empty.  </remarks> 
		</member>
		<member name="M:__MACRO___Puny_Basic" syntax="__MACRO___Puny_Basic(num)">
			<stacksize value="1"/>
			<param name="num">
				The single number to encode.
			</param>
			  <remarks>  Convert a single digit to base 36.  </remarks> 
		</member>
		<member name="M:__MACRO__ceildiv" syntax="__MACRO__ceildiv(numerator, denominator)">
			<stacksize value="1"/>
			<param name="numerator">
				The top of the division.
			</param>
			<param name="denominator">
				The bottom of the division.
			</param>
			    <returns>  (numerator / denominator) rounded up.  </returns>  <remarks>  Normal integer division ALWAYS rounds down - this always rounds up.  </remarks> 
		</member>
		<member name="M:__MACRO__floordiv" syntax="__MACRO__floordiv(numerator, denominator)">
			<stacksize value="1"/>
			<param name="numerator">
				The top of the division.
			</param>
			<param name="denominator">
				The bottom of the division.
			</param>
			<summary>  floordiv(numerator, denominator);  </summary>      <returns>  (numerator / denominator) rounded down.  </returns>  <remarks>  Normal integer division ALWAYS rounds down - this also always rounds down,  making it a little pointless, but also more explicit in function.  </remarks> 
		</member>
		<member name="M:__MACRO__iseven" syntax="__MACRO__iseven(value)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="value">
				Value to check if is even.
			</param>
			 
		</member>
		<member name="M:__MACRO__isnull" syntax="__MACRO__isnull(str[])">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to check if is null.
			</param>
			 
		</member>
		<member name="M:__MACRO__isodd" syntax="__MACRO__isodd(value)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="value">
				Value to check if is odd.
			</param>
			 
		</member>
		<member name="M:__MACRO__iterfunc" syntax="__MACRO__iterfunc(params)">
			<stacksize value="1"/>
			<param name="params">
				The iterator function's parameters.
			</param>
			  <remarks>  Used to declare a special iterator function.  Examples:  <code>  iterfunc stock OnlyZero(cur)                                                    <br />  {                                                                               <br /><indent />  if (cur == -1)                                                              <br /><indent /><indent />  return 0;                                                               <br /><indent />  return -1;                                                                  <br />  }                                                                               <br />  </code>  <code>  iterfunc stock AlsoOnlyZero[cellmin](cur)                                       <br />  {                                                                               <br /><indent />  if (cur == cellmin)                                                         <br /><indent /><indent />  return 0;                                                               <br /><indent />  return cellmin;                                                             <br />  }                                                                               <br />  </code>  <code>  iterfunc stock OneToTen[cellmin](cur)                                           <br />  {                                                                               <br /><indent />  if (cur == cellmin)                                                         <br /><indent /><indent />  return 1;                                                               <br /><indent />  if (cur == 10)                                                              <br /><indent /><indent />  return cellmin;                                                         <br /><indent />  return cur + 1;                                                             <br />  }                                                                               <br />  </code>  <code>  iterfunc stock OneToN(cur, n)                                                   <br />  {                                                                               <br /><indent />  if (n &lt; 1)                                                               <br /><indent /><indent />  return -1;                                                              <br /><indent />  if (cur == -1)                                                              <br /><indent /><indent />  return 1;                                                               <br /><indent />  if (cur == n)                                                               <br /><indent /><indent />  return -1;                                                              <br /><indent />  return cur + 1;                                                             <br />  }                                                                               <br />  </code>  </remarks> 
		</member>
		<member name="M:__MACRO__strcpy" syntax="__MACRO__strcpy(dest[], src[], len)">
			<stacksize value="1"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
				Destination string.
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
				Source string.
			</param>
			<param name="len">
				(Implicit) maximum length of the destination.
			</param>
			     
		</member>
		<member name="M:__TU" syntax="__TU(t, iters)">
			<stacksize value="27"/>
			<dependency name="operator/(Float:,Float:)"/>
			<dependency name="__TU"/>
			<dependency name="float"/>
			<dependency name="format"/>
			<param name="t">
				The time in ms.
			</param>
			<param name="iters">
				The number of iterations completed in this time.
			</param>
			    <remarks>  Formats and returns a string representing the time taken for one iteration,  given the time required for many iterations.  This attempts to format the  number using a reasonable fraction of a second.  </remarks> 
		</member>
		<member name="M:_yGACommand" syntax="_yGACommand(&amp;group)">
			<stacksize value="5"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="J@"/>
			<dependency name="YSI_g_sDefaultMembership"/>
			<dependency name="YSI_g_sElementMembership"/>
			<dependency name="YSI_g_sElementMembership"/>
			<dependency name="_Y_G@C_1"/>
			<dependency name="_yGA"/>
			<dependency name="cellbits"/>
			<param name="group">
				<paraminfo> &amp; </paraminfo>
				The group that was just created.
			</param>
			  <remarks>  The given group was just created, loop over all elements and make sure they  are NOT in this group - only the global group has a "default default" of  true.  We don't need to update any players with this as no-one will ever be  in a brand new group.  </remarks> 
		</member>
		<member name="M:_yGICommand" syntax="_yGICommand(&amp;ni, &amp;na, &amp;nu)">
			<stacksize value="8"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="AMX_GetPointerPrefix"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="J@"/>
			<dependency name="YSI_g_cEmptyGroups"/>
			<dependency name="YSI_g_sDefaultMembership"/>
			<dependency name="YSI_g_sEmpty"/>
			<dependency name="_Y_G@C_3"/>
			<dependency name="_yGA"/>
			<dependency name="_yGI"/>
			<dependency name="_yGU"/>
			<dependency name="cellbits"/>
			<param name="ni">
				<paraminfo> &amp; </paraminfo>
				Next init function variable as returned by y_amx.
			</param>
			<param name="na">
				<paraminfo> &amp; </paraminfo>
				Next add function variable as returned by y_amx.
			</param>
			<param name="nu">
				<paraminfo> &amp; </paraminfo>
				Next update function variable as returned by y_amx.
			</param>
			      <remarks>  This function is called when the group system first starts up to initialise  the global group and all the various function pointers.  The way the  "_gchain" macro works means that the fact that "ni" etc are references is  irrelevant; however, it does make the code LOOK much nicer and like  assigning to the variables does have some wider meaning.  If this is called with "ni = -1", it is special code to temporarily set or  restore the defaults for use with the "GROUP_ADD" macro.  So basically, it  is poor design giving two distinct uses to a single function.  </remarks> 
		</member>
		<member name="M:_yGUCommand" syntax="_yGUCommand(&amp;pid, p[], c[])">
			<stacksize value="9"/>
			<automaton name="@_"/>
			<referrer name="_Group_IncludeAll_1"/>
			<dependency name="Group_FullPlayerUpdate"/>
			<dependency name="J@"/>
			<dependency name="YSI_g_sElementMembership"/>
			<dependency name="YSI_g_sMaxEncountered"/>
			<dependency name="_Y_G@C_3"/>
			<dependency name="_yGU"/>
			<param name="pid">
				<paraminfo> &amp; </paraminfo>
				The player who joined or left groups.
			</param>
			<param name="p">
				<paraminfo>Bit [] </paraminfo>
				Their previous groups.
			</param>
			<param name="c">
				<paraminfo>Bit [] </paraminfo>
				Their new groups.
			</param>
			      <remarks>  The player "pid" just joined or left a group (or groups - can do multiple).  Update their visibility accordingly.  This function is ONLY called if there  is a CHANGE - earlier functions confirm that they weren't already in (or  not) this group(s) before the call.  </remarks> 
		</member>
		<member name="M:_y_utils_OnPlayerConnect" syntax="_y_utils_OnPlayerConnect(playerid)">
			<attribute name="public"/>
			<stacksize value="6"/>
			<dependency name="GameTextForPlayer"/>
			<dependency name="SendClientMessage"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:argderef" syntax="argderef(n)">
			<stacksize value="1"/>
			<dependency name="argderef"/>
			<param name="n">
			</param>
		</member>
		<member name="M:argref" syntax="argref(n)">
			<stacksize value="1"/>
			<param name="n">
			</param>
		</member>
		<member name="M:bernstein" syntax="bernstein(string[])">
			<stacksize value="28"/>
			<referrer name="bernstein"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmEmitAdd"/>
			<dependency name="AsmEmitAddC"/>
			<dependency name="AsmEmitConstAlt"/>
			<dependency name="AsmEmitJnzRel"/>
			<dependency name="AsmEmitJzerRel"/>
			<dependency name="AsmEmitLoadI"/>
			<dependency name="AsmEmitLrefSPri"/>
			<dependency name="AsmEmitMoveAlt"/>
			<dependency name="AsmEmitMovePri"/>
			<dependency name="AsmEmitPopPri"/>
			<dependency name="AsmEmitProc"/>
			<dependency name="AsmEmitPushPri"/>
			<dependency name="AsmEmitPushS"/>
			<dependency name="AsmEmitRetn"/>
			<dependency name="AsmEmitSmulC"/>
			<dependency name="AsmEmitStack"/>
			<dependency name="AsmEmitXchg"/>
			<dependency name="AsmInitPtr"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				the string to hash.
			</param>
			  <returns>  the bernstein hash of the input string  </returns>  <remarks>  This is a 32bit hash system so is not very secure, however we're only  using this as a string enumerator to uniquely identify strings easilly  and allow for a binary search of strings based on the hash of their name.  crc32, then jenkins were originally used however this is far faster, if a  little collision prone, but we're checking the strings manually anyway.  This doesn't matter as it would be done regardless of hash method, so this  doesn't need to be accounted for.  Speed is all that matters with at   least a bit of non collision (the number of strings we're dealing with,  this should have none-few collisions).  I modified it slightly from the original code pasted by aru, to code  closer to the code <a href="http://www.burtleburtle.net/bob/hash/doobs.html" />  and to work with PAWN (and shaved 0.2s off the time for one call :D).  Uber reduced version (just for fun):  b(s[]){new h=-1,i,j;while((j=s[i++]))h=h*33+j;return h;}  Update: Contrary to what I said above this is also used to identify colour  strings for the updated text system involving file based styling and this  is not checked for collisions as it's unimportant.  But this doesn't affect  the function at all, I just mentioned it here for "interest".  Rewritten in self-generating assembly.  </remarks> 
		</member>
		<member name="M:binstr" syntax="binstr(string[])">
			<stacksize value="3"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				String to try convert to a boolean.
			</param>
			  <returns>  bool: passed boolean.  </returns>  <remarks>  This takes a value in 0110101 (boolean) format and returns it as a  regular value.  </remarks> 
		</member>
		<member name="M:boolstr" syntax="boolstr(string[])">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<dependency name="strcmp"/>
			<dependency name="true"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				String to try convert to a boolean.
			</param>
			  <returns>  bool: passed boolean.  </returns>  <remarks>  This can take a number of ways of representing booleans - 0, false and  nothing there.  Anything not one of those things (false is not case  sensitive) is assumed true.  </remarks> 
		</member>
		<member name="M:chrfind" syntax="chrfind(needle, haystack[], start)">
			<stacksize value="3"/>
			<dependency name="strlen"/>
			<param name="needle">
				The character to find.
			</param>
			<param name="haystack">
				<paraminfo> [] </paraminfo>
				The string to find it in.
			</param>
			<param name="start">
				The offset to start from.
			</param>
			      <returns>  Fail - -1, Success - pos  </returns> 
		</member>
		<member name="M:chrfindp" syntax="chrfindp(needle, haystack[], start)">
			<stacksize value="1"/>
			<param name="needle">
				The character to find.
			</param>
			<param name="haystack">
				<paraminfo> [] </paraminfo>
				The string to find it in.
			</param>
			<param name="start">
				The offset to start from.
			</param>
			      <returns>  Fail - -1, Success - pos  </returns>  <remarks>  Like <symbolref name="chrfind" />, but with no upper-bounds check on  <paramref name="start" />.  </remarks> 
		</member>
		<member name="M:copy_1" syntax="copy_1(&amp;dest, source[], start)">
			<stacksize value="1"/>
			<referrer name="GetAmxHeaderNow"/>
			<param name="dest">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
		</member>
		<member name="M:copy_2" syntax="copy_2(&amp;dest, source[], start)">
			<stacksize value="1"/>
			<referrer name="GetAmxHeaderNow"/>
			<param name="dest">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
		</member>
		<member name="M:copy_4" syntax="copy_4(&amp;dest, source[], start)">
			<stacksize value="1"/>
			<referrer name="GetAmxHeaderNow"/>
			<param name="dest">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
		</member>
		<member name="M:deref" syntax="deref(v)">
			<stacksize value="1"/>
			<dependency name="deref"/>
			<param name="v">
			</param>
		</member>
		<member name="M:endofline" syntax="endofline(line[], pos)">
			<stacksize value="3"/>
			<dependency name="cellmin"/>
			<dependency name="strlen"/>
			<param name="line">
				<paraminfo> [] </paraminfo>
				String to check.
			</param>
			<param name="pos">
				Postion to start from.
			</param>
			    <remarks>  Checks if the current point in a line is the end of non-whitespace data.  </remarks> 
		</member>
		<member name="M:enter_public" syntax="enter_public(index, address)">
			<stacksize value="6"/>
			<referrer name="new_pec"/>
			<dependency name="ProfCallInfo"/>
			<dependency name="exit_public"/>
			<dependency name="g_call_depth"/>
			<dependency name="g_call_stack"/>
			<dependency name="g_call_stack"/>
			<dependency name="pci_index"/>
			<dependency name="pci_start_time"/>
			<dependency name="printf"/>
			<dependency name="tickcount"/>
			<param name="index">
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:existproperty" syntax="existproperty(id, name[], value)">
			<attribute name="native"/>
			<referrer name="HookChain_OnScriptInit"/>
			<referrer name="_Master_Get"/>
			<param name="id">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:exit_public" syntax="exit_public()">
			<stacksize value="8"/>
			<referrer name="enter_public"/>
			<dependency name="cellmax"/>
			<dependency name="cellmin"/>
			<dependency name="g_call_depth"/>
			<dependency name="g_call_stack"/>
			<dependency name="g_num_publics"/>
			<dependency name="g_publics"/>
			<dependency name="g_publics"/>
			<dependency name="pci_index"/>
			<dependency name="pci_start_time"/>
			<dependency name="ppi_child_time"/>
			<dependency name="ppi_num_calls"/>
			<dependency name="ppi_total_time"/>
			<dependency name="tickcount"/>
		</member>
		<member name="M:fclose" syntax="fclose(handle)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="LoadStaticVehiclesFromFile"/>
			<referrer name="DisasmWrite"/>
			<referrer name="ProfilerWriteData"/>
			<referrer name="ftouch"/>
			<param name="handle">
				<paraminfo>File </paraminfo>
			</param>
		</member>
		<member name="M:fexist" syntax="fexist(pattern[])">
			<attribute name="native"/>
			<referrer name="ftouch"/>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:float" syntax="float(value)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator*(Float:,_:)"/>
			<referrer name="operator/(Float:,_:)"/>
			<referrer name="operator/(_:,Float:)"/>
			<referrer name="operator+(Float:,_:)"/>
			<referrer name="operator-(Float:,_:)"/>
			<referrer name="operator-(_:,Float:)"/>
			<referrer name="operator==(Float:,_:)"/>
			<referrer name="operator!=(Float:,_:)"/>
			<referrer name="operator&gt;(Float:,_:)"/>
			<referrer name="operator&gt;(_:,Float:)"/>
			<referrer name="operator&gt;=(Float:,_:)"/>
			<referrer name="operator&gt;=(_:,Float:)"/>
			<referrer name="operator&lt;(Float:,_:)"/>
			<referrer name="operator&lt;(_:,Float:)"/>
			<referrer name="operator&lt;=(Float:,_:)"/>
			<referrer name="operator&lt;=(_:,Float:)"/>
			<referrer name="__TU"/>
			<referrer name="RandomFloat"/>
			<param name="value">
			</param>
		</member>
		<member name="M:floatadd" syntax="floatadd(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator+(Float:,_:)"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:floatcmp" syntax="floatcmp(oper1, oper2)">
			<attribute name="native"/>
			<referrer name="operator==(Float:,Float:)"/>
			<referrer name="operator==(Float:,_:)"/>
			<referrer name="operator!=(Float:,Float:)"/>
			<referrer name="operator!=(Float:,_:)"/>
			<referrer name="operator&gt;(Float:,Float:)"/>
			<referrer name="operator&gt;(Float:,_:)"/>
			<referrer name="operator&gt;(_:,Float:)"/>
			<referrer name="operator&gt;=(Float:,Float:)"/>
			<referrer name="operator&gt;=(Float:,_:)"/>
			<referrer name="operator&gt;=(_:,Float:)"/>
			<referrer name="operator&lt;(Float:,Float:)"/>
			<referrer name="operator&lt;(Float:,_:)"/>
			<referrer name="operator&lt;(_:,Float:)"/>
			<referrer name="operator&lt;=(Float:,Float:)"/>
			<referrer name="operator&lt;=(Float:,_:)"/>
			<referrer name="operator&lt;=(_:,Float:)"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:floatdiv" syntax="floatdiv(dividend, divisor)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator/(Float:,_:)"/>
			<referrer name="operator/(_:,Float:)"/>
			<param name="dividend">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="divisor">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:floatmul" syntax="floatmul(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator*(Float:,_:)"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:floatpower" syntax="floatpower(value, exponent)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="RandomFloat"/>
			<param name="value">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="exponent">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:floatround" syntax="floatround(value, method)">
			<attribute name="native"/>
			<referrer name="RandomFloat"/>
			<param name="value">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="method">
				<paraminfo>floatround_method </paraminfo>
			</param>
		</member>
		<member name="M:floatstr" syntax="floatstr(string[])">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="LoadStaticVehiclesFromFile"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:floatsub" syntax="floatsub(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator-(Float:,_:)"/>
			<referrer name="operator-(_:,Float:)"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:fopen" syntax="fopen(name[], mode)">
			<tagname value="File"/>
			<attribute name="native"/>
			<referrer name="LoadStaticVehiclesFromFile"/>
			<referrer name="DisasmWrite"/>
			<referrer name="ProfilerWriteData"/>
			<referrer name="ftouch"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="mode">
				<paraminfo>filemode </paraminfo>
			</param>
		</member>
		<member name="M:format" syntax="format(output[], len, format[], ...)">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="Debug_PrintArray"/>
			<referrer name="ProfilerWriteData"/>
			<referrer name="__TU"/>
			<referrer name="va_return"/>
			<referrer name="Bit_Display"/>
			<param name="output">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:fread" syntax="fread(handle, string[], size, pack)">
			<attribute name="native"/>
			<referrer name="LoadStaticVehiclesFromFile"/>
			<param name="handle">
				<paraminfo>File </paraminfo>
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="pack">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:ftouch" syntax="ftouch(filename[])">
			<stacksize value="5"/>
			<dependency name="fclose"/>
			<dependency name="fexist"/>
			<dependency name="fopen"/>
			<dependency name="io_write"/>
			<param name="filename">
				<paraminfo> [] </paraminfo>
				The file to "touch".
			</param>
			<summary>  ftouch(filename);  </summary>    <returns>  0 - File already exists.  1 - File was created.  -1 - File was not created.  </returns>  <remarks>  This "touches" a file in the Unix sense of creating it but not opening or  editing it in any way.  </remarks> 
		</member>
		<member name="M:funcidx" syntax="funcidx(name[])">
			<attribute name="native"/>
			<referrer name="CGen_GetAddr"/>
			<referrer name="@yH_OnScriptInit@004"/>
			<referrer name="@yH_OnScriptExit@004"/>
			<referrer name="@yH_OnMasterSystemClose@004"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:fwrite" syntax="fwrite(handle, string[])">
			<attribute name="native"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DisasmWriteDataRowChar"/>
			<referrer name="DisasmWriteDataRowHex"/>
			<referrer name="DisasmWriteData"/>
			<referrer name="ProfilerWriteData"/>
			<referrer name="va_fprintf"/>
			<param name="handle">
				<paraminfo>File </paraminfo>
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:getarg" syntax="getarg(arg, index)">
			<attribute name="native"/>
			<referrer name="AsmEmitInstruction"/>
			<referrer name="CodeScanMatcherPattern_"/>
			<referrer name="Distribute_Do"/>
			<referrer name="Distribute_So"/>
			<referrer name="Distribute_To"/>
			<param name="arg">
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:getproperty" syntax="getproperty(id, name[], value, string[])">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="Z@"/>
			<referrer name="S@"/>
			<referrer name="F@"/>
			<referrer name="Master_GetNext"/>
			<referrer name="HookChain_OnScriptInit"/>
			<referrer name="ScriptInit_OnScriptExit"/>
			<referrer name="Master_Reassert"/>
			<referrer name="_Master_Get"/>
			<referrer name="@_"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="@a"/>
			<param name="id">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="value">
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:heapspace" syntax="heapspace()">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
		</member>
		<member name="M:hexstr" syntax="hexstr(string[])">
			<stacksize value="4"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				String to convert to a number.
			</param>
			  <returns>  value of the passed hex string.  </returns>  <remarks>  Now stops on invalid characters.  </remarks> 
		</member>
		<member name="M:isNumeric" syntax="isNumeric(string[])">
			<stacksize value="4"/>
			<referrer name="ReturnUser"/>
			<dependency name="false"/>
			<dependency name="strlen"/>
			<dependency name="true"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:ishex" syntax="ishex(str[])">
			<stacksize value="3"/>
			<dependency name="cellmin"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to check.
			</param>
			  <returns>  true/false.  </returns> 
		</member>
		<member name="M:isnumeric" syntax="isnumeric(str[])">
			<stacksize value="2"/>
			<dependency name="cellmin"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to check
			</param>
			  <remarks>  Checks if a given string is numeric.  </remarks> 
		</member>
		<member name="M:ispacked" syntax="ispacked(string[])">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="Puny_EncodeHash"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:main" syntax="main()">
			<attribute name="entry"/>
			<stacksize value="3"/>
			<dependency name="print"/>
		</member>
		<member name="M:max" syntax="max(value1, value2)">
			<attribute name="native"/>
			<referrer name="YVA2_FoundPush"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="Command_Add"/>
			<param name="value1">
			</param>
			<param name="value2">
			</param>
		</member>
		<member name="M:memcpy" syntax="memcpy(dest[], source[], index, numbytes, maxlength)">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="StripL"/>
			<referrer name="Strip"/>
			<referrer name="rawMemcpy"/>
			<referrer name="YVA2_DoPush"/>
			<referrer name="Iter_Init_Internal"/>
			<referrer name="Iter_YieldLoop"/>
			<referrer name="Iter_YieldReturn"/>
			<referrer name="_@_y_distribute_@_"/>
			<referrer name="Distribute_To"/>
			<referrer name="Group_Handoff"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="index">
			</param>
			<param name="numbytes">
			</param>
			<param name="maxlength">
			</param>
		</member>
		<member name="M:memset" syntax="memset(arr[], val, size)">
			<stacksize value="7"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="rawMemset"/>
			<referrer name="Bit_SetAll"/>
			<dependency name="rawMemset"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				Array or address to set to a value.
			</param>
			<param name="val">
			</param>
			<param name="size">
			</param>
			  <param name="iValue">What to set the cells to.</param>  <param name="iSize">Number of cells to fill.</param>  <remarks>  Based on code by Slice:  <a href="http://forum.sa-mp.com/showthread.php?p=1606781#post1606781" />  Modified to use binary flags instead of a loop.  "memset" takes an array, the size of the array, and a value to fill it with  and sets the whole array to that value.  "rawmemset" is similar, but takes an AMX data segment address instead and  the size is in bytes, not cells.  However, the size must still be a multiple  of 4.  </remarks> 
		</member>
		<member name="M:min" syntax="min(value1, value2)">
			<attribute name="native"/>
			<referrer name="DisasmWriteData"/>
			<referrer name="CodeScanAddJumpTarget"/>
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="YHash"/>
			<referrer name="HashMap_RemoveValue"/>
			<referrer name="Distribute_To"/>
			<referrer name="Group_Handoff"/>
			<param name="value1">
			</param>
			<param name="value2">
			</param>
		</member>
		<member name="M:new_pec" syntax="new_pec(index, address, code_start)">
			<stacksize value="13"/>
			<referrer name="ProfilerInit"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_PUSH_C"/>
			<dependency name="ProfEntryCode"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="enter_public"/>
			<dependency name="g_num_pecs"/>
			<dependency name="g_pecs"/>
			<dependency name="g_pecs"/>
			<dependency name="pec_call"/>
			<dependency name="pec_call_enter"/>
			<dependency name="pec_push_8"/>
			<dependency name="pec_push_address"/>
			<dependency name="pec_push_c0"/>
			<dependency name="pec_push_c1"/>
			<dependency name="pec_push_c2"/>
			<dependency name="pec_push_index"/>
			<param name="index">
			</param>
			<param name="address">
			</param>
			<param name="code_start">
			</param>
		</member>
		<member name="M:numargs" syntax="numargs()">
			<attribute name="native"/>
			<referrer name="refabs"/>
			<referrer name="ref"/>
			<referrer name="AsmEmitInstruction"/>
			<referrer name="CodeScanMatcherPattern_"/>
		</member>
		<member name="M:print" syntax="print(string[])">
			<attribute name="native"/>
			<referrer name="ScriptInit_OnScriptInit"/>
			<referrer name="YVers_Callback"/>
			<referrer name="DumpStack"/>
			<referrer name="PrintStackTrace"/>
			<referrer name="va_print"/>
			<referrer name="main"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:printf" syntax="printf(format[], ...)">
			<attribute name="native"/>
			<referrer name="LoadStaticVehiclesFromFile"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="YVers_Callback"/>
			<referrer name="Debug_Print0"/>
			<referrer name="PrintAmxHeader"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="enter_public"/>
			<referrer name="ProfilerInit"/>
			<referrer name="DumpStack"/>
			<referrer name="PrintStackTrace"/>
			<referrer name="_Group_IncludeAll_1"/>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:random" syntax="random(max)">
			<attribute name="native"/>
			<referrer name="Random"/>
			<referrer name="RandomFloat"/>
			<referrer name="Iter_Random_Internal"/>
			<referrer name="Iter_RandomFree_InternalC"/>
			<referrer name="Iter_Func@Random"/>
			<param name="max">
			</param>
		</member>
		<member name="M:rawMemcpy" syntax="rawMemcpy(dest, src, bytes)">
			<stacksize value="1"/>
			<referrer name="HashMap_Add"/>
			<referrer name="HashMap_RemoveValue"/>
			<dependency name="memcpy"/>
			<param name="dest">
				Destination address.
			</param>
			<param name="src">
				Source data.
			</param>
			<param name="bytes">
				Number of bytes to copy.
			</param>
			<summary>  rawMemcpy  </summary>        <remarks>  Like memcpy, but takes addresses instead of arrays.  Also far less secure.  </remarks> 
		</member>
		<member name="M:rawMemset" syntax="rawMemset(iAddress, iValue, iSize)">
			<stacksize value="28"/>
			<referrer name="memset"/>
			<referrer name="rawMemset"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmEmitAnd"/>
			<dependency name="AsmEmitConstAlt"/>
			<dependency name="AsmEmitFill"/>
			<dependency name="AsmEmitLoadPri"/>
			<dependency name="AsmEmitLoadSAlt"/>
			<dependency name="AsmEmitLoadSPri"/>
			<dependency name="AsmEmitProc"/>
			<dependency name="AsmEmitRetn"/>
			<dependency name="AsmEmitShlCPri"/>
			<dependency name="AsmEmitStorPri"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="memset"/>
			<param name="iAddress">
				Array or address to set to a value.
			</param>
			<param name="iValue">
				What to set the cells to.
			</param>
			<param name="iSize">
				Number of cells to fill.
			</param>
			      <remarks>  Based on code by Slice:  <a href="http://forum.sa-mp.com/showthread.php?p=1606781#post1606781" />  Modified to use binary flags instead of a loop.  "memset" takes an array, the size of the array, and a value to fill it with  and sets the whole array to that value.  "rawmemset" is similar, but takes an AMX data segment address instead and  the size is in bytes, not cells.  However, the size must still be a multiple  of 4.  </remarks> 
		</member>
		<member name="M:ref" syntax="ref(...)">
			<stacksize value="2"/>
			<referrer name="AsmRaiseError"/>
			<referrer name="AsmInit"/>
			<referrer name="CodeScanAddMatcher"/>
			<referrer name="YVA2_CodeGenMainCleanup"/>
			<referrer name="HashMap_Add"/>
			<referrer name="HashMap_GetWithHash"/>
			<referrer name="HashMap_RemoveKeyWithHash"/>
			<referrer name="HashMap_RemoveValue"/>
			<dependency name="numargs"/>
			<param name="...">
			</param>
		</member>
		<member name="M:refabs" syntax="refabs(...)">
			<stacksize value="5"/>
			<referrer name="GetAmxAddress"/>
			<dependency name="RelToAbs"/>
			<dependency name="numargs"/>
			<param name="...">
			</param>
		</member>
		<member name="M:returnstringarg" syntax="returnstringarg(idx)">
			<stacksize value="145"/>
			<dependency name="returnstringarg"/>
			<dependency name="strcat"/>
			<param name="idx">
				Index of the string in the parameters.
			</param>
			  <returns>  string  </returns>  <remarks>  Is passed the result of getarg, which will be the address of a string (in  theory) and uses that for DMA to get the string.  </remarks> 
		</member>
		<member name="M:setarg" syntax="setarg(arg, index, value)">
			<attribute name="native"/>
			<referrer name="Iter_Clear_InternalC"/>
			<param name="arg">
			</param>
			<param name="index">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:setproperty" syntax="setproperty(id, name[], value, string[])">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="X@"/>
			<referrer name="Y@"/>
			<referrer name="Z@"/>
			<referrer name="S@"/>
			<referrer name="R@"/>
			<referrer name="HookChain_OnScriptInit"/>
			<referrer name="ScriptInit_OnScriptExit"/>
			<referrer name="Master_Reassert"/>
			<referrer name="_Master_Get"/>
			<referrer name="@_"/>
			<referrer name="@a"/>
			<param name="id">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="value">
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:strcat" syntax="strcat(dest[], source[], maxlength)">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="__CompilerStringReturn"/>
			<referrer name="DisasmGetInsnName"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanGetMatchName"/>
			<referrer name="returnstringarg"/>
			<referrer name="va_getstring"/>
			<referrer name="Hooks_GetPreHooks"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="Puny_Decode"/>
			<referrer name="Puny_EncodeHash"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="maxlength">
			</param>
		</member>
		<member name="M:strcmp" syntax="strcmp(string1[], string2[], ignorecase, length)">
			<attribute name="native"/>
			<referrer name="ReturnUser"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="YVers_Callback"/>
			<referrer name="AMX_GetEntry"/>
			<referrer name="AMX_GetName"/>
			<referrer name="boolstr"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="HashMap_Add"/>
			<referrer name="HashMap_GetWithHash"/>
			<referrer name="HashMap_RemoveKeyWithHash"/>
			<param name="string1">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="string2">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="ignorecase">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="length">
			</param>
		</member>
		<member name="M:strdel" syntax="strdel(string[], start, end)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="Hooks_IsolateName"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="end">
			</param>
		</member>
		<member name="M:strfind" syntax="strfind(string[], sub[], ignorecase, pos)">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="YVers_Callback"/>
			<referrer name="AMX_GetEntry"/>
			<referrer name="AMX_GetName"/>
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="Hooks_IsolateName"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="sub">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="ignorecase">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="pos">
			</param>
		</member>
		<member name="M:strins" syntax="strins(string[], substr[], pos, maxlength)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<referrer name="Puny_Decode"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="substr">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="pos">
			</param>
			<param name="maxlength">
			</param>
		</member>
		<member name="M:strlen" syntax="strlen(string[])">
			<attribute name="native"/>
			<referrer name="strtok"/>
			<referrer name="strrest"/>
			<referrer name="isNumeric"/>
			<referrer name="ReturnUser"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="StripNL"/>
			<referrer name="StripL"/>
			<referrer name="Strip"/>
			<referrer name="endofline"/>
			<referrer name="chrfind"/>
			<referrer name="unpack"/>
			<referrer name="va_strlen"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_Collate"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="YHash"/>
			<referrer name="Puny_Decode"/>
			<referrer name="Puny_Encode"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:strpack" syntax="strpack(dest[], source[], maxlength)">
			<attribute name="native"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Puny_EncodeHash"/>
			<referrer name="Command_AddAlt"/>
			<referrer name="@yH_OnMasterSystemClose@004"/>
			<referrer name="_Command_Rebuild"/>
			<referrer name="Command_Add"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="maxlength">
			</param>
		</member>
		<member name="M:strrest" syntax="strrest(string[], &amp;index)">
			<stacksize value="131"/>
			<dependency name="EOS"/>
			<dependency name="strlen"/>
			<dependency name="strrest"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="index">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:strtok" syntax="strtok(string[], &amp;index)">
			<stacksize value="23"/>
			<dependency name="EOS"/>
			<dependency name="strlen"/>
			<dependency name="strtok"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="index">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:strunpack" syntax="strunpack(dest[], source[], maxlength)">
			<attribute name="native"/>
			<referrer name="_@_y_funcinc_@_"/>
			<referrer name="unpack"/>
			<referrer name="S@"/>
			<referrer name="F@"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_Collate"/>
			<referrer name="Puny_EncodeHash"/>
			<referrer name="Command_ReProcess"/>
			<referrer name="Command_GetName"/>
			<referrer name="Command_GetNext"/>
			<referrer name="_Command_GetDisplay"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="maxlength">
			</param>
		</member>
		<member name="M:strval" syntax="strval(string[])">
			<attribute name="native"/>
			<referrer name="LoadStaticVehiclesFromFile"/>
			<referrer name="ReturnUser"/>
			<referrer name="IPToInt"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:tickcount" syntax="tickcount(&amp;granularity)">
			<attribute name="native"/>
			<referrer name="exit_public"/>
			<referrer name="enter_public"/>
			<param name="granularity">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:token_by_delim" syntax="token_by_delim(string[], return_str[], delim, start_index)">
			<stacksize value="2"/>
			<referrer name="LoadStaticVehiclesFromFile"/>
			<dependency name="EOS"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="return_str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="delim">
			</param>
			<param name="start_index">
			</param>
		</member>
		<member name="M:tolower" syntax="tolower(c)">
			<attribute name="native"/>
			<referrer name="StrToLower"/>
			<referrer name="Puny_EncodeHash"/>
			<referrer name="@yH_OnScriptInit@004"/>
			<param name="c">
			</param>
		</member>
		<member name="M:toupper" syntax="toupper(c)">
			<attribute name="native"/>
			<referrer name="StrToUpper"/>
			<referrer name="YHash"/>
			<param name="c">
			</param>
		</member>
		<member name="M:u@" syntax="u@(u[])">
			<stacksize value="1"/>
			<param name="u">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:unpack" syntax="unpack(str[])">
			<stacksize value="149"/>
			<referrer name="Hooks_IsolateName"/>
			<dependency name="strlen"/>
			<dependency name="strunpack"/>
			<dependency name="unpack"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to unpack
			</param>
			  <returns>  unpacked string  </returns>  <remarks>  Mainly used for debugging.  </remarks> 
		</member>
		<member name="M:va_CreatePlayerTextDraw" syntax="va_CreatePlayerTextDraw(playerid, x, y, fmat[], ...)">
			<tagname value="PlayerText"/>
			<stacksize value="160"/>
			<dependency name="CreatePlayerTextDraw"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<param name="playerid">
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_GameTextForAll" syntax="va_GameTextForAll(fmat[], time, style, ...)">
			<stacksize value="157"/>
			<dependency name="GameTextForAll"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="time">
			</param>
			<param name="style">
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_GameTextForPlayer" syntax="va_GameTextForPlayer(playerid, fmat[], time, style, ...)">
			<stacksize value="158"/>
			<dependency name="GameTextForPlayer"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<param name="playerid">
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="time">
			</param>
			<param name="style">
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_SendClientMessage" syntax="va_SendClientMessage(playerid, colour, fmat[], ...)">
			<stacksize value="159"/>
			<dependency name="SendClientMessage"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<param name="playerid">
			</param>
			<param name="colour">
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_SendClientMessageToAll" syntax="va_SendClientMessageToAll(colour, fmat[], ...)">
			<stacksize value="158"/>
			<dependency name="SendClientMessageToAll"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<param name="colour">
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_SendPlayerMessageToAll" syntax="va_SendPlayerMessageToAll(senderid, fmat[], ...)">
			<stacksize value="158"/>
			<dependency name="SendPlayerMessageToAll"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<param name="senderid">
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_SendPlayerMessageToPlayer" syntax="va_SendPlayerMessageToPlayer(playerid, senderid, fmat[], ...)">
			<stacksize value="159"/>
			<dependency name="SendPlayerMessageToPlayer"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<param name="playerid">
			</param>
			<param name="senderid">
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_TextDrawCreate" syntax="va_TextDrawCreate(x, y, fmat[], ...)">
			<tagname value="Text"/>
			<stacksize value="159"/>
			<dependency name="TextDrawCreate"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="va_return"/>
			<param name="x">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_formatex" syntax="va_formatex(output[], size, fmat[], STATIC_ARGS)">
			<stacksize value="1"/>
			<param name="output">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="STATIC_ARGS">
				<paraminfo>va_ </paraminfo>
			</param>
		</member>
		<member name="M:va_fprintf" syntax="va_fprintf(fhnd, fmat[], ...)">
			<stacksize value="158"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="fwrite"/>
			<dependency name="va_return"/>
			<param name="fhnd">
				<paraminfo>File </paraminfo>
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_getstring" syntax="va_getstring(dest[], arg, len)">
			<stacksize value="1"/>
			<dependency name="strcat"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="arg">
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:va_print" syntax="va_print(fmat[], ...)">
			<stacksize value="157"/>
			<dependency name="YVA2_DummyPush"/>
			<dependency name="print"/>
			<dependency name="va_return"/>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:va_return" syntax="va_return(fmat[], ...)">
			<stacksize value="145"/>
			<referrer name="va_CreatePlayerTextDraw"/>
			<referrer name="va_TextDrawCreate"/>
			<referrer name="va_SendClientMessage"/>
			<referrer name="va_SendClientMessageToAll"/>
			<referrer name="va_SendPlayerMessageToPlayer"/>
			<referrer name="va_SendPlayerMessageToAll"/>
			<referrer name="va_GameTextForPlayer"/>
			<referrer name="va_GameTextForAll"/>
			<referrer name="va_print"/>
			<referrer name="va_fprintf"/>
			<dependency name="format"/>
			<dependency name="va_return"/>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
				String format.
			</param>
			<param name="...">
				<paraminfo> {_,Language,Bit,Text,Menu,Style,XML,Bintree,Group,Timer,File,Float,Text3D} </paraminfo>
				Parameters.
			</param>
			    <returns>  Formatted string.  </returns>  <remarks>  Just wraps `format` and returns a string instead.  Has extra code to ensure that it works correct on the old compiler.  </remarks> 
		</member>
		<member name="M:va_strlen" syntax="va_strlen(arg)">
			<stacksize value="1"/>
			<dependency name="strlen"/>
			<param name="arg">
			</param>
		</member>

	</members>
</doc>
